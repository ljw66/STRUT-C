func_name,FUT,seed case,prompts,outputs
aes,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void xor_buf(const BYTE in[], BYTE out[], size_t len) 
{ 
 size_t idx; 
 for (idx = 0; idx < len; idx++) 
  out[idx] ^= in[idx]; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void xor_buf(const BYTE in[], BYTE out[], size_t len) 
{ 
 size_t idx; 
 for (idx = 0; idx < len; idx++) 
  out[idx] ^= in[idx]; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""xor_buf"", ""file"": """", ""cases"": [{""desc"": ""Test with zero length"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with non-zero length and identical input and output"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 3}], ""stubins"": [], ""outputs"": [{""expr"": ""out"", ""value"": ""\""\\x00\\x00\\x00\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with non-zero length and different input and output"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""out"", ""value"": ""def""}, {""expr"": ""len"", ""value"": 3}], ""stubins"": [], ""outputs"": [{""expr"": ""out"", ""value"": ""\""\\x05\\x03\\x05\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input and output buffers containing zero bytes"", ""inputs"": [{""expr"": ""in"", ""value"": ""\\x00\\x00\\x00""}, {""expr"": ""out"", ""value"": ""\\x00\\x00\\x00""}, {""expr"": ""len"", ""value"": 3}], ""stubins"": [], ""outputs"": [{""expr"": ""out"", ""value"": ""\""\\x00\\x00\\x00\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input buffer containing zero bytes and non-zero output buffer"", ""inputs"": [{""expr"": ""in"", ""value"": ""\\x00\\x00\\x00""}, {""expr"": ""out"", ""value"": ""\\x01\\x02\\x03""}, {""expr"": ""len"", ""value"": 3}], ""stubins"": [], ""outputs"": [{""expr"": ""out"", ""value"": ""\""\\x01\\x02\\x03\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with larger buffer"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefgh""}, {""expr"": ""out"", ""value"": ""hgfedcba""}, {""expr"": ""len"", ""value"": 8}], ""stubins"": [], ""outputs"": [{""expr"": ""out"", ""value"": ""\""\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with single byte buffer"", ""inputs"": [{""expr"": ""in"", ""value"": ""a""}, {""expr"": ""out"", ""value"": ""b""}, {""expr"": ""len"", ""value"": 1}], ""stubins"": [], ""outputs"": [{""expr"": ""out"", ""value"": ""\""\\x03\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
int aes_encrypt_cbc(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 BYTE buf_in[16], buf_out[16], iv_buf[16]; 
 int blocks, idx; 
 if (in_len % 16 != 0) 
  return(0); 
 blocks = in_len / 16; 
 memcpy(iv_buf, iv, 16); 
 for (idx = 0; idx < blocks; idx++) { 
  memcpy(buf_in, &in[idx * 16], 16); 
  xor_buf(iv_buf, buf_in, 16); 
  aes_encrypt(buf_in, buf_out, key, keysize); 
  memcpy(&out[idx * 16], buf_out, 16); 
  memcpy(iv_buf, buf_out, 16); 
 } 
 return(1); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void xor_buf(const BYTE *in,BYTE *out,size_t len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_encrypt(const BYTE *in,BYTE *out,const WORD *key,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
int aes_encrypt_cbc(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 BYTE buf_in[16], buf_out[16], iv_buf[16]; 
 int blocks, idx; 
 if (in_len % 16 != 0) 
  return(0); 
 blocks = in_len / 16; 
 memcpy(iv_buf, iv, 16); 
 for (idx = 0; idx < blocks; idx++) { 
  memcpy(buf_in, &in[idx * 16], 16); 
  xor_buf(iv_buf, buf_in, 16); 
  aes_encrypt(buf_in, buf_out, key, keysize); 
  memcpy(&out[idx * 16], buf_out, 16); 
  memcpy(iv_buf, buf_out, 16); 
 } 
 return(1); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void xor_buf(const BYTE *in,BYTE *out,size_t len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_encrypt(const BYTE *in,BYTE *out,const WORD *key,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}
{other test cases}
","{""func"": ""aes_encrypt_cbc"", ""file"": """", ""cases"": [{""desc"": ""Input length not multiple of 16"", ""inputs"": [{""expr"": ""in"", ""value"": ""1234567890""}, {""expr"": ""in_len"", ""value"": 10}, {""expr"": ""out"", ""value"": ""0000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": 0}, {""expr"": ""key_PTRTO[1]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 0}, {""expr"": ""iv"", ""value"": ""0000000000000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Single block encryption"", ""inputs"": [{""expr"": ""in"", ""value"": ""1234567890123456""}, {""expr"": ""in_len"", ""value"": 16}, {""expr"": ""out"", ""value"": ""0000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": 1}, {""expr"": ""key_PTRTO[1]"", ""value"": 2}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""0000000000000000""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""iv_buf\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""iv\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": ""\""1234567890123456\"""", ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": ""\""1234567890123456\"""", ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": ""\""1234567890123456\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": ""\""encryptedData\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": ""\""key\"""", ""funcName"": ""aes_encrypt""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Multiple blocks encryption"", ""inputs"": [{""expr"": ""in"", ""value"": ""12345678901234567890123456789012""}, {""expr"": ""in_len"", ""value"": 32}, {""expr"": ""out"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": 1}, {""expr"": ""key_PTRTO[1]"", ""value"": 2}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""0000000000000000""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""iv_buf\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""iv\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": ""\""1234567890123456\"""", ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": ""\""1234567890123456\"""", ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": ""\""1234567890123456\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": ""\""encryptedBlock1\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": ""\""key\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""returnValue"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""iv_buf\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""encryptedBlock1\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": ""\""7890123456789012\"""", ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": ""\""7890123456789012\"""", ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": ""\""7890123456789012\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": ""\""encryptedBlock2\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": ""\""key\"""", ""funcName"": ""aes_encrypt""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Zero length input"", ""inputs"": [{""expr"": ""in_len"", ""value"": 0}, {""expr"": ""key_PTRTO[0]"", ""value"": 1}, {""expr"": ""key_PTRTO[1]"", ""value"": 2}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""0000000000000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Non-zero length input not multiple of 16"", ""inputs"": [{""expr"": ""in"", ""value"": ""12345678901234567""}, {""expr"": ""in_len"", ""value"": 17}, {""expr"": ""out"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": 1}, {""expr"": ""key_PTRTO[1]"", ""value"": 2}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""0000000000000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Encryption with non-zero IV"", ""inputs"": [{""expr"": ""in"", ""value"": ""1234567890123456""}, {""expr"": ""in_len"", ""value"": 16}, {""expr"": ""out"", ""value"": ""0000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": 1}, {""expr"": ""key_PTRTO[1]"", ""value"": 2}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""1111111111111111""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""1111111111111111\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""iv_buf\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""iv\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": ""\""1234567890123456\"""", ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": ""\""0011111111111111\"""", ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": ""\""0011111111111111\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": ""\""encryptedData\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": ""\""key\"""", ""funcName"": ""aes_encrypt""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""key"", ""userVar"": ""key_PTRTO""}], ""ios"": []}"
aes,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
int aes_encrypt_cbc_mac(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 BYTE buf_in[16], buf_out[16], iv_buf[16]; 
 int blocks, idx; 
 if (in_len % 16 != 0) 
  return(0); 
 blocks = in_len / 16; 
 memcpy(iv_buf, iv, 16); 
 for (idx = 0; idx < blocks; idx++) { 
  memcpy(buf_in, &in[idx * 16], 16); 
  xor_buf(iv_buf, buf_in, 16); 
  aes_encrypt(buf_in, buf_out, key, keysize); 
  memcpy(iv_buf, buf_out, 16); 
 } 
 memcpy(out, buf_out, 16); 
 return(1); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void xor_buf(const BYTE *in,BYTE *out,size_t len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_encrypt(const BYTE *in,BYTE *out,const WORD *key,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
int aes_encrypt_cbc_mac(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 BYTE buf_in[16], buf_out[16], iv_buf[16]; 
 int blocks, idx; 
 if (in_len % 16 != 0) 
  return(0); 
 blocks = in_len / 16; 
 memcpy(iv_buf, iv, 16); 
 for (idx = 0; idx < blocks; idx++) { 
  memcpy(buf_in, &in[idx * 16], 16); 
  xor_buf(iv_buf, buf_in, 16); 
  aes_encrypt(buf_in, buf_out, key, keysize); 
  memcpy(iv_buf, buf_out, 16); 
 } 
 memcpy(out, buf_out, 16); 
 return(1); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void xor_buf(const BYTE *in,BYTE *out,size_t len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_encrypt(const BYTE *in,BYTE *out,const WORD *key,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}
{other test cases}
","{""func"": ""aes_encrypt_cbc_mac"", ""file"": """", ""cases"": [{""desc"": ""Test case where input length is not a multiple of 16"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""in_len"", ""value"": 10}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""key_PTRTO[0]"", ""value"": 0}, {""expr"": ""key_PTRTO[1]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 0}, {""expr"": ""iv"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with valid input length and keysize"", ""inputs"": [{""expr"": ""in"", ""value"": ""0123456789abcdef0123456789abcdef""}, {""expr"": ""in_len"", ""value"": 32}, {""expr"": ""out"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": 1}, {""expr"": ""key_PTRTO[1]"", ""value"": 2}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""abcdef0123456789""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": ""\""encrypteddata\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with zero input length"", ""inputs"": [{""expr"": ""in_len"", ""value"": 0}, {""expr"": ""out"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": 1}, {""expr"": ""key_PTRTO[1]"", ""value"": 2}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""abcdef0123456789""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with valid input and different key size"", ""inputs"": [{""expr"": ""in"", ""value"": ""0123456789abcdef0123456789abcdef""}, {""expr"": ""in_len"", ""value"": 32}, {""expr"": ""out"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": 3}, {""expr"": ""key_PTRTO[1]"", ""value"": 4}, {""expr"": ""keysize"", ""value"": 256}, {""expr"": ""iv"", ""value"": ""abcdef0123456789""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": ""\""encrypteddata256\"""", ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""key"", ""userVar"": ""key_PTRTO""}], ""ios"": []}"
aes,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
int aes_decrypt_cbc(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 BYTE buf_in[16], buf_out[16], iv_buf[16]; 
 int blocks, idx; 
 if (in_len % 16 != 0) 
  return(0); 
 blocks = in_len / 16; 
 memcpy(iv_buf, iv, 16); 
 for (idx = 0; idx < blocks; idx++) { 
  memcpy(buf_in, &in[idx * 16], 16); 
  aes_decrypt(buf_in, buf_out, key, keysize); 
  xor_buf(iv_buf, buf_out, 16); 
  memcpy(&out[idx * 16], buf_out, 16); 
  memcpy(iv_buf, buf_in, 16); 
 } 
 return(1); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void xor_buf(const BYTE *in,BYTE *out,size_t len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_decrypt(const BYTE *in,BYTE *out,const WORD *key,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
int aes_decrypt_cbc(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 BYTE buf_in[16], buf_out[16], iv_buf[16]; 
 int blocks, idx; 
 if (in_len % 16 != 0) 
  return(0); 
 blocks = in_len / 16; 
 memcpy(iv_buf, iv, 16); 
 for (idx = 0; idx < blocks; idx++) { 
  memcpy(buf_in, &in[idx * 16], 16); 
  aes_decrypt(buf_in, buf_out, key, keysize); 
  xor_buf(iv_buf, buf_out, 16); 
  memcpy(&out[idx * 16], buf_out, 16); 
  memcpy(iv_buf, buf_in, 16); 
 } 
 return(1); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void xor_buf(const BYTE *in,BYTE *out,size_t len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_decrypt(const BYTE *in,BYTE *out,const WORD *key,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}
{other test cases}
","{""func"": ""aes_decrypt_cbc"", ""file"": """", ""cases"": [{""desc"": ""Test case where input length is not a multiple of 16"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcd""}, {""expr"": ""in_len"", ""value"": 15}, {""expr"": ""out"", ""value"": ""abcd""}, {""expr"": ""key_PTRTO[0]"", ""value"": 0}, {""expr"": ""key_PTRTO[1]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 16}, {""expr"": ""iv"", ""value"": ""abcd""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with valid input length and key size"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""in_len"", ""value"": 16}, {""expr"": ""out"", ""value"": ""                ""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x12345678""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x9abcdef0""}, {""expr"": ""keysize"", ""value"": 16}, {""expr"": ""iv"", ""value"": ""1234567890abcdef""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""anony_param_0\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""iv_buf\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""iv\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_decrypt""}, {""expr"": ""*in"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""aes_decrypt""}, {""expr"": ""*out"", ""value"": ""\""decrypteddata\"""", ""funcName"": ""aes_decrypt""}, {""expr"": ""*key"", ""value"": ""0x12345678"", ""funcName"": ""aes_decrypt""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": ""\""iv_buf\"""", ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": ""\""xoreddata\"""", ""funcName"": ""xor_buf""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with multiple blocks"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefghijklmnopqrstuvwx""}, {""expr"": ""in_len"", ""value"": 24}, {""expr"": ""out"", ""value"": ""                        ""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x11111111""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x22222222""}, {""expr"": ""keysize"", ""value"": 16}, {""expr"": ""iv"", ""value"": ""abcdefabcdefabcdef""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""anony_param_0\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""iv_buf\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""iv\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_decrypt""}, {""expr"": ""*in"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""aes_decrypt""}, {""expr"": ""*out"", ""value"": ""\""decrypteddata1\"""", ""funcName"": ""aes_decrypt""}, {""expr"": ""*key"", ""value"": ""0x11111111"", ""funcName"": ""aes_decrypt""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": ""\""iv_buf\"""", ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": ""\""xoreddata1\"""", ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_decrypt""}, {""expr"": ""*in"", ""value"": ""\""qrstuvwx\"""", ""funcName"": ""aes_decrypt""}, {""expr"": ""*out"", ""value"": ""\""decrypteddata2\"""", ""funcName"": ""aes_decrypt""}, {""expr"": ""*key"", ""value"": ""0x11111111"", ""funcName"": ""aes_decrypt""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": ""\""decrypteddata1\"""", ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": ""\""xoreddata2\"""", ""funcName"": ""xor_buf""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with zero input length"", ""inputs"": [{""expr"": ""in_len"", ""value"": 0}, {""expr"": ""key_PTRTO[0]"", ""value"": 0}, {""expr"": ""key_PTRTO[1]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 16}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""key"", ""userVar"": ""key_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void increment_iv(BYTE iv[], int counter_size) 
{ 
 int idx; 
 for (idx = 16 - 1; idx >= 16 - counter_size; idx--) { 
  iv[idx]++; 
  if (iv[idx] != 0 || idx == 16 - counter_size) 
   break; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""iv"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""counter_size"", ""type"": ""int"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void increment_iv(BYTE iv[], int counter_size) 
{ 
 int idx; 
 for (idx = 16 - 1; idx >= 16 - counter_size; idx--) { 
  iv[idx]++; 
  if (iv[idx] != 0 || idx == 16 - counter_size) 
   break; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""iv"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""counter_size"", ""type"": ""int"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""increment_iv"", ""file"": """", ""cases"": [{""desc"": ""Test case 1: No increment due to counter_size being zero"", ""inputs"": [{""expr"": ""iv"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]""}, {""expr"": ""counter_size"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""iv"", ""value"": ""\""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 2: Increment last byte only"", ""inputs"": [{""expr"": ""iv"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]""}, {""expr"": ""counter_size"", ""value"": 1}], ""stubins"": [], ""outputs"": [{""expr"": ""iv"", ""value"": ""\""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 3: Increment with carry to next byte"", ""inputs"": [{""expr"": ""iv"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255]""}, {""expr"": ""counter_size"", ""value"": 2}], ""stubins"": [], ""outputs"": [{""expr"": ""iv"", ""value"": ""\""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 4: Full counter_size increment"", ""inputs"": [{""expr"": ""iv"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255]""}, {""expr"": ""counter_size"", ""value"": 2}], ""stubins"": [], ""outputs"": [{""expr"": ""iv"", ""value"": ""\""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 5: Increment with partial carry"", ""inputs"": [{""expr"": ""iv"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255]""}, {""expr"": ""counter_size"", ""value"": 3}], ""stubins"": [], ""outputs"": [{""expr"": ""iv"", ""value"": ""\""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 6: Increment entire array"", ""inputs"": [{""expr"": ""iv"", ""value"": ""[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]""}, {""expr"": ""counter_size"", ""value"": 16}], ""stubins"": [], ""outputs"": [{""expr"": ""iv"", ""value"": ""\""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 7: Increment with no carry"", ""inputs"": [{""expr"": ""iv"", ""value"": ""[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]""}, {""expr"": ""counter_size"", ""value"": 4}], ""stubins"": [], ""outputs"": [{""expr"": ""iv"", ""value"": ""\""[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17]\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void aes_encrypt_ctr(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 size_t idx = 0, last_block_length; 
 BYTE iv_buf[16], out_buf[16]; 
 if (in != out) 
  memcpy(out, in, in_len); 
 memcpy(iv_buf, iv, 16); 
 last_block_length = in_len - 16; 
 if (in_len > 16) { 
  for (idx = 0; idx < last_block_length; idx += 16) { 
   aes_encrypt(iv_buf, out_buf, key, keysize); 
   xor_buf(out_buf, &out[idx], 16); 
   increment_iv(iv_buf, 16); 
  } 
 } 
 aes_encrypt(iv_buf, out_buf, key, keysize); 
 xor_buf(out_buf, &out[idx], in_len - idx); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void increment_iv(BYTE *iv,int counter_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void xor_buf(const BYTE *in,BYTE *out,size_t len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_encrypt(const BYTE *in,BYTE *out,const WORD *key,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void aes_encrypt_ctr(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 size_t idx = 0, last_block_length; 
 BYTE iv_buf[16], out_buf[16]; 
 if (in != out) 
  memcpy(out, in, in_len); 
 memcpy(iv_buf, iv, 16); 
 last_block_length = in_len - 16; 
 if (in_len > 16) { 
  for (idx = 0; idx < last_block_length; idx += 16) { 
   aes_encrypt(iv_buf, out_buf, key, keysize); 
   xor_buf(out_buf, &out[idx], 16); 
   increment_iv(iv_buf, 16); 
  } 
 } 
 aes_encrypt(iv_buf, out_buf, key, keysize); 
 xor_buf(out_buf, &out[idx], in_len - idx); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void increment_iv(BYTE *iv,int counter_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void xor_buf(const BYTE *in,BYTE *out,size_t len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_encrypt(const BYTE *in,BYTE *out,const WORD *key,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""aes_encrypt_ctr"", ""file"": """", ""cases"": [{""desc"": ""Test case with in_len = 0"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""in_len"", ""value"": 0}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""key_PTRTO[0]"", ""value"": 0}, {""expr"": ""key_PTRTO[1]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 0}, {""expr"": ""iv"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""*iv"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with in_len = 16"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""in_len"", ""value"": 16}, {""expr"": ""out"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x12345678""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x9abcdef0""}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""1234567890123456""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""*iv"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with in_len > 16"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefghijklmnopqrstuvwxyz""}, {""expr"": ""in_len"", ""value"": 26}, {""expr"": ""out"", ""value"": ""abcdefghijklmnopqrstuvwxyz""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x12345678""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x9abcdef0""}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""1234567890123456""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""*iv"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with in and out pointing to different buffers"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""in_len"", ""value"": 16}, {""expr"": ""out"", ""value"": ""1234567890123456""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x12345678""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x9abcdef0""}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""1234567890123456""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""*iv"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with in_len = 32"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefghijklmnopqrstuvwxyz123456""}, {""expr"": ""in_len"", ""value"": 32}, {""expr"": ""out"", ""value"": ""abcdefghijklmnopqrstuvwxyz123456""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x12345678""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x9abcdef0""}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""1234567890123456""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""*iv"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""xor_buf""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""aes_encrypt""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""aes_encrypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""key"", ""userVar"": ""key_PTRTO""}], ""ios"": []}"
aes,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void aes_decrypt_ctr(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 aes_encrypt_ctr(in, in_len, out, key, keysize, iv); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void aes_encrypt_ctr(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void aes_decrypt_ctr(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[]) 
{ 
 aes_encrypt_ctr(in, in_len, out, key, keysize, iv); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""in_len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}, {""expr"": ""iv"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void aes_encrypt_ctr(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""aes_decrypt_ctr"", ""file"": """", ""cases"": [{""desc"": ""Test with empty input and output arrays"", ""inputs"": [{""expr"": ""in_len"", ""value"": 0}, {""expr"": ""key_PTRTO[0]"", ""value"": 0}, {""expr"": ""key_PTRTO[1]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt_ctr""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with non-empty input and output arrays"", ""inputs"": [{""expr"": ""in"", ""value"": ""test input""}, {""expr"": ""in_len"", ""value"": 10}, {""expr"": ""out"", ""value"": ""output data""}, {""expr"": ""key_PTRTO[0]"", ""value"": 123456}, {""expr"": ""key_PTRTO[1]"", ""value"": 654321}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""iv"", ""value"": ""initializ""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt_ctr""}, {""expr"": ""*out"", ""value"": ""\""decrypted\"""", ""funcName"": ""aes_encrypt_ctr""}], ""outputs"": [{""expr"": ""out"", ""value"": ""\""decrypted\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with different key sizes"", ""inputs"": [{""expr"": ""in"", ""value"": ""another test""}, {""expr"": ""in_len"", ""value"": 12}, {""expr"": ""out"", ""value"": ""output data""}, {""expr"": ""key_PTRTO[0]"", ""value"": 111111}, {""expr"": ""key_PTRTO[1]"", ""value"": 222222}, {""expr"": ""keysize"", ""value"": 256}, {""expr"": ""iv"", ""value"": ""initvector""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt_ctr""}, {""expr"": ""*out"", ""value"": ""\""decrypted256\"""", ""funcName"": ""aes_encrypt_ctr""}], ""outputs"": [{""expr"": ""out"", ""value"": ""\""decrypted256\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with maximum input length"", ""inputs"": [{""expr"": ""in"", ""value"": ""maxinputdata""}, {""expr"": ""in_len"", ""value"": 1024}, {""expr"": ""out"", ""value"": ""output data""}, {""expr"": ""key_PTRTO[0]"", ""value"": 999999}, {""expr"": ""key_PTRTO[1]"", ""value"": 888888}, {""expr"": ""keysize"", ""value"": 192}, {""expr"": ""iv"", ""value"": ""maxivector""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt_ctr""}, {""expr"": ""*out"", ""value"": ""\""decryptedmax\"""", ""funcName"": ""aes_encrypt_ctr""}], ""outputs"": [{""expr"": ""out"", ""value"": ""\""decryptedmax\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""key"", ""userVar"": ""key_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
int aes_encrypt_ccm(const BYTE payload[], WORD payload_len, const BYTE assoc[], unsigned short assoc_len, 
                    const BYTE nonce[], unsigned short nonce_len, BYTE out[], WORD *out_len, 
                    WORD mac_len, const BYTE key_str[], int keysize) 
{ 
 BYTE temp_iv[16], counter[16], mac[16], *buf; 
 int end_of_buf, payload_len_store_size; 
 WORD key[60]; 
 if (mac_len != 4 && mac_len != 6 && mac_len != 8 && mac_len != 10 && 
    mac_len != 12 && mac_len != 14 && mac_len != 16) 
  return(0); 
 if (nonce_len < 7 || nonce_len > 13) 
  return(0); 
 if (assoc_len > 32768 ) 
  return(0); 
 buf = (BYTE*)malloc(payload_len + assoc_len + 48 ); 
 if (! buf) 
  return(0); 
 aes_key_setup(key_str, key, keysize); 
 payload_len_store_size = 16 - 1 - nonce_len; 
 ccm_prepare_first_format_blk(buf, assoc_len, payload_len, payload_len_store_size, mac_len, nonce, nonce_len); 
 end_of_buf = 16; 
 ccm_format_assoc_data(buf, &end_of_buf, assoc, assoc_len); 
 ccm_format_payload_data(buf, &end_of_buf, payload, payload_len); 
 ccm_prepare_first_ctr_blk(counter, nonce, nonce_len, payload_len_store_size); 
 memset(temp_iv, 0, 16); 
 aes_encrypt_cbc_mac(buf, end_of_buf, mac, key, keysize, temp_iv); 
 memcpy(out, payload, payload_len); 
 memcpy(&out[payload_len], mac, mac_len); 
 memcpy(temp_iv, counter, 16); 
 increment_iv(temp_iv, 16 - 1 - mac_len); 
 aes_encrypt_ctr(out, payload_len, out, key, keysize, temp_iv); 
 aes_encrypt_ctr(&out[payload_len], mac_len, &out[payload_len], key, keysize, counter); 
 free(buf); 
 *out_len = payload_len + mac_len; 
 return(1); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""payload"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""assoc"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""type"": ""unsigned short int"", ""value"": 0}, {""expr"": ""nonce"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""type"": ""unsigned short int"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""out_len[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""out_len[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""mac_len"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""key_str"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void increment_iv(BYTE *iv,int counter_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_key_setup(const BYTE *key,WORD *w,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*w"", ""type"": ""WORD"", ""value"": 0}]}, {""called function"": ""void * malloc(size_t anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void aes_encrypt_ctr(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""int aes_encrypt_cbc_mac(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void free(void *anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void ccm_prepare_first_ctr_blk(BYTE *counter,const BYTE *nonce,int nonce_len,int payload_len_store_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*counter"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*nonce"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_format_payload_data(BYTE *buf,int *end_of_buf,const BYTE *payload,int payload_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*end_of_buf"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*payload"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_prepare_first_format_blk(BYTE *buf,int assoc_len,int payload_len,int payload_len_store_size,int mac_len,const BYTE *nonce,int nonce_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*nonce"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void ccm_format_assoc_data(BYTE *buf,int *end_of_buf,const BYTE *assoc,int assoc_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*end_of_buf"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*assoc"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
int aes_encrypt_ccm(const BYTE payload[], WORD payload_len, const BYTE assoc[], unsigned short assoc_len, 
                    const BYTE nonce[], unsigned short nonce_len, BYTE out[], WORD *out_len, 
                    WORD mac_len, const BYTE key_str[], int keysize) 
{ 
 BYTE temp_iv[16], counter[16], mac[16], *buf; 
 int end_of_buf, payload_len_store_size; 
 WORD key[60]; 
 if (mac_len != 4 && mac_len != 6 && mac_len != 8 && mac_len != 10 && 
    mac_len != 12 && mac_len != 14 && mac_len != 16) 
  return(0); 
 if (nonce_len < 7 || nonce_len > 13) 
  return(0); 
 if (assoc_len > 32768 ) 
  return(0); 
 buf = (BYTE*)malloc(payload_len + assoc_len + 48 ); 
 if (! buf) 
  return(0); 
 aes_key_setup(key_str, key, keysize); 
 payload_len_store_size = 16 - 1 - nonce_len; 
 ccm_prepare_first_format_blk(buf, assoc_len, payload_len, payload_len_store_size, mac_len, nonce, nonce_len); 
 end_of_buf = 16; 
 ccm_format_assoc_data(buf, &end_of_buf, assoc, assoc_len); 
 ccm_format_payload_data(buf, &end_of_buf, payload, payload_len); 
 ccm_prepare_first_ctr_blk(counter, nonce, nonce_len, payload_len_store_size); 
 memset(temp_iv, 0, 16); 
 aes_encrypt_cbc_mac(buf, end_of_buf, mac, key, keysize, temp_iv); 
 memcpy(out, payload, payload_len); 
 memcpy(&out[payload_len], mac, mac_len); 
 memcpy(temp_iv, counter, 16); 
 increment_iv(temp_iv, 16 - 1 - mac_len); 
 aes_encrypt_ctr(out, payload_len, out, key, keysize, temp_iv); 
 aes_encrypt_ctr(&out[payload_len], mac_len, &out[payload_len], key, keysize, counter); 
 free(buf); 
 *out_len = payload_len + mac_len; 
 return(1); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""payload"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""assoc"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""type"": ""unsigned short int"", ""value"": 0}, {""expr"": ""nonce"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""type"": ""unsigned short int"", ""value"": 0}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""out_len[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""out_len[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""mac_len"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""key_str"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void increment_iv(BYTE *iv,int counter_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void aes_key_setup(const BYTE *key,WORD *w,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*w"", ""type"": ""WORD"", ""value"": 0}]}, {""called function"": ""void * malloc(size_t anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void aes_encrypt_ctr(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""int aes_encrypt_cbc_mac(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void free(void *anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void ccm_prepare_first_ctr_blk(BYTE *counter,const BYTE *nonce,int nonce_len,int payload_len_store_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*counter"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*nonce"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_format_payload_data(BYTE *buf,int *end_of_buf,const BYTE *payload,int payload_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*end_of_buf"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*payload"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_prepare_first_format_blk(BYTE *buf,int assoc_len,int payload_len,int payload_len_store_size,int mac_len,const BYTE *nonce,int nonce_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*nonce"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void ccm_format_assoc_data(BYTE *buf,int *end_of_buf,const BYTE *assoc,int assoc_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*end_of_buf"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*assoc"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}
{other test cases}
","{""func"": ""aes_encrypt_ccm"", ""file"": """", ""cases"": [{""desc"": ""Invalid mac_len test case"", ""inputs"": [{""expr"": ""payload"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""value"": 3}, {""expr"": ""assoc"", ""value"": ""def""}, {""expr"": ""assoc_len"", ""value"": 3}, {""expr"": ""nonce"", ""value"": ""ghi""}, {""expr"": ""nonce_len"", ""value"": 12}, {""expr"": ""out"", ""value"": ""jkl""}, {""expr"": ""out_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""out_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 5}, {""expr"": ""key_str"", ""value"": ""mno""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Invalid nonce_len test case"", ""inputs"": [{""expr"": ""payload"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""value"": 3}, {""expr"": ""assoc"", ""value"": ""def""}, {""expr"": ""assoc_len"", ""value"": 3}, {""expr"": ""nonce"", ""value"": ""ghi""}, {""expr"": ""nonce_len"", ""value"": 6}, {""expr"": ""out"", ""value"": ""jkl""}, {""expr"": ""out_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""out_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 8}, {""expr"": ""key_str"", ""value"": ""mno""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Invalid assoc_len test case"", ""inputs"": [{""expr"": ""payload"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""value"": 3}, {""expr"": ""assoc"", ""value"": ""def""}, {""expr"": ""assoc_len"", ""value"": 32769}, {""expr"": ""nonce"", ""value"": ""ghi""}, {""expr"": ""nonce_len"", ""value"": 12}, {""expr"": ""out"", ""value"": ""jkl""}, {""expr"": ""out_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""out_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 8}, {""expr"": ""key_str"", ""value"": ""mno""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Memory allocation failure test case"", ""inputs"": [{""expr"": ""payload"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""value"": 3}, {""expr"": ""assoc"", ""value"": ""def""}, {""expr"": ""assoc_len"", ""value"": 3}, {""expr"": ""nonce"", ""value"": ""ghi""}, {""expr"": ""nonce_len"", ""value"": 12}, {""expr"": ""out"", ""value"": ""jkl""}, {""expr"": ""out_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""out_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 8}, {""expr"": ""key_str"", ""value"": ""mno""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""malloc""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Successful encryption test case"", ""inputs"": [{""expr"": ""payload"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""value"": 3}, {""expr"": ""assoc"", ""value"": ""def""}, {""expr"": ""assoc_len"", ""value"": 3}, {""expr"": ""nonce"", ""value"": ""ghi""}, {""expr"": ""nonce_len"", ""value"": 12}, {""expr"": ""out"", ""value"": ""jkl""}, {""expr"": ""out_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""out_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 8}, {""expr"": ""key_str"", ""value"": ""mno""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""valid_memory_address\"""", ""funcName"": ""malloc""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_key_setup""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""ccm_prepare_first_format_blk""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""ccm_format_assoc_data""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""ccm_format_payload_data""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""ccm_prepare_first_ctr_blk""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt_cbc_mac""}, {""expr"": ""returnValue"", ""value"": ""\""valid_memory_address\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""increment_iv""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""aes_encrypt_ctr""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""free""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}, {""expr"": ""out_len[0]"", ""value"": 11}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""out_len"", ""userVar"": ""out_len_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
int aes_decrypt_ccm(const BYTE ciphertext[], WORD ciphertext_len, const BYTE assoc[], unsigned short assoc_len, 
                    const BYTE nonce[], unsigned short nonce_len, BYTE plaintext[], WORD *plaintext_len, 
                    WORD mac_len, int *mac_auth, const BYTE key_str[], int keysize) 
{ 
 BYTE temp_iv[16], counter[16], mac[16], mac_buf[16], *buf; 
 int end_of_buf, plaintext_len_store_size; 
 WORD key[60]; 
 if (ciphertext_len <= mac_len) 
  return(0); 
 buf = (BYTE*)malloc(assoc_len + ciphertext_len + 48); 
 if (! buf) 
  return(0); 
 aes_key_setup(key_str, key, keysize); 
 *plaintext_len = ciphertext_len - mac_len; 
 plaintext_len_store_size = 16 - 1 - nonce_len; 
 memcpy(plaintext, ciphertext, *plaintext_len); 
 memcpy(mac, &ciphertext[*plaintext_len], mac_len); 
 ccm_prepare_first_ctr_blk(counter, nonce, nonce_len, plaintext_len_store_size); 
 memcpy(temp_iv, counter, 16); 
 increment_iv(temp_iv, 16 - 1 - mac_len); 
 aes_decrypt_ctr(plaintext, *plaintext_len, plaintext, key, keysize, temp_iv); 
 if (mac_auth != ((void *) 0)) { 
  aes_decrypt_ctr(mac, mac_len, mac, key, keysize, counter); 
  plaintext_len_store_size = 16 - 1 - nonce_len; 
  ccm_prepare_first_format_blk(buf, assoc_len, *plaintext_len, plaintext_len_store_size, mac_len, nonce, nonce_len); 
  end_of_buf = 16; 
  ccm_format_assoc_data(buf, &end_of_buf, assoc, assoc_len); 
  ccm_format_payload_data(buf, &end_of_buf, plaintext, *plaintext_len); 
  memset(temp_iv, 0, 16); 
  aes_encrypt_cbc_mac(buf, end_of_buf, mac_buf, key, keysize, temp_iv); 
  if (! memcmp(mac, mac_buf, mac_len)) { 
   *mac_auth = 1; 
  } 
  else { 
   *mac_auth = 0; 
   memset(plaintext, 0, *plaintext_len); 
  } 
 } 
 free(buf); 
 return(1); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ciphertext"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""ciphertext_len"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""assoc"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""type"": ""unsigned short int"", ""value"": 0}, {""expr"": ""nonce"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""type"": ""unsigned short int"", ""value"": 0}, {""expr"": ""plaintext"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""plaintext_len[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""plaintext_len[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""mac_len"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""mac_auth[0]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""mac_auth[1]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""key_str"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void increment_iv(BYTE *iv,int counter_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void * malloc(size_t anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void aes_decrypt_ctr(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""int aes_encrypt_cbc_mac(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_format_payload_data(BYTE *buf,int *end_of_buf,const BYTE *payload,int payload_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*end_of_buf"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*payload"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_prepare_first_ctr_blk(BYTE *counter,const BYTE *nonce,int nonce_len,int payload_len_store_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*counter"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*nonce"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_format_assoc_data(BYTE *buf,int *end_of_buf,const BYTE *assoc,int assoc_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*end_of_buf"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*assoc"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void aes_key_setup(const BYTE *key,WORD *w,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*w"", ""type"": ""WORD"", ""value"": 0}]}, {""called function"": ""int memcmp(const void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""const void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void free(void *anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void ccm_prepare_first_format_blk(BYTE *buf,int assoc_len,int payload_len,int payload_len_store_size,int mac_len,const BYTE *nonce,int nonce_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*nonce"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
int aes_decrypt_ccm(const BYTE ciphertext[], WORD ciphertext_len, const BYTE assoc[], unsigned short assoc_len, 
                    const BYTE nonce[], unsigned short nonce_len, BYTE plaintext[], WORD *plaintext_len, 
                    WORD mac_len, int *mac_auth, const BYTE key_str[], int keysize) 
{ 
 BYTE temp_iv[16], counter[16], mac[16], mac_buf[16], *buf; 
 int end_of_buf, plaintext_len_store_size; 
 WORD key[60]; 
 if (ciphertext_len <= mac_len) 
  return(0); 
 buf = (BYTE*)malloc(assoc_len + ciphertext_len + 48); 
 if (! buf) 
  return(0); 
 aes_key_setup(key_str, key, keysize); 
 *plaintext_len = ciphertext_len - mac_len; 
 plaintext_len_store_size = 16 - 1 - nonce_len; 
 memcpy(plaintext, ciphertext, *plaintext_len); 
 memcpy(mac, &ciphertext[*plaintext_len], mac_len); 
 ccm_prepare_first_ctr_blk(counter, nonce, nonce_len, plaintext_len_store_size); 
 memcpy(temp_iv, counter, 16); 
 increment_iv(temp_iv, 16 - 1 - mac_len); 
 aes_decrypt_ctr(plaintext, *plaintext_len, plaintext, key, keysize, temp_iv); 
 if (mac_auth != ((void *) 0)) { 
  aes_decrypt_ctr(mac, mac_len, mac, key, keysize, counter); 
  plaintext_len_store_size = 16 - 1 - nonce_len; 
  ccm_prepare_first_format_blk(buf, assoc_len, *plaintext_len, plaintext_len_store_size, mac_len, nonce, nonce_len); 
  end_of_buf = 16; 
  ccm_format_assoc_data(buf, &end_of_buf, assoc, assoc_len); 
  ccm_format_payload_data(buf, &end_of_buf, plaintext, *plaintext_len); 
  memset(temp_iv, 0, 16); 
  aes_encrypt_cbc_mac(buf, end_of_buf, mac_buf, key, keysize, temp_iv); 
  if (! memcmp(mac, mac_buf, mac_len)) { 
   *mac_auth = 1; 
  } 
  else { 
   *mac_auth = 0; 
   memset(plaintext, 0, *plaintext_len); 
  } 
 } 
 free(buf); 
 return(1); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ciphertext"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""ciphertext_len"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""assoc"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""type"": ""unsigned short int"", ""value"": 0}, {""expr"": ""nonce"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""type"": ""unsigned short int"", ""value"": 0}, {""expr"": ""plaintext"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""plaintext_len[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""plaintext_len[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""mac_len"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""mac_auth[0]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""mac_auth[1]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""key_str"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void increment_iv(BYTE *iv,int counter_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void * malloc(size_t anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void aes_decrypt_ctr(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""int aes_encrypt_cbc_mac(const BYTE *in,size_t in_len,BYTE *out,const WORD *key,int keysize,const BYTE *iv)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const WORD"", ""value"": 0}, {""expr"": ""*iv"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_format_payload_data(BYTE *buf,int *end_of_buf,const BYTE *payload,int payload_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*end_of_buf"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*payload"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_prepare_first_ctr_blk(BYTE *counter,const BYTE *nonce,int nonce_len,int payload_len_store_size)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*counter"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*nonce"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void ccm_format_assoc_data(BYTE *buf,int *end_of_buf,const BYTE *assoc,int assoc_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*end_of_buf"", ""type"": ""int"", ""value"": 0}, {""expr"": ""*assoc"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void aes_key_setup(const BYTE *key,WORD *w,int keysize)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*w"", ""type"": ""WORD"", ""value"": 0}]}, {""called function"": ""int memcmp(const void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""const void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void free(void *anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}, {""called function"": ""void ccm_prepare_first_format_blk(BYTE *buf,int assoc_len,int payload_len,int payload_len_store_size,int mac_len,const BYTE *nonce,int nonce_len)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*buf"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""*nonce"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""int"", ""value"": 0}]}
{other test cases}
","{""func"": ""aes_decrypt_ccm"", ""file"": """", ""cases"": [{""desc"": ""ciphertext_len is less than or equal to mac_len, should return 0"", ""inputs"": [{""expr"": ""ciphertext"", ""value"": ""abcdef""}, {""expr"": ""ciphertext_len"", ""value"": 4}, {""expr"": ""assoc"", ""value"": ""assocdata""}, {""expr"": ""assoc_len"", ""value"": 8}, {""expr"": ""nonce"", ""value"": ""nonceval""}, {""expr"": ""nonce_len"", ""value"": 8}, {""expr"": ""plaintext"", ""value"": ""plaintext""}, {""expr"": ""plaintext_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""plaintext_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 6}, {""expr"": ""mac_auth_PTRTO[0]"", ""value"": 0}, {""expr"": ""mac_auth_PTRTO[1]"", ""value"": 0}, {""expr"": ""key_str"", ""value"": ""keyvalue""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""malloc fails, should return 0"", ""inputs"": [{""expr"": ""ciphertext"", ""value"": ""abcdef""}, {""expr"": ""ciphertext_len"", ""value"": 10}, {""expr"": ""assoc"", ""value"": ""assocdata""}, {""expr"": ""assoc_len"", ""value"": 8}, {""expr"": ""nonce"", ""value"": ""nonceval""}, {""expr"": ""nonce_len"", ""value"": 8}, {""expr"": ""plaintext"", ""value"": ""plaintext""}, {""expr"": ""plaintext_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""plaintext_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 6}, {""expr"": ""mac_auth_PTRTO[0]"", ""value"": 0}, {""expr"": ""mac_auth_PTRTO[1]"", ""value"": 0}, {""expr"": ""key_str"", ""value"": ""keyvalue""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""malloc""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""mac_auth is not null, mac comparison fails, should set mac_auth to 0 and clear plaintext"", ""inputs"": [{""expr"": ""ciphertext"", ""value"": ""abcdef123456""}, {""expr"": ""ciphertext_len"", ""value"": 12}, {""expr"": ""assoc"", ""value"": ""assocdata""}, {""expr"": ""assoc_len"", ""value"": 8}, {""expr"": ""nonce"", ""value"": ""nonceval""}, {""expr"": ""nonce_len"", ""value"": 8}, {""expr"": ""plaintext"", ""value"": ""plaintext""}, {""expr"": ""plaintext_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""plaintext_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 6}, {""expr"": ""mac_auth_PTRTO[0]"", ""value"": 0}, {""expr"": ""mac_auth_PTRTO[1]"", ""value"": 0}, {""expr"": ""key_str"", ""value"": ""keyvalue""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 1, ""funcName"": ""malloc""}, {""expr"": ""returnValue"", ""value"": 1, ""funcName"": ""memcmp""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}, {""expr"": ""mac_auth[0]"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""mac_auth is not null, mac comparison succeeds, should set mac_auth to 1"", ""inputs"": [{""expr"": ""ciphertext"", ""value"": ""abcdef123456""}, {""expr"": ""ciphertext_len"", ""value"": 12}, {""expr"": ""assoc"", ""value"": ""assocdata""}, {""expr"": ""assoc_len"", ""value"": 8}, {""expr"": ""nonce"", ""value"": ""nonceval""}, {""expr"": ""nonce_len"", ""value"": 8}, {""expr"": ""plaintext"", ""value"": ""plaintext""}, {""expr"": ""plaintext_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""plaintext_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 6}, {""expr"": ""mac_auth_PTRTO[0]"", ""value"": 0}, {""expr"": ""mac_auth_PTRTO[1]"", ""value"": 0}, {""expr"": ""key_str"", ""value"": ""keyvalue""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 1, ""funcName"": ""malloc""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcmp""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}, {""expr"": ""mac_auth[0]"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""mac_auth is null, should not check mac and return 1"", ""inputs"": [{""expr"": ""ciphertext"", ""value"": ""abcdef123456""}, {""expr"": ""ciphertext_len"", ""value"": 12}, {""expr"": ""assoc"", ""value"": ""assocdata""}, {""expr"": ""assoc_len"", ""value"": 8}, {""expr"": ""nonce"", ""value"": ""nonceval""}, {""expr"": ""nonce_len"", ""value"": 8}, {""expr"": ""plaintext"", ""value"": ""plaintext""}, {""expr"": ""plaintext_len_PTRTO[0]"", ""value"": 0}, {""expr"": ""plaintext_len_PTRTO[1]"", ""value"": 0}, {""expr"": ""mac_len"", ""value"": 6}, {""expr"": ""mac_auth"", ""value"": ""null""}, {""expr"": ""key_str"", ""value"": ""keyvalue""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 1, ""funcName"": ""malloc""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""plaintext_len"", ""userVar"": ""plaintext_len_PTRTO""}, {""expr"": ""mac_auth"", ""userVar"": ""mac_auth_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ccm_prepare_first_ctr_blk(BYTE counter[], const BYTE nonce[], int nonce_len, int payload_len_store_size) 
{ 
 memset(counter, 0, 16); 
 counter[0] = (payload_len_store_size - 1) & 0x07; 
 memcpy(&counter[1], nonce, nonce_len); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""counter"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""payload_len_store_size"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ccm_prepare_first_ctr_blk(BYTE counter[], const BYTE nonce[], int nonce_len, int payload_len_store_size) 
{ 
 memset(counter, 0, 16); 
 counter[0] = (payload_len_store_size - 1) & 0x07; 
 memcpy(&counter[1], nonce, nonce_len); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""counter"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""payload_len_store_size"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""ccm_prepare_first_ctr_blk"", ""file"": """", ""cases"": [{""desc"": ""Test with nonce_len = 0 and payload_len_store_size = 0"", ""inputs"": [{""expr"": ""counter"", ""value"": ""abc""}, {""expr"": ""nonce"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""value"": 0}, {""expr"": ""payload_len_store_size"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with nonce_len = 8 and payload_len_store_size = 1"", ""inputs"": [{""expr"": ""counter"", ""value"": ""abc""}, {""expr"": ""nonce"", ""value"": ""12345678""}, {""expr"": ""nonce_len"", ""value"": 8}, {""expr"": ""payload_len_store_size"", ""value"": 1}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""12345678\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with nonce_len = 16 and payload_len_store_size = 8"", ""inputs"": [{""expr"": ""counter"", ""value"": ""abc""}, {""expr"": ""nonce"", ""value"": ""1234567890abcdef""}, {""expr"": ""nonce_len"", ""value"": 16}, {""expr"": ""payload_len_store_size"", ""value"": 8}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""1234567890abcdef\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with nonce_len = 15 and payload_len_store_size = 3"", ""inputs"": [{""expr"": ""counter"", ""value"": ""abc""}, {""expr"": ""nonce"", ""value"": ""1234567890abcde""}, {""expr"": ""nonce_len"", ""value"": 15}, {""expr"": ""payload_len_store_size"", ""value"": 3}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""1234567890abcde\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with nonce_len = 0 and payload_len_store_size = 7"", ""inputs"": [{""expr"": ""counter"", ""value"": ""abc""}, {""expr"": ""nonce"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""value"": 0}, {""expr"": ""payload_len_store_size"", ""value"": 7}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with nonce_len = 16 and payload_len_store_size = 0"", ""inputs"": [{""expr"": ""counter"", ""value"": ""abc""}, {""expr"": ""nonce"", ""value"": ""1234567890abcdef""}, {""expr"": ""nonce_len"", ""value"": 16}, {""expr"": ""payload_len_store_size"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""1234567890abcdef\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ccm_prepare_first_format_blk(BYTE buf[], int assoc_len, int payload_len, int payload_len_store_size, int mac_len, const BYTE nonce[], int nonce_len) 
{ 
 buf[0] = ((((mac_len - 2) / 2) & 0x07) << 3) | ((payload_len_store_size - 1) & 0x07); 
 if (assoc_len > 0) 
  buf[0] += 0x40; 
 memcpy(&buf[1], nonce, nonce_len); 
 memset(&buf[1 + nonce_len], 0, 16 - 1 - nonce_len); 
 buf[15] = payload_len & 0x000000FF; 
 buf[14] = (payload_len >> 8) & 0x000000FF; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""buf"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""payload_len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""payload_len_store_size"", ""type"": ""int"", ""value"": 0}, {""expr"": ""mac_len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""nonce"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ccm_prepare_first_format_blk(BYTE buf[], int assoc_len, int payload_len, int payload_len_store_size, int mac_len, const BYTE nonce[], int nonce_len) 
{ 
 buf[0] = ((((mac_len - 2) / 2) & 0x07) << 3) | ((payload_len_store_size - 1) & 0x07); 
 if (assoc_len > 0) 
  buf[0] += 0x40; 
 memcpy(&buf[1], nonce, nonce_len); 
 memset(&buf[1 + nonce_len], 0, 16 - 1 - nonce_len); 
 buf[15] = payload_len & 0x000000FF; 
 buf[14] = (payload_len >> 8) & 0x000000FF; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""buf"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""payload_len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""payload_len_store_size"", ""type"": ""int"", ""value"": 0}, {""expr"": ""mac_len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""nonce"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""nonce_len"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""ccm_prepare_first_format_blk"", ""file"": """", ""cases"": [{""desc"": ""Test case with assoc_len > 0"", ""inputs"": [{""expr"": ""buf"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""assoc_len"", ""value"": 1}, {""expr"": ""payload_len"", ""value"": 256}, {""expr"": ""payload_len_store_size"", ""value"": 2}, {""expr"": ""mac_len"", ""value"": 4}, {""expr"": ""nonce"", ""value"": ""1234567890abcdef""}, {""expr"": ""nonce_len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""1234567890abcdef\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""1234567890abcdef\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""1234567890abcdef\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""buf[0]"", ""value"": ""0x5A""}, {""expr"": ""buf[1]"", ""value"": ""0x31""}, {""expr"": ""buf[2]"", ""value"": ""0x32""}, {""expr"": ""buf[3]"", ""value"": ""0x33""}, {""expr"": ""buf[4]"", ""value"": ""0x34""}, {""expr"": ""buf[5]"", ""value"": ""0x35""}, {""expr"": ""buf[6]"", ""value"": ""0x36""}, {""expr"": ""buf[7]"", ""value"": ""0x37""}, {""expr"": ""buf[8]"", ""value"": ""0x38""}, {""expr"": ""buf[9]"", ""value"": ""0x39""}, {""expr"": ""buf[10]"", ""value"": ""0x30""}, {""expr"": ""buf[11]"", ""value"": ""0x61""}, {""expr"": ""buf[12]"", ""value"": ""0x62""}, {""expr"": ""buf[13]"", ""value"": ""0x63""}, {""expr"": ""buf[14]"", ""value"": ""0x01""}, {""expr"": ""buf[15]"", ""value"": ""0x00""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with assoc_len = 0, payload_len_store_size = 1"", ""inputs"": [{""expr"": ""buf"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""assoc_len"", ""value"": 0}, {""expr"": ""payload_len"", ""value"": 512}, {""expr"": ""payload_len_store_size"", ""value"": 1}, {""expr"": ""mac_len"", ""value"": 8}, {""expr"": ""nonce"", ""value"": ""abcdef1234567890""}, {""expr"": ""nonce_len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abcdef1234567890\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdef1234567890\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""abcdef1234567890\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""buf[0]"", ""value"": ""0xE0""}, {""expr"": ""buf[1]"", ""value"": ""0x61""}, {""expr"": ""buf[2]"", ""value"": ""0x62""}, {""expr"": ""buf[3]"", ""value"": ""0x63""}, {""expr"": ""buf[4]"", ""value"": ""0x64""}, {""expr"": ""buf[5]"", ""value"": ""0x65""}, {""expr"": ""buf[6]"", ""value"": ""0x66""}, {""expr"": ""buf[7]"", ""value"": ""0x31""}, {""expr"": ""buf[8]"", ""value"": ""0x32""}, {""expr"": ""buf[9]"", ""value"": ""0x33""}, {""expr"": ""buf[10]"", ""value"": ""0x34""}, {""expr"": ""buf[11]"", ""value"": ""0x35""}, {""expr"": ""buf[12]"", ""value"": ""0x36""}, {""expr"": ""buf[13]"", ""value"": ""0x37""}, {""expr"": ""buf[14]"", ""value"": ""0x02""}, {""expr"": ""buf[15]"", ""value"": ""0x00""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with payload_len_store_size = 3, mac_len = 10"", ""inputs"": [{""expr"": ""buf"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""assoc_len"", ""value"": 0}, {""expr"": ""payload_len"", ""value"": 1024}, {""expr"": ""payload_len_store_size"", ""value"": 3}, {""expr"": ""mac_len"", ""value"": 10}, {""expr"": ""nonce"", ""value"": ""fedcba0987654321""}, {""expr"": ""nonce_len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""fedcba0987654321\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""fedcba0987654321\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""fedcba0987654321\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""buf[0]"", ""value"": ""0xB2""}, {""expr"": ""buf[1]"", ""value"": ""0x66""}, {""expr"": ""buf[2]"", ""value"": ""0x65""}, {""expr"": ""buf[3]"", ""value"": ""0x64""}, {""expr"": ""buf[4]"", ""value"": ""0x63""}, {""expr"": ""buf[5]"", ""value"": ""0x62""}, {""expr"": ""buf[6]"", ""value"": ""0x61""}, {""expr"": ""buf[7]"", ""value"": ""0x30""}, {""expr"": ""buf[8]"", ""value"": ""0x39""}, {""expr"": ""buf[9]"", ""value"": ""0x38""}, {""expr"": ""buf[10]"", ""value"": ""0x37""}, {""expr"": ""buf[11]"", ""value"": ""0x36""}, {""expr"": ""buf[12]"", ""value"": ""0x35""}, {""expr"": ""buf[13]"", ""value"": ""0x34""}, {""expr"": ""buf[14]"", ""value"": ""0x04""}, {""expr"": ""buf[15]"", ""value"": ""0x00""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with assoc_len = 0, payload_len = 0"", ""inputs"": [{""expr"": ""buf"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""assoc_len"", ""value"": 0}, {""expr"": ""payload_len"", ""value"": 0}, {""expr"": ""payload_len_store_size"", ""value"": 1}, {""expr"": ""mac_len"", ""value"": 4}, {""expr"": ""nonce"", ""value"": ""1111111111111111""}, {""expr"": ""nonce_len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""1111111111111111\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""1111111111111111\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""1111111111111111\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""buf[0]"", ""value"": ""0x0A""}, {""expr"": ""buf[1]"", ""value"": ""0x31""}, {""expr"": ""buf[2]"", ""value"": ""0x31""}, {""expr"": ""buf[3]"", ""value"": ""0x31""}, {""expr"": ""buf[4]"", ""value"": ""0x31""}, {""expr"": ""buf[5]"", ""value"": ""0x31""}, {""expr"": ""buf[6]"", ""value"": ""0x31""}, {""expr"": ""buf[7]"", ""value"": ""0x31""}, {""expr"": ""buf[8]"", ""value"": ""0x31""}, {""expr"": ""buf[9]"", ""value"": ""0x31""}, {""expr"": ""buf[10]"", ""value"": ""0x31""}, {""expr"": ""buf[11]"", ""value"": ""0x31""}, {""expr"": ""buf[12]"", ""value"": ""0x31""}, {""expr"": ""buf[13]"", ""value"": ""0x31""}, {""expr"": ""buf[14]"", ""value"": ""0x00""}, {""expr"": ""buf[15]"", ""value"": ""0x00""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with max payload_len"", ""inputs"": [{""expr"": ""buf"", ""value"": ""00000000000000000000000000000000""}, {""expr"": ""assoc_len"", ""value"": 0}, {""expr"": ""payload_len"", ""value"": 65535}, {""expr"": ""payload_len_store_size"", ""value"": 2}, {""expr"": ""mac_len"", ""value"": 16}, {""expr"": ""nonce"", ""value"": ""2222222222222222""}, {""expr"": ""nonce_len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""2222222222222222\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""2222222222222222\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""2222222222222222\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""0000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""buf[0]"", ""value"": ""0xFA""}, {""expr"": ""buf[1]"", ""value"": ""0x32""}, {""expr"": ""buf[2]"", ""value"": ""0x32""}, {""expr"": ""buf[3]"", ""value"": ""0x32""}, {""expr"": ""buf[4]"", ""value"": ""0x32""}, {""expr"": ""buf[5]"", ""value"": ""0x32""}, {""expr"": ""buf[6]"", ""value"": ""0x32""}, {""expr"": ""buf[7]"", ""value"": ""0x32""}, {""expr"": ""buf[8]"", ""value"": ""0x32""}, {""expr"": ""buf[9]"", ""value"": ""0x32""}, {""expr"": ""buf[10]"", ""value"": ""0x32""}, {""expr"": ""buf[11]"", ""value"": ""0x32""}, {""expr"": ""buf[12]"", ""value"": ""0x32""}, {""expr"": ""buf[13]"", ""value"": ""0x32""}, {""expr"": ""buf[14]"", ""value"": ""0xFF""}, {""expr"": ""buf[15]"", ""value"": ""0xFF""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ccm_format_assoc_data(BYTE buf[], int *end_of_buf, const BYTE assoc[], int assoc_len) 
{ 
 int pad; 
 buf[*end_of_buf + 1] = assoc_len & 0x00FF; 
 buf[*end_of_buf] = (assoc_len >> 8) & 0x00FF; 
 *end_of_buf += 2; 
 memcpy(&buf[*end_of_buf], assoc, assoc_len); 
 *end_of_buf += assoc_len; 
 pad = 16 - (*end_of_buf % 16); 
 memset(&buf[*end_of_buf], 0, pad); 
 *end_of_buf += pad; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""buf"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""end_of_buf[0]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""end_of_buf[1]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""assoc"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ccm_format_assoc_data(BYTE buf[], int *end_of_buf, const BYTE assoc[], int assoc_len) 
{ 
 int pad; 
 buf[*end_of_buf + 1] = assoc_len & 0x00FF; 
 buf[*end_of_buf] = (assoc_len >> 8) & 0x00FF; 
 *end_of_buf += 2; 
 memcpy(&buf[*end_of_buf], assoc, assoc_len); 
 *end_of_buf += assoc_len; 
 pad = 16 - (*end_of_buf % 16); 
 memset(&buf[*end_of_buf], 0, pad); 
 *end_of_buf += pad; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""buf"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""end_of_buf[0]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""end_of_buf[1]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""assoc"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""ccm_format_assoc_data"", ""file"": """", ""cases"": [{""desc"": ""Test with assoc_len equal to 0"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abc""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""assoc"", ""value"": ""abc""}, {""expr"": ""assoc_len"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with assoc_len equal to 16"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""assoc"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""assoc_len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnop00000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnop00000000\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with assoc_len equal to 17"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abcdefghijklmnopq""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""assoc"", ""value"": ""abcdefghijklmnopq""}, {""expr"": ""assoc_len"", ""value"": 17}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnopq\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnopq\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""abcdefghijklmnopq\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnopq000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnopq000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with assoc_len equal to 32"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdef""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""assoc"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdef""}, {""expr"": ""assoc_len"", ""value"": 32}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnopqrstuvwxyzabcdef\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnopqrstuvwxyzabcdef\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""abcdefghijklmnopqrstuvwxyzabcdef\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnopqrstuvwxyzabcdef0000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnopqrstuvwxyzabcdef0000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with assoc_len equal to 1"", ""inputs"": [{""expr"": ""buf"", ""value"": ""a""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""assoc"", ""value"": ""a""}, {""expr"": ""assoc_len"", ""value"": 1}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""a\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""a\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""a\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""a000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""a000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with assoc_len equal to 15"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abcdefghijklmno""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""assoc"", ""value"": ""abcdefghijklmno""}, {""expr"": ""assoc_len"", ""value"": 15}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmno\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmno\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""abcdefghijklmno\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmno000000000000000\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmno000000000000000\"""", ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""end_of_buf"", ""userVar"": ""end_of_buf_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ccm_format_payload_data(BYTE buf[], int *end_of_buf, const BYTE payload[], int payload_len) 
{ 
 int pad; 
 memcpy(&buf[*end_of_buf], payload, payload_len); 
 *end_of_buf += payload_len; 
 pad = *end_of_buf % 16; 
 if (pad != 0) 
  pad = 16 - pad; 
 memset(&buf[*end_of_buf], 0, pad); 
 *end_of_buf += pad; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""buf"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""end_of_buf[0]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""end_of_buf[1]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""payload"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ccm_format_payload_data(BYTE buf[], int *end_of_buf, const BYTE payload[], int payload_len) 
{ 
 int pad; 
 memcpy(&buf[*end_of_buf], payload, payload_len); 
 *end_of_buf += payload_len; 
 pad = *end_of_buf % 16; 
 if (pad != 0) 
  pad = 16 - pad; 
 memset(&buf[*end_of_buf], 0, pad); 
 *end_of_buf += pad; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""buf"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""end_of_buf[0]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""end_of_buf[1]"", ""type"": ""int"", ""value"": 0}, {""expr"": ""payload"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""ccm_format_payload_data"", ""file"": """", ""cases"": [{""desc"": ""Test case where payload is empty and end_of_buf is initially 0"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abc""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""payload_len"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""end_of_buf[0]"", ""value"": 16}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where payload length is less than 16 and end_of_buf is initially 0"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""payload"", ""value"": ""abc""}, {""expr"": ""payload_len"", ""value"": 3}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""abc\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""end_of_buf[0]"", ""value"": 16}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where payload length is exactly 16 and end_of_buf is initially 0"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""payload"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""payload_len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnopqrstuvwxy\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""abcdefghijklmnop\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""end_of_buf[0]"", ""value"": 16}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where payload length is greater than 16 and end_of_buf is initially 0"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 0}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""payload"", ""value"": ""abcdefghijklmnopqrstuvwxy""}, {""expr"": ""payload_len"", ""value"": 25}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnopqrstuvwxy\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnopqrstuvwxyz\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""abcdefghijklmnopqrstuvwxy\"""", ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnopqrstuvwxyz\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnopqrstuvwxyz\"""", ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""end_of_buf[0]"", ""value"": 32}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where payload length is 0 and end_of_buf is initially not 0"", ""inputs"": [{""expr"": ""buf"", ""value"": ""abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy""}, {""expr"": ""end_of_buf_PTRTO[0]"", ""value"": 10}, {""expr"": ""end_of_buf_PTRTO[1]"", ""value"": 0}, {""expr"": ""payload_len"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": ""\""abcdefghijklmnopqrstuvwxy\"""", ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": ""\""abcdefghijklmnopqrstuvwxy\"""", ""funcName"": ""memset""}], ""outputs"": [{""expr"": ""end_of_buf[0]"", ""value"": 16}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""end_of_buf"", ""userVar"": ""end_of_buf_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
static const BYTE aes_sbox[16][16] 
WORD SubWord(WORD word) 
{ 
 unsigned int result; 
 result = (int)aes_sbox[(word >> 4) & 0x0000000F][word & 0x0000000F]; 
 result += (int)aes_sbox[(word >> 12) & 0x0000000F][(word >> 8) & 0x0000000F] << 8; 
 result += (int)aes_sbox[(word >> 20) & 0x0000000F][(word >> 16) & 0x0000000F] << 16; 
 result += (int)aes_sbox[(word >> 28) & 0x0000000F][(word >> 24) & 0x0000000F] << 24; 
 return(result); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""word"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": ""[0]""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""WORD"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
static const BYTE aes_sbox[16][16] 
WORD SubWord(WORD word) 
{ 
 unsigned int result; 
 result = (int)aes_sbox[(word >> 4) & 0x0000000F][word & 0x0000000F]; 
 result += (int)aes_sbox[(word >> 12) & 0x0000000F][(word >> 8) & 0x0000000F] << 8; 
 result += (int)aes_sbox[(word >> 20) & 0x0000000F][(word >> 16) & 0x0000000F] << 16; 
 result += (int)aes_sbox[(word >> 28) & 0x0000000F][(word >> 24) & 0x0000000F] << 24; 
 return(result); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""word"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": ""[0]""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""WORD"", ""value"": 0}]}
{other test cases}
","{""func"": ""SubWord"", ""file"": """", ""cases"": [{""desc"": ""Test case with word having all zero bits"", ""inputs"": [{""expr"": ""word"", ""value"": 0}, {""expr"": ""aes_sbox"", ""value"": ""[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12], [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13], [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with word having all one bits"", ""inputs"": [{""expr"": ""word"", ""value"": 4294967295}, {""expr"": ""aes_sbox"", ""value"": ""[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12], [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13], [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 252645135}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
void aes_key_setup(const BYTE key[], WORD w[], int keysize) 
{ 
 int Nb=4,Nr,Nk,idx; 
 WORD temp,Rcon[]={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000, 
                   0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000, 
                   0xab000000,0x4d000000,0x9a000000}; 
 switch (keysize) { 
  case 128: Nr = 10; Nk = 4; break; 
  case 192: Nr = 12; Nk = 6; break; 
  case 256: Nr = 14; Nk = 8; break; 
  default: return; 
 } 
 for (idx=0; idx < Nk; ++idx) { 
  w[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) | 
       ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3])); 
 } 
 for (idx = Nk; idx < Nb * (Nr+1); ++idx) { 
  temp = w[idx - 1]; 
  if ((idx % Nk) == 0) 
   temp = SubWord((((temp) << 8) | ((temp) >> 24))) ^ Rcon[(idx-1)/Nk]; 
  else if (Nk > 6 && (idx % Nk) == 4) 
   temp = SubWord(temp); 
  w[idx] = w[idx-Nk] ^ temp; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""WORD SubWord(WORD word)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
void aes_key_setup(const BYTE key[], WORD w[], int keysize) 
{ 
 int Nb=4,Nr,Nk,idx; 
 WORD temp,Rcon[]={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000, 
                   0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000, 
                   0xab000000,0x4d000000,0x9a000000}; 
 switch (keysize) { 
  case 128: Nr = 10; Nk = 4; break; 
  case 192: Nr = 12; Nk = 6; break; 
  case 256: Nr = 14; Nk = 8; break; 
  default: return; 
 } 
 for (idx=0; idx < Nk; ++idx) { 
  w[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) | 
       ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3])); 
 } 
 for (idx = Nk; idx < Nb * (Nr+1); ++idx) { 
  temp = w[idx - 1]; 
  if ((idx % Nk) == 0) 
   temp = SubWord((((temp) << 8) | ((temp) >> 24))) ^ Rcon[(idx-1)/Nk]; 
  else if (Nk > 6 && (idx % Nk) == 4) 
   temp = SubWord(temp); 
  w[idx] = w[idx-Nk] ^ temp; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""WORD SubWord(WORD word)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""aes_key_setup"", ""file"": """", ""cases"": [{""desc"": ""Test case with keysize 128"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 0}, {""expr"": ""w_PTRTO[1]"", ""value"": 0}, {""expr"": ""w_PTRTO[2]"", ""value"": 0}, {""expr"": ""w_PTRTO[3]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""key[0]"", ""value"": ""0x2b""}, {""expr"": ""key[1]"", ""value"": ""0x7e""}, {""expr"": ""key[2]"", ""value"": ""0x15""}, {""expr"": ""key[3]"", ""value"": ""0x16""}, {""expr"": ""key[4]"", ""value"": ""0x28""}, {""expr"": ""key[5]"", ""value"": ""0xae""}, {""expr"": ""key[6]"", ""value"": ""0xd2""}, {""expr"": ""key[7]"", ""value"": ""0xa6""}, {""expr"": ""key[8]"", ""value"": ""0xab""}, {""expr"": ""key[9]"", ""value"": ""0xf7""}, {""expr"": ""key[10]"", ""value"": ""0xcf""}, {""expr"": ""key[11]"", ""value"": ""0x9f""}, {""expr"": ""key[12]"", ""value"": ""0x93""}, {""expr"": ""key[13]"", ""value"": ""0x69""}, {""expr"": ""key[14]"", ""value"": ""0x7b""}, {""expr"": ""key[15]"", ""value"": ""0x3e""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""0x00102030"", ""funcName"": ""SubWord""}], ""outputs"": [{""expr"": ""w[0]"", ""value"": ""0x2b7e1516""}, {""expr"": ""w[1]"", ""value"": ""0x28aed2a6""}, {""expr"": ""w[2]"", ""value"": ""0xabf7cf9f""}, {""expr"": ""w[3]"", ""value"": ""0x93697b3e""}, {""expr"": ""w[4]"", ""value"": ""0xa0fafe17""}, {""expr"": ""w[5]"", ""value"": ""0x88542cb1""}, {""expr"": ""w[6]"", ""value"": ""0x23a33939""}, {""expr"": ""w[7]"", ""value"": ""0x2a6c7605""}, {""expr"": ""w[8]"", ""value"": ""0xf2c295f2""}, {""expr"": ""w[9]"", ""value"": ""0x7a96b943""}, {""expr"": ""w[10]"", ""value"": ""0x5935807a""}, {""expr"": ""w[11]"", ""value"": ""0x7359f67f""}, {""expr"": ""w[12]"", ""value"": ""0x3d80477d""}, {""expr"": ""w[13]"", ""value"": ""0x4716fe3e""}, {""expr"": ""w[14]"", ""value"": ""0x1e237e44""}, {""expr"": ""w[15]"", ""value"": ""0x6d7a883b""}, {""expr"": ""w[16]"", ""value"": ""0xef44a541""}, {""expr"": ""w[17]"", ""value"": ""0xa8525b7f""}, {""expr"": ""w[18]"", ""value"": ""0xb671253b""}, {""expr"": ""w[19]"", ""value"": ""0xdb0bad00""}, {""expr"": ""w[20]"", ""value"": ""0xd4d1c6f8""}, {""expr"": ""w[21]"", ""value"": ""0x7c839d87""}, {""expr"": ""w[22]"", ""value"": ""0xcaf2b8bc""}, {""expr"": ""w[23]"", ""value"": ""0x11f915bc""}, {""expr"": ""w[24]"", ""value"": ""0x6d88a37a""}, {""expr"": ""w[25]"", ""value"": ""0x110b3efd""}, {""expr"": ""w[26]"", ""value"": ""0xdbf98641""}, {""expr"": ""w[27]"", ""value"": ""0xca0093fd""}, {""expr"": ""w[28]"", ""value"": ""0x4e54f70e""}, {""expr"": ""w[29]"", ""value"": ""0x5f5fc9f3""}, {""expr"": ""w[30]"", ""value"": ""0x84a64fb2""}, {""expr"": ""w[31]"", ""value"": ""0x4ea6dc4f""}, {""expr"": ""w[32]"", ""value"": ""0xead27321""}, {""expr"": ""w[33]"", ""value"": ""0xb58dbad2""}, {""expr"": ""w[34]"", ""value"": ""0x312bf560""}, {""expr"": ""w[35]"", ""value"": ""0x7f8d292f""}, {""expr"": ""w[36]"", ""value"": ""0xac7766f3""}, {""expr"": ""w[37]"", ""value"": ""0x19fadc21""}, {""expr"": ""w[38]"", ""value"": ""0x28d12941""}, {""expr"": ""w[39]"", ""value"": ""0x575c006e""}, {""expr"": ""w[40]"", ""value"": ""0xd014f9a8""}, {""expr"": ""w[41]"", ""value"": ""0xc9ee2589""}, {""expr"": ""w[42]"", ""value"": ""0xe13f0cc8""}, {""expr"": ""w[43]"", ""value"": ""0xb6630ca6""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with keysize 192"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 0}, {""expr"": ""w_PTRTO[1]"", ""value"": 0}, {""expr"": ""w_PTRTO[2]"", ""value"": 0}, {""expr"": ""w_PTRTO[3]"", ""value"": 0}, {""expr"": ""w_PTRTO[4]"", ""value"": 0}, {""expr"": ""w_PTRTO[5]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 192}, {""expr"": ""key[0]"", ""value"": ""0x8e""}, {""expr"": ""key[1]"", ""value"": ""0x73""}, {""expr"": ""key[2]"", ""value"": ""0xb0""}, {""expr"": ""key[3]"", ""value"": ""0xf7""}, {""expr"": ""key[4]"", ""value"": ""0xda""}, {""expr"": ""key[5]"", ""value"": ""0x0e""}, {""expr"": ""key[6]"", ""value"": ""0x64""}, {""expr"": ""key[7]"", ""value"": ""0x52""}, {""expr"": ""key[8]"", ""value"": ""0xc8""}, {""expr"": ""key[9]"", ""value"": ""0x10""}, {""expr"": ""key[10]"", ""value"": ""0xf3""}, {""expr"": ""key[11]"", ""value"": ""0x2b""}, {""expr"": ""key[12]"", ""value"": ""0x80""}, {""expr"": ""key[13]"", ""value"": ""0x90""}, {""expr"": ""key[14]"", ""value"": ""0x79""}, {""expr"": ""key[15]"", ""value"": ""0xe5""}, {""expr"": ""key[16]"", ""value"": ""0x62""}, {""expr"": ""key[17]"", ""value"": ""0xf8""}, {""expr"": ""key[18]"", ""value"": ""0xea""}, {""expr"": ""key[19]"", ""value"": ""0xd2""}, {""expr"": ""key[20]"", ""value"": ""0x52""}, {""expr"": ""key[21]"", ""value"": ""0x2c""}, {""expr"": ""key[22]"", ""value"": ""0x6b""}, {""expr"": ""key[23]"", ""value"": ""0x7b""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""0x00102030"", ""funcName"": ""SubWord""}], ""outputs"": [{""expr"": ""w[0]"", ""value"": ""0x8e73b0f7""}, {""expr"": ""w[1]"", ""value"": ""0xda0e6452""}, {""expr"": ""w[2]"", ""value"": ""0xc810f32b""}, {""expr"": ""w[3]"", ""value"": ""0x809079e5""}, {""expr"": ""w[4]"", ""value"": ""0x62f8ead2""}, {""expr"": ""w[5]"", ""value"": ""0x522c6b7b""}, {""expr"": ""w[6]"", ""value"": ""0xfe0c91f7""}, {""expr"": ""w[7]"", ""value"": ""0x2402f5a5""}, {""expr"": ""w[8]"", ""value"": ""0xec12068e""}, {""expr"": ""w[9]"", ""value"": ""0x6c827f6b""}, {""expr"": ""w[10]"", ""value"": ""0x0e7a95b9""}, {""expr"": ""w[11]"", ""value"": ""0x5c56fec2""}, {""expr"": ""w[12]"", ""value"": ""0x4db7b4bd""}, {""expr"": ""w[13]"", ""value"": ""0x69b54118""}, {""expr"": ""w[14]"", ""value"": ""0x85a74796""}, {""expr"": ""w[15]"", ""value"": ""0xe92538fd""}, {""expr"": ""w[16]"", ""value"": ""0xe75fad44""}, {""expr"": ""w[17]"", ""value"": ""0xbb095386""}, {""expr"": ""w[18]"", ""value"": ""0x485af057""}, {""expr"": ""w[19]"", ""value"": ""0x21efb14f""}, {""expr"": ""w[20]"", ""value"": ""0xa448f6d9""}, {""expr"": ""w[21]"", ""value"": ""0x4d6dce24""}, {""expr"": ""w[22]"", ""value"": ""0xaa326360""}, {""expr"": ""w[23]"", ""value"": ""0x113b30e6""}, {""expr"": ""w[24]"", ""value"": ""0xa25e7ed5""}, {""expr"": ""w[25]"", ""value"": ""0x83b1cf9a""}, {""expr"": ""w[26]"", ""value"": ""0x27f93943""}, {""expr"": ""w[27]"", ""value"": ""0x6a94f767""}, {""expr"": ""w[28]"", ""value"": ""0xc0a69407""}, {""expr"": ""w[29]"", ""value"": ""0xd19da4e1""}, {""expr"": ""w[30]"", ""value"": ""0xec1786eb""}, {""expr"": ""w[31]"", ""value"": ""0x6fa64971""}, {""expr"": ""w[32]"", ""value"": ""0x485f7032""}, {""expr"": ""w[33]"", ""value"": ""0x22cb8755""}, {""expr"": ""w[34]"", ""value"": ""0xe26d1352""}, {""expr"": ""w[35]"", ""value"": ""0x33b5e7c3""}, {""expr"": ""w[36]"", ""value"": ""0x8ec9e771""}, {""expr"": ""w[37]"", ""value"": ""0x9ba9f7f2""}, {""expr"": ""w[38]"", ""value"": ""0x5b6d5c3b""}, {""expr"": ""w[39]"", ""value"": ""0x3b2e6c1f""}, {""expr"": ""w[40]"", ""value"": ""0x2c5c1f89""}, {""expr"": ""w[41]"", ""value"": ""0x5b7a9cfc""}, {""expr"": ""w[42]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[43]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[44]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[45]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[46]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[47]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[48]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[49]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[50]"", ""value"": ""0x5a7a9cfc""}, {""expr"": ""w[51]"", ""value"": ""0x5a7a9cfc""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""w"", ""userVar"": ""w_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void AddRoundKey(BYTE state[][4], const WORD w[]) 
{ 
 BYTE subkey[4]; 
 subkey[0] = w[0] >> 24; 
 subkey[1] = w[0] >> 16; 
 subkey[2] = w[0] >> 8; 
 subkey[3] = w[0]; 
 state[0][0] ^= subkey[0]; 
 state[1][0] ^= subkey[1]; 
 state[2][0] ^= subkey[2]; 
 state[3][0] ^= subkey[3]; 
 subkey[0] = w[1] >> 24; 
 subkey[1] = w[1] >> 16; 
 subkey[2] = w[1] >> 8; 
 subkey[3] = w[1]; 
 state[0][1] ^= subkey[0]; 
 state[1][1] ^= subkey[1]; 
 state[2][1] ^= subkey[2]; 
 state[3][1] ^= subkey[3]; 
 subkey[0] = w[2] >> 24; 
 subkey[1] = w[2] >> 16; 
 subkey[2] = w[2] >> 8; 
 subkey[3] = w[2]; 
 state[0][2] ^= subkey[0]; 
 state[1][2] ^= subkey[1]; 
 state[2][2] ^= subkey[2]; 
 state[3][2] ^= subkey[3]; 
 subkey[0] = w[3] >> 24; 
 subkey[1] = w[3] >> 16; 
 subkey[2] = w[3] >> 8; 
 subkey[3] = w[3]; 
 state[0][3] ^= subkey[0]; 
 state[1][3] ^= subkey[1]; 
 state[2][3] ^= subkey[2]; 
 state[3][3] ^= subkey[3]; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void AddRoundKey(BYTE state[][4], const WORD w[]) 
{ 
 BYTE subkey[4]; 
 subkey[0] = w[0] >> 24; 
 subkey[1] = w[0] >> 16; 
 subkey[2] = w[0] >> 8; 
 subkey[3] = w[0]; 
 state[0][0] ^= subkey[0]; 
 state[1][0] ^= subkey[1]; 
 state[2][0] ^= subkey[2]; 
 state[3][0] ^= subkey[3]; 
 subkey[0] = w[1] >> 24; 
 subkey[1] = w[1] >> 16; 
 subkey[2] = w[1] >> 8; 
 subkey[3] = w[1]; 
 state[0][1] ^= subkey[0]; 
 state[1][1] ^= subkey[1]; 
 state[2][1] ^= subkey[2]; 
 state[3][1] ^= subkey[3]; 
 subkey[0] = w[2] >> 24; 
 subkey[1] = w[2] >> 16; 
 subkey[2] = w[2] >> 8; 
 subkey[3] = w[2]; 
 state[0][2] ^= subkey[0]; 
 state[1][2] ^= subkey[1]; 
 state[2][2] ^= subkey[2]; 
 state[3][2] ^= subkey[3]; 
 subkey[0] = w[3] >> 24; 
 subkey[1] = w[3] >> 16; 
 subkey[2] = w[3] >> 8; 
 subkey[3] = w[3]; 
 state[0][3] ^= subkey[0]; 
 state[1][3] ^= subkey[1]; 
 state[2][3] ^= subkey[2]; 
 state[3][3] ^= subkey[3]; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""AddRoundKey"", ""file"": """", ""cases"": [{""desc"": ""All w values are zero, state remains unchanged"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 0}, {""expr"": ""w_PTRTO[1]"", ""value"": 0}, {""expr"": ""w_PTRTO[2]"", ""value"": 0}, {""expr"": ""w_PTRTO[3]"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""All w values are maximum, state XORs with maximum subkeys"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 4294967295}, {""expr"": ""w_PTRTO[1]"", ""value"": 4294967295}, {""expr"": ""w_PTRTO[2]"", ""value"": 4294967295}, {""expr"": ""w_PTRTO[3]"", ""value"": 4294967295}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""w values have alternating bits (0xAAAAAAAA and 0x55555555)"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 2863311530}, {""expr"": ""w_PTRTO[1]"", ""value"": 1431655765}, {""expr"": ""w_PTRTO[2]"", ""value"": 2863311530}, {""expr"": ""w_PTRTO[3]"", ""value"": 1431655765}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""w values are sequential integers"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 1}, {""expr"": ""w_PTRTO[1]"", ""value"": 2}, {""expr"": ""w_PTRTO[2]"", ""value"": 3}, {""expr"": ""w_PTRTO[3]"", ""value"": 4}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""w values are random integers"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 305419896}, {""expr"": ""w_PTRTO[1]"", ""value"": 591751049}, {""expr"": ""w_PTRTO[2]"", ""value"": 878082202}, {""expr"": ""w_PTRTO[3]"", ""value"": 1164413185}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""state is all zeros, w values are non-zero"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 305419896}, {""expr"": ""w_PTRTO[1]"", ""value"": 591751049}, {""expr"": ""w_PTRTO[2]"", ""value"": 878082202}, {""expr"": ""w_PTRTO[3]"", ""value"": 1164413185}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""state is all maximum (0xFF), w values are non-zero"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 305419896}, {""expr"": ""w_PTRTO[1]"", ""value"": 591751049}, {""expr"": ""w_PTRTO[2]"", ""value"": 878082202}, {""expr"": ""w_PTRTO[3]"", ""value"": 1164413185}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""w"", ""userVar"": ""w_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE aes_sbox[16][16] 
void SubBytes(BYTE state[][4]) 
{ 
 state[0][0] = aes_sbox[state[0][0] >> 4][state[0][0] & 0x0F]; 
 state[0][1] = aes_sbox[state[0][1] >> 4][state[0][1] & 0x0F]; 
 state[0][2] = aes_sbox[state[0][2] >> 4][state[0][2] & 0x0F]; 
 state[0][3] = aes_sbox[state[0][3] >> 4][state[0][3] & 0x0F]; 
 state[1][0] = aes_sbox[state[1][0] >> 4][state[1][0] & 0x0F]; 
 state[1][1] = aes_sbox[state[1][1] >> 4][state[1][1] & 0x0F]; 
 state[1][2] = aes_sbox[state[1][2] >> 4][state[1][2] & 0x0F]; 
 state[1][3] = aes_sbox[state[1][3] >> 4][state[1][3] & 0x0F]; 
 state[2][0] = aes_sbox[state[2][0] >> 4][state[2][0] & 0x0F]; 
 state[2][1] = aes_sbox[state[2][1] >> 4][state[2][1] & 0x0F]; 
 state[2][2] = aes_sbox[state[2][2] >> 4][state[2][2] & 0x0F]; 
 state[2][3] = aes_sbox[state[2][3] >> 4][state[2][3] & 0x0F]; 
 state[3][0] = aes_sbox[state[3][0] >> 4][state[3][0] & 0x0F]; 
 state[3][1] = aes_sbox[state[3][1] >> 4][state[3][1] & 0x0F]; 
 state[3][2] = aes_sbox[state[3][2] >> 4][state[3][2] & 0x0F]; 
 state[3][3] = aes_sbox[state[3][3] >> 4][state[3][3] & 0x0F]; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": ""[0]""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE aes_sbox[16][16] 
void SubBytes(BYTE state[][4]) 
{ 
 state[0][0] = aes_sbox[state[0][0] >> 4][state[0][0] & 0x0F]; 
 state[0][1] = aes_sbox[state[0][1] >> 4][state[0][1] & 0x0F]; 
 state[0][2] = aes_sbox[state[0][2] >> 4][state[0][2] & 0x0F]; 
 state[0][3] = aes_sbox[state[0][3] >> 4][state[0][3] & 0x0F]; 
 state[1][0] = aes_sbox[state[1][0] >> 4][state[1][0] & 0x0F]; 
 state[1][1] = aes_sbox[state[1][1] >> 4][state[1][1] & 0x0F]; 
 state[1][2] = aes_sbox[state[1][2] >> 4][state[1][2] & 0x0F]; 
 state[1][3] = aes_sbox[state[1][3] >> 4][state[1][3] & 0x0F]; 
 state[2][0] = aes_sbox[state[2][0] >> 4][state[2][0] & 0x0F]; 
 state[2][1] = aes_sbox[state[2][1] >> 4][state[2][1] & 0x0F]; 
 state[2][2] = aes_sbox[state[2][2] >> 4][state[2][2] & 0x0F]; 
 state[2][3] = aes_sbox[state[2][3] >> 4][state[2][3] & 0x0F]; 
 state[3][0] = aes_sbox[state[3][0] >> 4][state[3][0] & 0x0F]; 
 state[3][1] = aes_sbox[state[3][1] >> 4][state[3][1] & 0x0F]; 
 state[3][2] = aes_sbox[state[3][2] >> 4][state[3][2] & 0x0F]; 
 state[3][3] = aes_sbox[state[3][3] >> 4][state[3][3] & 0x0F]; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": ""[0]""}], ""outputs"": []}
{other test cases}
","{""func"": ""SubBytes"", ""file"": """", ""cases"": [{""desc"": ""All elements in the state array are zeros"", ""inputs"": [{""expr"": ""aes_sbox"", ""value"": ""[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12], [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13], [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]]""}, {""expr"": ""state"", ""value"": ""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""All elements in the state array are ones"", ""inputs"": [{""expr"": ""aes_sbox"", ""value"": ""[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11], [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12], [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13], [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14], [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]]""}, {""expr"": ""state"", ""value"": ""[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE aes_invsbox[16][16] 
void InvSubBytes(BYTE state[][4]) 
{ 
 state[0][0] = aes_invsbox[state[0][0] >> 4][state[0][0] & 0x0F]; 
 state[0][1] = aes_invsbox[state[0][1] >> 4][state[0][1] & 0x0F]; 
 state[0][2] = aes_invsbox[state[0][2] >> 4][state[0][2] & 0x0F]; 
 state[0][3] = aes_invsbox[state[0][3] >> 4][state[0][3] & 0x0F]; 
 state[1][0] = aes_invsbox[state[1][0] >> 4][state[1][0] & 0x0F]; 
 state[1][1] = aes_invsbox[state[1][1] >> 4][state[1][1] & 0x0F]; 
 state[1][2] = aes_invsbox[state[1][2] >> 4][state[1][2] & 0x0F]; 
 state[1][3] = aes_invsbox[state[1][3] >> 4][state[1][3] & 0x0F]; 
 state[2][0] = aes_invsbox[state[2][0] >> 4][state[2][0] & 0x0F]; 
 state[2][1] = aes_invsbox[state[2][1] >> 4][state[2][1] & 0x0F]; 
 state[2][2] = aes_invsbox[state[2][2] >> 4][state[2][2] & 0x0F]; 
 state[2][3] = aes_invsbox[state[2][3] >> 4][state[2][3] & 0x0F]; 
 state[3][0] = aes_invsbox[state[3][0] >> 4][state[3][0] & 0x0F]; 
 state[3][1] = aes_invsbox[state[3][1] >> 4][state[3][1] & 0x0F]; 
 state[3][2] = aes_invsbox[state[3][2] >> 4][state[3][2] & 0x0F]; 
 state[3][3] = aes_invsbox[state[3][3] >> 4][state[3][3] & 0x0F]; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""aes_invsbox"", ""type"": ""const BYTE [16][16]"", ""value"": ""[0]""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE aes_invsbox[16][16] 
void InvSubBytes(BYTE state[][4]) 
{ 
 state[0][0] = aes_invsbox[state[0][0] >> 4][state[0][0] & 0x0F]; 
 state[0][1] = aes_invsbox[state[0][1] >> 4][state[0][1] & 0x0F]; 
 state[0][2] = aes_invsbox[state[0][2] >> 4][state[0][2] & 0x0F]; 
 state[0][3] = aes_invsbox[state[0][3] >> 4][state[0][3] & 0x0F]; 
 state[1][0] = aes_invsbox[state[1][0] >> 4][state[1][0] & 0x0F]; 
 state[1][1] = aes_invsbox[state[1][1] >> 4][state[1][1] & 0x0F]; 
 state[1][2] = aes_invsbox[state[1][2] >> 4][state[1][2] & 0x0F]; 
 state[1][3] = aes_invsbox[state[1][3] >> 4][state[1][3] & 0x0F]; 
 state[2][0] = aes_invsbox[state[2][0] >> 4][state[2][0] & 0x0F]; 
 state[2][1] = aes_invsbox[state[2][1] >> 4][state[2][1] & 0x0F]; 
 state[2][2] = aes_invsbox[state[2][2] >> 4][state[2][2] & 0x0F]; 
 state[2][3] = aes_invsbox[state[2][3] >> 4][state[2][3] & 0x0F]; 
 state[3][0] = aes_invsbox[state[3][0] >> 4][state[3][0] & 0x0F]; 
 state[3][1] = aes_invsbox[state[3][1] >> 4][state[3][1] & 0x0F]; 
 state[3][2] = aes_invsbox[state[3][2] >> 4][state[3][2] & 0x0F]; 
 state[3][3] = aes_invsbox[state[3][3] >> 4][state[3][3] & 0x0F]; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""aes_invsbox"", ""type"": ""const BYTE [16][16]"", ""value"": ""[0]""}], ""outputs"": []}
{other test cases}
","{""func"": ""InvSubBytes"", ""file"": """", ""cases"": [{""desc"": ""Test case 1: All elements in state are zero"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 2: All elements in state are maximum value (0xFF)"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ShiftRows(BYTE state[][4]) 
{ 
 int t; 
 t = state[1][0]; 
 state[1][0] = state[1][1]; 
 state[1][1] = state[1][2]; 
 state[1][2] = state[1][3]; 
 state[1][3] = t; 
 t = state[2][0]; 
 state[2][0] = state[2][2]; 
 state[2][2] = t; 
 t = state[2][1]; 
 state[2][1] = state[2][3]; 
 state[2][3] = t; 
 t = state[3][0]; 
 state[3][0] = state[3][3]; 
 state[3][3] = state[3][2]; 
 state[3][2] = state[3][1]; 
 state[3][1] = t; 
}
","{""desc"": ""description text"", ""inputs"": [], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void ShiftRows(BYTE state[][4]) 
{ 
 int t; 
 t = state[1][0]; 
 state[1][0] = state[1][1]; 
 state[1][1] = state[1][2]; 
 state[1][2] = state[1][3]; 
 state[1][3] = t; 
 t = state[2][0]; 
 state[2][0] = state[2][2]; 
 state[2][2] = t; 
 t = state[2][1]; 
 state[2][1] = state[2][3]; 
 state[2][3] = t; 
 t = state[3][0]; 
 state[3][0] = state[3][3]; 
 state[3][3] = state[3][2]; 
 state[3][2] = state[3][1]; 
 state[3][1] = t; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [], ""outputs"": []}
{other test cases}
","{""func"": ""ShiftRows"", ""file"": """", ""cases"": [{""desc"": ""Test case 1: Basic functionality test with distinct values"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 2: All zero values"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 3: All values are the same non-zero value"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 4: Sequential values"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 5: Random values"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void InvShiftRows(BYTE state[][4]) 
{ 
 int t; 
 t = state[1][3]; 
 state[1][3] = state[1][2]; 
 state[1][2] = state[1][1]; 
 state[1][1] = state[1][0]; 
 state[1][0] = t; 
 t = state[2][3]; 
 state[2][3] = state[2][1]; 
 state[2][1] = t; 
 t = state[2][2]; 
 state[2][2] = state[2][0]; 
 state[2][0] = t; 
 t = state[3][3]; 
 state[3][3] = state[3][0]; 
 state[3][0] = state[3][1]; 
 state[3][1] = state[3][2]; 
 state[3][2] = t; 
}
","{""desc"": ""description text"", ""inputs"": [], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void InvShiftRows(BYTE state[][4]) 
{ 
 int t; 
 t = state[1][3]; 
 state[1][3] = state[1][2]; 
 state[1][2] = state[1][1]; 
 state[1][1] = state[1][0]; 
 state[1][0] = t; 
 t = state[2][3]; 
 state[2][3] = state[2][1]; 
 state[2][1] = t; 
 t = state[2][2]; 
 state[2][2] = state[2][0]; 
 state[2][0] = t; 
 t = state[3][3]; 
 state[3][3] = state[3][0]; 
 state[3][0] = state[3][1]; 
 state[3][1] = state[3][2]; 
 state[3][2] = t; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [], ""outputs"": []}
{other test cases}
","{""func"": ""InvShiftRows"", ""file"": """", ""cases"": [{""desc"": ""Basic shift operation with distinct values"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""All elements are zero"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""All elements are one"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Alternating pattern of values"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Mixed values in the state matrix"", ""inputs"": [], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE gf_mul[256][6] 
void MixColumns(BYTE state[][4]) 
{ 
 BYTE col[4]; 
 col[0] = state[0][0]; 
 col[1] = state[1][0]; 
 col[2] = state[2][0]; 
 col[3] = state[3][0]; 
 state[0][0] = gf_mul[col[0]][0]; 
 state[0][0] ^= gf_mul[col[1]][1]; 
 state[0][0] ^= col[2]; 
 state[0][0] ^= col[3]; 
 state[1][0] = col[0]; 
 state[1][0] ^= gf_mul[col[1]][0]; 
 state[1][0] ^= gf_mul[col[2]][1]; 
 state[1][0] ^= col[3]; 
 state[2][0] = col[0]; 
 state[2][0] ^= col[1]; 
 state[2][0] ^= gf_mul[col[2]][0]; 
 state[2][0] ^= gf_mul[col[3]][1]; 
 state[3][0] = gf_mul[col[0]][1]; 
 state[3][0] ^= col[1]; 
 state[3][0] ^= col[2]; 
 state[3][0] ^= gf_mul[col[3]][0]; 
 col[0] = state[0][1]; 
 col[1] = state[1][1]; 
 col[2] = state[2][1]; 
 col[3] = state[3][1]; 
 state[0][1] = gf_mul[col[0]][0]; 
 state[0][1] ^= gf_mul[col[1]][1]; 
 state[0][1] ^= col[2]; 
 state[0][1] ^= col[3]; 
 state[1][1] = col[0]; 
 state[1][1] ^= gf_mul[col[1]][0]; 
 state[1][1] ^= gf_mul[col[2]][1]; 
 state[1][1] ^= col[3]; 
 state[2][1] = col[0]; 
 state[2][1] ^= col[1]; 
 state[2][1] ^= gf_mul[col[2]][0]; 
 state[2][1] ^= gf_mul[col[3]][1]; 
 state[3][1] = gf_mul[col[0]][1]; 
 state[3][1] ^= col[1]; 
 state[3][1] ^= col[2]; 
 state[3][1] ^= gf_mul[col[3]][0]; 
 col[0] = state[0][2]; 
 col[1] = state[1][2]; 
 col[2] = state[2][2]; 
 col[3] = state[3][2]; 
 state[0][2] = gf_mul[col[0]][0]; 
 state[0][2] ^= gf_mul[col[1]][1]; 
 state[0][2] ^= col[2]; 
 state[0][2] ^= col[3]; 
 state[1][2] = col[0]; 
 state[1][2] ^= gf_mul[col[1]][0]; 
 state[1][2] ^= gf_mul[col[2]][1]; 
 state[1][2] ^= col[3]; 
 state[2][2] = col[0]; 
 state[2][2] ^= col[1]; 
 state[2][2] ^= gf_mul[col[2]][0]; 
 state[2][2] ^= gf_mul[col[3]][1]; 
 state[3][2] = gf_mul[col[0]][1]; 
 state[3][2] ^= col[1]; 
 state[3][2] ^= col[2]; 
 state[3][2] ^= gf_mul[col[3]][0]; 
 col[0] = state[0][3]; 
 col[1] = state[1][3]; 
 col[2] = state[2][3]; 
 col[3] = state[3][3]; 
 state[0][3] = gf_mul[col[0]][0]; 
 state[0][3] ^= gf_mul[col[1]][1]; 
 state[0][3] ^= col[2]; 
 state[0][3] ^= col[3]; 
 state[1][3] = col[0]; 
 state[1][3] ^= gf_mul[col[1]][0]; 
 state[1][3] ^= gf_mul[col[2]][1]; 
 state[1][3] ^= col[3]; 
 state[2][3] = col[0]; 
 state[2][3] ^= col[1]; 
 state[2][3] ^= gf_mul[col[2]][0]; 
 state[2][3] ^= gf_mul[col[3]][1]; 
 state[3][3] = gf_mul[col[0]][1]; 
 state[3][3] ^= col[1]; 
 state[3][3] ^= col[2]; 
 state[3][3] ^= gf_mul[col[3]][0]; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""gf_mul"", ""type"": ""const BYTE [256][6]"", ""value"": ""[0]""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE gf_mul[256][6] 
void MixColumns(BYTE state[][4]) 
{ 
 BYTE col[4]; 
 col[0] = state[0][0]; 
 col[1] = state[1][0]; 
 col[2] = state[2][0]; 
 col[3] = state[3][0]; 
 state[0][0] = gf_mul[col[0]][0]; 
 state[0][0] ^= gf_mul[col[1]][1]; 
 state[0][0] ^= col[2]; 
 state[0][0] ^= col[3]; 
 state[1][0] = col[0]; 
 state[1][0] ^= gf_mul[col[1]][0]; 
 state[1][0] ^= gf_mul[col[2]][1]; 
 state[1][0] ^= col[3]; 
 state[2][0] = col[0]; 
 state[2][0] ^= col[1]; 
 state[2][0] ^= gf_mul[col[2]][0]; 
 state[2][0] ^= gf_mul[col[3]][1]; 
 state[3][0] = gf_mul[col[0]][1]; 
 state[3][0] ^= col[1]; 
 state[3][0] ^= col[2]; 
 state[3][0] ^= gf_mul[col[3]][0]; 
 col[0] = state[0][1]; 
 col[1] = state[1][1]; 
 col[2] = state[2][1]; 
 col[3] = state[3][1]; 
 state[0][1] = gf_mul[col[0]][0]; 
 state[0][1] ^= gf_mul[col[1]][1]; 
 state[0][1] ^= col[2]; 
 state[0][1] ^= col[3]; 
 state[1][1] = col[0]; 
 state[1][1] ^= gf_mul[col[1]][0]; 
 state[1][1] ^= gf_mul[col[2]][1]; 
 state[1][1] ^= col[3]; 
 state[2][1] = col[0]; 
 state[2][1] ^= col[1]; 
 state[2][1] ^= gf_mul[col[2]][0]; 
 state[2][1] ^= gf_mul[col[3]][1]; 
 state[3][1] = gf_mul[col[0]][1]; 
 state[3][1] ^= col[1]; 
 state[3][1] ^= col[2]; 
 state[3][1] ^= gf_mul[col[3]][0]; 
 col[0] = state[0][2]; 
 col[1] = state[1][2]; 
 col[2] = state[2][2]; 
 col[3] = state[3][2]; 
 state[0][2] = gf_mul[col[0]][0]; 
 state[0][2] ^= gf_mul[col[1]][1]; 
 state[0][2] ^= col[2]; 
 state[0][2] ^= col[3]; 
 state[1][2] = col[0]; 
 state[1][2] ^= gf_mul[col[1]][0]; 
 state[1][2] ^= gf_mul[col[2]][1]; 
 state[1][2] ^= col[3]; 
 state[2][2] = col[0]; 
 state[2][2] ^= col[1]; 
 state[2][2] ^= gf_mul[col[2]][0]; 
 state[2][2] ^= gf_mul[col[3]][1]; 
 state[3][2] = gf_mul[col[0]][1]; 
 state[3][2] ^= col[1]; 
 state[3][2] ^= col[2]; 
 state[3][2] ^= gf_mul[col[3]][0]; 
 col[0] = state[0][3]; 
 col[1] = state[1][3]; 
 col[2] = state[2][3]; 
 col[3] = state[3][3]; 
 state[0][3] = gf_mul[col[0]][0]; 
 state[0][3] ^= gf_mul[col[1]][1]; 
 state[0][3] ^= col[2]; 
 state[0][3] ^= col[3]; 
 state[1][3] = col[0]; 
 state[1][3] ^= gf_mul[col[1]][0]; 
 state[1][3] ^= gf_mul[col[2]][1]; 
 state[1][3] ^= col[3]; 
 state[2][3] = col[0]; 
 state[2][3] ^= col[1]; 
 state[2][3] ^= gf_mul[col[2]][0]; 
 state[2][3] ^= gf_mul[col[3]][1]; 
 state[3][3] = gf_mul[col[0]][1]; 
 state[3][3] ^= col[1]; 
 state[3][3] ^= col[2]; 
 state[3][3] ^= gf_mul[col[3]][0]; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""gf_mul"", ""type"": ""const BYTE [256][6]"", ""value"": ""[0]""}], ""outputs"": []}
{other test cases}
","{""func"": ""MixColumns"", ""file"": """", ""cases"": [{""desc"": ""All elements in the state matrix are zeros."", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[0, 0, 0, 0, 0, 0] for _ in range(256)]""}, {""expr"": ""state"", ""value"": ""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Random values in the state matrix with a simple gf_mul table."", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[i, i, i, i, i, i] for i in range(256)]""}, {""expr"": ""state"", ""value"": ""[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[1, 2, 3, 4], [6, 7, 8, 9], [15, 16, 17, 18], [14, 15, 16, 17]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""All elements in the state matrix are 255 (maximum value for BYTE)."", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[255, 255, 255, 255, 255, 255] for _ in range(256)]""}, {""expr"": ""state"", ""value"": ""[[255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Mixed values in the state matrix with a more complex gf_mul table."", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[i ^ j for j in range(6)] for i in range(256)]""}, {""expr"": ""state"", ""value"": ""[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[1, 2, 3, 4], [6, 7, 8, 9], [15, 16, 17, 18], [14, 15, 16, 17]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Sequential values in the state matrix with a simple gf_mul table."", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[i, i, i, i, i, i] for i in range(256)]""}, {""expr"": ""state"", ""value"": ""[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[0, 1, 2, 3], [5, 6, 7, 8], [14, 15, 16, 17], [13, 14, 15, 16]]\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE gf_mul[256][6] 
void InvMixColumns(BYTE state[][4]) 
{ 
 BYTE col[4]; 
 col[0] = state[0][0]; 
 col[1] = state[1][0]; 
 col[2] = state[2][0]; 
 col[3] = state[3][0]; 
 state[0][0] = gf_mul[col[0]][5]; 
 state[0][0] ^= gf_mul[col[1]][3]; 
 state[0][0] ^= gf_mul[col[2]][4]; 
 state[0][0] ^= gf_mul[col[3]][2]; 
 state[1][0] = gf_mul[col[0]][2]; 
 state[1][0] ^= gf_mul[col[1]][5]; 
 state[1][0] ^= gf_mul[col[2]][3]; 
 state[1][0] ^= gf_mul[col[3]][4]; 
 state[2][0] = gf_mul[col[0]][4]; 
 state[2][0] ^= gf_mul[col[1]][2]; 
 state[2][0] ^= gf_mul[col[2]][5]; 
 state[2][0] ^= gf_mul[col[3]][3]; 
 state[3][0] = gf_mul[col[0]][3]; 
 state[3][0] ^= gf_mul[col[1]][4]; 
 state[3][0] ^= gf_mul[col[2]][2]; 
 state[3][0] ^= gf_mul[col[3]][5]; 
 col[0] = state[0][1]; 
 col[1] = state[1][1]; 
 col[2] = state[2][1]; 
 col[3] = state[3][1]; 
 state[0][1] = gf_mul[col[0]][5]; 
 state[0][1] ^= gf_mul[col[1]][3]; 
 state[0][1] ^= gf_mul[col[2]][4]; 
 state[0][1] ^= gf_mul[col[3]][2]; 
 state[1][1] = gf_mul[col[0]][2]; 
 state[1][1] ^= gf_mul[col[1]][5]; 
 state[1][1] ^= gf_mul[col[2]][3]; 
 state[1][1] ^= gf_mul[col[3]][4]; 
 state[2][1] = gf_mul[col[0]][4]; 
 state[2][1] ^= gf_mul[col[1]][2]; 
 state[2][1] ^= gf_mul[col[2]][5]; 
 state[2][1] ^= gf_mul[col[3]][3]; 
 state[3][1] = gf_mul[col[0]][3]; 
 state[3][1] ^= gf_mul[col[1]][4]; 
 state[3][1] ^= gf_mul[col[2]][2]; 
 state[3][1] ^= gf_mul[col[3]][5]; 
 col[0] = state[0][2]; 
 col[1] = state[1][2]; 
 col[2] = state[2][2]; 
 col[3] = state[3][2]; 
 state[0][2] = gf_mul[col[0]][5]; 
 state[0][2] ^= gf_mul[col[1]][3]; 
 state[0][2] ^= gf_mul[col[2]][4]; 
 state[0][2] ^= gf_mul[col[3]][2]; 
 state[1][2] = gf_mul[col[0]][2]; 
 state[1][2] ^= gf_mul[col[1]][5]; 
 state[1][2] ^= gf_mul[col[2]][3]; 
 state[1][2] ^= gf_mul[col[3]][4]; 
 state[2][2] = gf_mul[col[0]][4]; 
 state[2][2] ^= gf_mul[col[1]][2]; 
 state[2][2] ^= gf_mul[col[2]][5]; 
 state[2][2] ^= gf_mul[col[3]][3]; 
 state[3][2] = gf_mul[col[0]][3]; 
 state[3][2] ^= gf_mul[col[1]][4]; 
 state[3][2] ^= gf_mul[col[2]][2]; 
 state[3][2] ^= gf_mul[col[3]][5]; 
 col[0] = state[0][3]; 
 col[1] = state[1][3]; 
 col[2] = state[2][3]; 
 col[3] = state[3][3]; 
 state[0][3] = gf_mul[col[0]][5]; 
 state[0][3] ^= gf_mul[col[1]][3]; 
 state[0][3] ^= gf_mul[col[2]][4]; 
 state[0][3] ^= gf_mul[col[3]][2]; 
 state[1][3] = gf_mul[col[0]][2]; 
 state[1][3] ^= gf_mul[col[1]][5]; 
 state[1][3] ^= gf_mul[col[2]][3]; 
 state[1][3] ^= gf_mul[col[3]][4]; 
 state[2][3] = gf_mul[col[0]][4]; 
 state[2][3] ^= gf_mul[col[1]][2]; 
 state[2][3] ^= gf_mul[col[2]][5]; 
 state[2][3] ^= gf_mul[col[3]][3]; 
 state[3][3] = gf_mul[col[0]][3]; 
 state[3][3] ^= gf_mul[col[1]][4]; 
 state[3][3] ^= gf_mul[col[2]][2]; 
 state[3][3] ^= gf_mul[col[3]][5]; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""gf_mul"", ""type"": ""const BYTE [256][6]"", ""value"": ""[0]""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE gf_mul[256][6] 
void InvMixColumns(BYTE state[][4]) 
{ 
 BYTE col[4]; 
 col[0] = state[0][0]; 
 col[1] = state[1][0]; 
 col[2] = state[2][0]; 
 col[3] = state[3][0]; 
 state[0][0] = gf_mul[col[0]][5]; 
 state[0][0] ^= gf_mul[col[1]][3]; 
 state[0][0] ^= gf_mul[col[2]][4]; 
 state[0][0] ^= gf_mul[col[3]][2]; 
 state[1][0] = gf_mul[col[0]][2]; 
 state[1][0] ^= gf_mul[col[1]][5]; 
 state[1][0] ^= gf_mul[col[2]][3]; 
 state[1][0] ^= gf_mul[col[3]][4]; 
 state[2][0] = gf_mul[col[0]][4]; 
 state[2][0] ^= gf_mul[col[1]][2]; 
 state[2][0] ^= gf_mul[col[2]][5]; 
 state[2][0] ^= gf_mul[col[3]][3]; 
 state[3][0] = gf_mul[col[0]][3]; 
 state[3][0] ^= gf_mul[col[1]][4]; 
 state[3][0] ^= gf_mul[col[2]][2]; 
 state[3][0] ^= gf_mul[col[3]][5]; 
 col[0] = state[0][1]; 
 col[1] = state[1][1]; 
 col[2] = state[2][1]; 
 col[3] = state[3][1]; 
 state[0][1] = gf_mul[col[0]][5]; 
 state[0][1] ^= gf_mul[col[1]][3]; 
 state[0][1] ^= gf_mul[col[2]][4]; 
 state[0][1] ^= gf_mul[col[3]][2]; 
 state[1][1] = gf_mul[col[0]][2]; 
 state[1][1] ^= gf_mul[col[1]][5]; 
 state[1][1] ^= gf_mul[col[2]][3]; 
 state[1][1] ^= gf_mul[col[3]][4]; 
 state[2][1] = gf_mul[col[0]][4]; 
 state[2][1] ^= gf_mul[col[1]][2]; 
 state[2][1] ^= gf_mul[col[2]][5]; 
 state[2][1] ^= gf_mul[col[3]][3]; 
 state[3][1] = gf_mul[col[0]][3]; 
 state[3][1] ^= gf_mul[col[1]][4]; 
 state[3][1] ^= gf_mul[col[2]][2]; 
 state[3][1] ^= gf_mul[col[3]][5]; 
 col[0] = state[0][2]; 
 col[1] = state[1][2]; 
 col[2] = state[2][2]; 
 col[3] = state[3][2]; 
 state[0][2] = gf_mul[col[0]][5]; 
 state[0][2] ^= gf_mul[col[1]][3]; 
 state[0][2] ^= gf_mul[col[2]][4]; 
 state[0][2] ^= gf_mul[col[3]][2]; 
 state[1][2] = gf_mul[col[0]][2]; 
 state[1][2] ^= gf_mul[col[1]][5]; 
 state[1][2] ^= gf_mul[col[2]][3]; 
 state[1][2] ^= gf_mul[col[3]][4]; 
 state[2][2] = gf_mul[col[0]][4]; 
 state[2][2] ^= gf_mul[col[1]][2]; 
 state[2][2] ^= gf_mul[col[2]][5]; 
 state[2][2] ^= gf_mul[col[3]][3]; 
 state[3][2] = gf_mul[col[0]][3]; 
 state[3][2] ^= gf_mul[col[1]][4]; 
 state[3][2] ^= gf_mul[col[2]][2]; 
 state[3][2] ^= gf_mul[col[3]][5]; 
 col[0] = state[0][3]; 
 col[1] = state[1][3]; 
 col[2] = state[2][3]; 
 col[3] = state[3][3]; 
 state[0][3] = gf_mul[col[0]][5]; 
 state[0][3] ^= gf_mul[col[1]][3]; 
 state[0][3] ^= gf_mul[col[2]][4]; 
 state[0][3] ^= gf_mul[col[3]][2]; 
 state[1][3] = gf_mul[col[0]][2]; 
 state[1][3] ^= gf_mul[col[1]][5]; 
 state[1][3] ^= gf_mul[col[2]][3]; 
 state[1][3] ^= gf_mul[col[3]][4]; 
 state[2][3] = gf_mul[col[0]][4]; 
 state[2][3] ^= gf_mul[col[1]][2]; 
 state[2][3] ^= gf_mul[col[2]][5]; 
 state[2][3] ^= gf_mul[col[3]][3]; 
 state[3][3] = gf_mul[col[0]][3]; 
 state[3][3] ^= gf_mul[col[1]][4]; 
 state[3][3] ^= gf_mul[col[2]][2]; 
 state[3][3] ^= gf_mul[col[3]][5]; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""gf_mul"", ""type"": ""const BYTE [256][6]"", ""value"": ""[0]""}], ""outputs"": []}
{other test cases}
","{""func"": ""InvMixColumns"", ""file"": """", ""cases"": [{""desc"": ""Test with all zero state array and all zero gf_mul table"", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[0, 0, 0, 0, 0, 0] for _ in range(256)]""}, {""expr"": ""state"", ""value"": ""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with non-zero state array and all zero gf_mul table"", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[0, 0, 0, 0, 0, 0] for _ in range(256)]""}, {""expr"": ""state"", ""value"": ""[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with all zero state array and non-zero gf_mul table"", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[i for i in range(6)] for _ in range(256)]""}, {""expr"": ""state"", ""value"": ""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with non-zero state array and non-zero gf_mul table"", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[i for i in range(6)] for _ in range(256)]""}, {""expr"": ""state"", ""value"": ""[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with maximum values in state array and non-zero gf_mul table"", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[i for i in range(6)] for _ in range(256)]""}, {""expr"": ""state"", ""value"": ""[[255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5]]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with alternating values in state array and non-zero gf_mul table"", ""inputs"": [{""expr"": ""gf_mul"", ""value"": ""[[i for i in range(6)] for _ in range(256)]""}, {""expr"": ""state"", ""value"": ""[[0, 255, 0, 255], [255, 0, 255, 0], [0, 255, 0, 255], [255, 0, 255, 0]]""}], ""stubins"": [], ""outputs"": [{""expr"": ""state"", ""value"": ""\""[[5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5]]\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void aes_encrypt(const BYTE in[], BYTE out[], const WORD key[], int keysize) 
{ 
 BYTE state[4][4]; 
 state[0][0] = in[0]; 
 state[1][0] = in[1]; 
 state[2][0] = in[2]; 
 state[3][0] = in[3]; 
 state[0][1] = in[4]; 
 state[1][1] = in[5]; 
 state[2][1] = in[6]; 
 state[3][1] = in[7]; 
 state[0][2] = in[8]; 
 state[1][2] = in[9]; 
 state[2][2] = in[10]; 
 state[3][2] = in[11]; 
 state[0][3] = in[12]; 
 state[1][3] = in[13]; 
 state[2][3] = in[14]; 
 state[3][3] = in[15]; 
 AddRoundKey(state,&key[0]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[4]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[8]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[12]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[16]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[20]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[24]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[28]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[32]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[36]); 
 if (keysize != 128) { 
  SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[40]); 
  SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[44]); 
  if (keysize != 192) { 
   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[48]); 
   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[52]); 
   SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[56]); 
  } 
  else { 
   SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[48]); 
  } 
 } 
 else { 
  SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[40]); 
 } 
 out[0] = state[0][0]; 
 out[1] = state[1][0]; 
 out[2] = state[2][0]; 
 out[3] = state[3][0]; 
 out[4] = state[0][1]; 
 out[5] = state[1][1]; 
 out[6] = state[2][1]; 
 out[7] = state[3][1]; 
 out[8] = state[0][2]; 
 out[9] = state[1][2]; 
 out[10] = state[2][2]; 
 out[11] = state[3][2]; 
 out[12] = state[0][3]; 
 out[13] = state[1][3]; 
 out[14] = state[2][3]; 
 out[15] = state[3][3]; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void AddRoundKey(BYTE (*state)[4],const WORD *w)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}, {""expr"": ""*w"", ""type"": ""const WORD"", ""value"": 0}]}, {""called function"": ""void MixColumns(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""gf_mul"", ""type"": ""const BYTE [256][6]"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}, {""called function"": ""void SubBytes(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}, {""called function"": ""void ShiftRows(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void aes_encrypt(const BYTE in[], BYTE out[], const WORD key[], int keysize) 
{ 
 BYTE state[4][4]; 
 state[0][0] = in[0]; 
 state[1][0] = in[1]; 
 state[2][0] = in[2]; 
 state[3][0] = in[3]; 
 state[0][1] = in[4]; 
 state[1][1] = in[5]; 
 state[2][1] = in[6]; 
 state[3][1] = in[7]; 
 state[0][2] = in[8]; 
 state[1][2] = in[9]; 
 state[2][2] = in[10]; 
 state[3][2] = in[11]; 
 state[0][3] = in[12]; 
 state[1][3] = in[13]; 
 state[2][3] = in[14]; 
 state[3][3] = in[15]; 
 AddRoundKey(state,&key[0]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[4]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[8]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[12]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[16]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[20]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[24]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[28]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[32]); 
 SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[36]); 
 if (keysize != 128) { 
  SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[40]); 
  SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[44]); 
  if (keysize != 192) { 
   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[48]); 
   SubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[52]); 
   SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[56]); 
  } 
  else { 
   SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[48]); 
  } 
 } 
 else { 
  SubBytes(state); ShiftRows(state); AddRoundKey(state,&key[40]); 
 } 
 out[0] = state[0][0]; 
 out[1] = state[1][0]; 
 out[2] = state[2][0]; 
 out[3] = state[3][0]; 
 out[4] = state[0][1]; 
 out[5] = state[1][1]; 
 out[6] = state[2][1]; 
 out[7] = state[3][1]; 
 out[8] = state[0][2]; 
 out[9] = state[1][2]; 
 out[10] = state[2][2]; 
 out[11] = state[3][2]; 
 out[12] = state[0][3]; 
 out[13] = state[1][3]; 
 out[14] = state[2][3]; 
 out[15] = state[3][3]; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void AddRoundKey(BYTE (*state)[4],const WORD *w)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}, {""expr"": ""*w"", ""type"": ""const WORD"", ""value"": 0}]}, {""called function"": ""void MixColumns(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""gf_mul"", ""type"": ""const BYTE [256][6]"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}, {""called function"": ""void SubBytes(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}, {""called function"": ""void ShiftRows(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""aes_encrypt"", ""file"": """", ""cases"": [{""desc"": ""Test case with keysize 128 (only first branch)"", ""inputs"": [{""expr"": ""key_PTRTO[0]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[2]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[3]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""keysize"", ""value"": 128}, {""expr"": ""in[0]"", ""value"": ""0x32""}, {""expr"": ""in[1]"", ""value"": ""0x88""}, {""expr"": ""in[2]"", ""value"": ""0x31""}, {""expr"": ""in[3]"", ""value"": ""0xe0""}, {""expr"": ""in[4]"", ""value"": ""0x43""}, {""expr"": ""in[5]"", ""value"": ""0x5a""}, {""expr"": ""in[6]"", ""value"": ""0x31""}, {""expr"": ""in[7]"", ""value"": ""0x37""}, {""expr"": ""in[8]"", ""value"": ""0xf6""}, {""expr"": ""in[9]"", ""value"": ""0x30""}, {""expr"": ""in[10]"", ""value"": ""0x98""}, {""expr"": ""in[11]"", ""value"": ""0x07""}, {""expr"": ""in[12]"", ""value"": ""0xa8""}, {""expr"": ""in[13]"", ""value"": ""0x8d""}, {""expr"": ""in[14]"", ""value"": ""0xa2""}, {""expr"": ""in[15]"", ""value"": ""0x34""}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""out[8]"", ""value"": 0}, {""expr"": ""out[9]"", ""value"": 0}, {""expr"": ""out[10]"", ""value"": 0}, {""expr"": ""out[11]"", ""value"": 0}, {""expr"": ""out[12]"", ""value"": 0}, {""expr"": ""out[13]"", ""value"": 0}, {""expr"": ""out[14]"", ""value"": 0}, {""expr"": ""out[15]"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""*w"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""MixColumns""}, {""expr"": ""gf_mul"", ""value"": 0, ""funcName"": ""MixColumns""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""SubBytes""}, {""expr"": ""aes_sbox"", ""value"": 0, ""funcName"": ""SubBytes""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""ShiftRows""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with keysize 192 (first and second branch)"", ""inputs"": [{""expr"": ""key_PTRTO[0]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[2]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[3]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""key_PTRTO[4]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[5]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[6]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[7]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""keysize"", ""value"": 192}, {""expr"": ""in[0]"", ""value"": ""0x32""}, {""expr"": ""in[1]"", ""value"": ""0x88""}, {""expr"": ""in[2]"", ""value"": ""0x31""}, {""expr"": ""in[3]"", ""value"": ""0xe0""}, {""expr"": ""in[4]"", ""value"": ""0x43""}, {""expr"": ""in[5]"", ""value"": ""0x5a""}, {""expr"": ""in[6]"", ""value"": ""0x31""}, {""expr"": ""in[7]"", ""value"": ""0x37""}, {""expr"": ""in[8]"", ""value"": ""0xf6""}, {""expr"": ""in[9]"", ""value"": ""0x30""}, {""expr"": ""in[10]"", ""value"": ""0x98""}, {""expr"": ""in[11]"", ""value"": ""0x07""}, {""expr"": ""in[12]"", ""value"": ""0xa8""}, {""expr"": ""in[13]"", ""value"": ""0x8d""}, {""expr"": ""in[14]"", ""value"": ""0xa2""}, {""expr"": ""in[15]"", ""value"": ""0x34""}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""out[8]"", ""value"": 0}, {""expr"": ""out[9]"", ""value"": 0}, {""expr"": ""out[10]"", ""value"": 0}, {""expr"": ""out[11]"", ""value"": 0}, {""expr"": ""out[12]"", ""value"": 0}, {""expr"": ""out[13]"", ""value"": 0}, {""expr"": ""out[14]"", ""value"": 0}, {""expr"": ""out[15]"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""*w"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""MixColumns""}, {""expr"": ""gf_mul"", ""value"": 0, ""funcName"": ""MixColumns""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""SubBytes""}, {""expr"": ""aes_sbox"", ""value"": 0, ""funcName"": ""SubBytes""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""ShiftRows""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with keysize 256 (all branches)"", ""inputs"": [{""expr"": ""key_PTRTO[0]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[2]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[3]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""key_PTRTO[4]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[5]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[6]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[7]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""keysize"", ""value"": 256}, {""expr"": ""in[0]"", ""value"": ""0x32""}, {""expr"": ""in[1]"", ""value"": ""0x88""}, {""expr"": ""in[2]"", ""value"": ""0x31""}, {""expr"": ""in[3]"", ""value"": ""0xe0""}, {""expr"": ""in[4]"", ""value"": ""0x43""}, {""expr"": ""in[5]"", ""value"": ""0x5a""}, {""expr"": ""in[6]"", ""value"": ""0x31""}, {""expr"": ""in[7]"", ""value"": ""0x37""}, {""expr"": ""in[8]"", ""value"": ""0xf6""}, {""expr"": ""in[9]"", ""value"": ""0x30""}, {""expr"": ""in[10]"", ""value"": ""0x98""}, {""expr"": ""in[11]"", ""value"": ""0x07""}, {""expr"": ""in[12]"", ""value"": ""0xa8""}, {""expr"": ""in[13]"", ""value"": ""0x8d""}, {""expr"": ""in[14]"", ""value"": ""0xa2""}, {""expr"": ""in[15]"", ""value"": ""0x34""}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""out[8]"", ""value"": 0}, {""expr"": ""out[9]"", ""value"": 0}, {""expr"": ""out[10]"", ""value"": 0}, {""expr"": ""out[11]"", ""value"": 0}, {""expr"": ""out[12]"", ""value"": 0}, {""expr"": ""out[13]"", ""value"": 0}, {""expr"": ""out[14]"", ""value"": 0}, {""expr"": ""out[15]"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""*w"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""MixColumns""}, {""expr"": ""gf_mul"", ""value"": 0, ""funcName"": ""MixColumns""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""SubBytes""}, {""expr"": ""aes_sbox"", ""value"": 0, ""funcName"": ""SubBytes""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""ShiftRows""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""key"", ""userVar"": ""key_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void aes_decrypt(const BYTE in[], BYTE out[], const WORD key[], int keysize) 
{ 
 BYTE state[4][4]; 
 state[0][0] = in[0]; 
 state[1][0] = in[1]; 
 state[2][0] = in[2]; 
 state[3][0] = in[3]; 
 state[0][1] = in[4]; 
 state[1][1] = in[5]; 
 state[2][1] = in[6]; 
 state[3][1] = in[7]; 
 state[0][2] = in[8]; 
 state[1][2] = in[9]; 
 state[2][2] = in[10]; 
 state[3][2] = in[11]; 
 state[0][3] = in[12]; 
 state[1][3] = in[13]; 
 state[2][3] = in[14]; 
 state[3][3] = in[15]; 
 if (keysize > 128) { 
  if (keysize > 192) { 
   AddRoundKey(state,&key[56]); 
   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[52]);InvMixColumns(state); 
   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[48]);InvMixColumns(state); 
  } 
  else { 
   AddRoundKey(state,&key[48]); 
  } 
  InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[44]);InvMixColumns(state); 
  InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[40]);InvMixColumns(state); 
 } 
 else { 
  AddRoundKey(state,&key[40]); 
 } 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[36]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[32]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[28]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[24]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[20]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[16]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[12]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[8]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[4]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[0]); 
 out[0] = state[0][0]; 
 out[1] = state[1][0]; 
 out[2] = state[2][0]; 
 out[3] = state[3][0]; 
 out[4] = state[0][1]; 
 out[5] = state[1][1]; 
 out[6] = state[2][1]; 
 out[7] = state[3][1]; 
 out[8] = state[0][2]; 
 out[9] = state[1][2]; 
 out[10] = state[2][2]; 
 out[11] = state[3][2]; 
 out[12] = state[0][3]; 
 out[13] = state[1][3]; 
 out[14] = state[2][3]; 
 out[15] = state[3][3]; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void InvMixColumns(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""gf_mul"", ""type"": ""const BYTE [256][6]"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}, {""called function"": ""void AddRoundKey(BYTE (*state)[4],const WORD *w)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}, {""expr"": ""*w"", ""type"": ""const WORD"", ""value"": 0}]}, {""called function"": ""void InvShiftRows(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}, {""called function"": ""void InvSubBytes(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""aes_invsbox"", ""type"": ""const BYTE [16][16]"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void aes_decrypt(const BYTE in[], BYTE out[], const WORD key[], int keysize) 
{ 
 BYTE state[4][4]; 
 state[0][0] = in[0]; 
 state[1][0] = in[1]; 
 state[2][0] = in[2]; 
 state[3][0] = in[3]; 
 state[0][1] = in[4]; 
 state[1][1] = in[5]; 
 state[2][1] = in[6]; 
 state[3][1] = in[7]; 
 state[0][2] = in[8]; 
 state[1][2] = in[9]; 
 state[2][2] = in[10]; 
 state[3][2] = in[11]; 
 state[0][3] = in[12]; 
 state[1][3] = in[13]; 
 state[2][3] = in[14]; 
 state[3][3] = in[15]; 
 if (keysize > 128) { 
  if (keysize > 192) { 
   AddRoundKey(state,&key[56]); 
   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[52]);InvMixColumns(state); 
   InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[48]);InvMixColumns(state); 
  } 
  else { 
   AddRoundKey(state,&key[48]); 
  } 
  InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[44]);InvMixColumns(state); 
  InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[40]);InvMixColumns(state); 
 } 
 else { 
  AddRoundKey(state,&key[40]); 
 } 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[36]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[32]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[28]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[24]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[20]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[16]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[12]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[8]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[4]);InvMixColumns(state); 
 InvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[0]); 
 out[0] = state[0][0]; 
 out[1] = state[1][0]; 
 out[2] = state[2][0]; 
 out[3] = state[3][0]; 
 out[4] = state[0][1]; 
 out[5] = state[1][1]; 
 out[6] = state[2][1]; 
 out[7] = state[3][1]; 
 out[8] = state[0][2]; 
 out[9] = state[1][2]; 
 out[10] = state[2][2]; 
 out[11] = state[3][2]; 
 out[12] = state[0][3]; 
 out[13] = state[1][3]; 
 out[14] = state[2][3]; 
 out[15] = state[3][3]; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""key[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""void InvMixColumns(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""gf_mul"", ""type"": ""const BYTE [256][6]"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}, {""called function"": ""void AddRoundKey(BYTE (*state)[4],const WORD *w)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}, {""expr"": ""*w"", ""type"": ""const WORD"", ""value"": 0}]}, {""called function"": ""void InvShiftRows(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}, {""called function"": ""void InvSubBytes(BYTE (*state)[4])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""aes_invsbox"", ""type"": ""const BYTE [16][16]"", ""value"": 0}, {""expr"": ""state"", ""type"": ""BYTE (*)[4]"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""aes_decrypt"", ""file"": """", ""cases"": [{""desc"": ""Test with keysize = 128"", ""inputs"": [{""expr"": ""in"", ""value"": ""0123456789abcdef""}, {""expr"": ""out"", ""value"": ""0000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[2]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[3]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""keysize"", ""value"": 128}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvMixColumns""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""*w"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvShiftRows""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvSubBytes""}, {""expr"": ""aes_invsbox"", ""value"": 0, ""funcName"": ""InvSubBytes""}], ""outputs"": [{""expr"": ""out[0]"", ""value"": ""0x63""}, {""expr"": ""out[1]"", ""value"": ""0xf2""}, {""expr"": ""out[2]"", ""value"": ""0x30""}, {""expr"": ""out[3]"", ""value"": ""0xfe""}, {""expr"": ""out[4]"", ""value"": ""0x7c""}, {""expr"": ""out[5]"", ""value"": ""0x6b""}, {""expr"": ""out[6]"", ""value"": ""0x01""}, {""expr"": ""out[7]"", ""value"": ""0xd7""}, {""expr"": ""out[8]"", ""value"": ""0x77""}, {""expr"": ""out[9]"", ""value"": ""0x6f""}, {""expr"": ""out[10]"", ""value"": ""0x67""}, {""expr"": ""out[11]"", ""value"": ""0xab""}, {""expr"": ""out[12]"", ""value"": ""0x7b""}, {""expr"": ""out[13]"", ""value"": ""0xc5""}, {""expr"": ""out[14]"", ""value"": ""0x2b""}, {""expr"": ""out[15]"", ""value"": ""0x76""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with keysize = 192"", ""inputs"": [{""expr"": ""in"", ""value"": ""0123456789abcdef""}, {""expr"": ""out"", ""value"": ""0000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[2]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[3]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""key_PTRTO[4]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[5]"", ""value"": ""0x28aed2a6""}, {""expr"": ""keysize"", ""value"": 192}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvMixColumns""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""*w"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvShiftRows""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvSubBytes""}, {""expr"": ""aes_invsbox"", ""value"": 0, ""funcName"": ""InvSubBytes""}], ""outputs"": [{""expr"": ""out[0]"", ""value"": ""0x63""}, {""expr"": ""out[1]"", ""value"": ""0xf2""}, {""expr"": ""out[2]"", ""value"": ""0x30""}, {""expr"": ""out[3]"", ""value"": ""0xfe""}, {""expr"": ""out[4]"", ""value"": ""0x7c""}, {""expr"": ""out[5]"", ""value"": ""0x6b""}, {""expr"": ""out[6]"", ""value"": ""0x01""}, {""expr"": ""out[7]"", ""value"": ""0xd7""}, {""expr"": ""out[8]"", ""value"": ""0x77""}, {""expr"": ""out[9]"", ""value"": ""0x6f""}, {""expr"": ""out[10]"", ""value"": ""0x67""}, {""expr"": ""out[11]"", ""value"": ""0xab""}, {""expr"": ""out[12]"", ""value"": ""0x7b""}, {""expr"": ""out[13]"", ""value"": ""0xc5""}, {""expr"": ""out[14]"", ""value"": ""0x2b""}, {""expr"": ""out[15]"", ""value"": ""0x76""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with keysize = 256"", ""inputs"": [{""expr"": ""in"", ""value"": ""0123456789abcdef""}, {""expr"": ""out"", ""value"": ""0000000000000000""}, {""expr"": ""key_PTRTO[0]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[1]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[2]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[3]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""key_PTRTO[4]"", ""value"": ""0x2b7e1516""}, {""expr"": ""key_PTRTO[5]"", ""value"": ""0x28aed2a6""}, {""expr"": ""key_PTRTO[6]"", ""value"": ""0xabf71588""}, {""expr"": ""key_PTRTO[7]"", ""value"": ""0x09cf4f3c""}, {""expr"": ""keysize"", ""value"": 256}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvMixColumns""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""*w"", ""value"": 0, ""funcName"": ""AddRoundKey""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvShiftRows""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""InvSubBytes""}, {""expr"": ""aes_invsbox"", ""value"": 0, ""funcName"": ""InvSubBytes""}], ""outputs"": [{""expr"": ""out[0]"", ""value"": ""0x63""}, {""expr"": ""out[1]"", ""value"": ""0xf2""}, {""expr"": ""out[2]"", ""value"": ""0x30""}, {""expr"": ""out[3]"", ""value"": ""0xfe""}, {""expr"": ""out[4]"", ""value"": ""0x7c""}, {""expr"": ""out[5]"", ""value"": ""0x6b""}, {""expr"": ""out[6]"", ""value"": ""0x01""}, {""expr"": ""out[7]"", ""value"": ""0xd7""}, {""expr"": ""out[8]"", ""value"": ""0x77""}, {""expr"": ""out[9]"", ""value"": ""0x6f""}, {""expr"": ""out[10]"", ""value"": ""0x67""}, {""expr"": ""out[11]"", ""value"": ""0xab""}, {""expr"": ""out[12]"", ""value"": ""0x7b""}, {""expr"": ""out[13]"", ""value"": ""0xc5""}, {""expr"": ""out[14]"", ""value"": ""0x2b""}, {""expr"": ""out[15]"", ""value"": ""0x76""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""key"", ""userVar"": ""key_PTRTO""}], ""ios"": []}"
arcfour,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void arcfour_key_setup(BYTE state[], const BYTE key[], int len) 
{ 
 int i, j; 
 BYTE t; 
 for (i = 0; i < 256; ++i) 
  state[i] = i; 
 for (i = 0, j = 0; i < 256; ++i) { 
  j = (j + state[i] + key[i % len]) % 256; 
  t = state[i]; 
  state[i] = state[j]; 
  state[j] = t; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""state"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""int"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void arcfour_key_setup(BYTE state[], const BYTE key[], int len) 
{ 
 int i, j; 
 BYTE t; 
 for (i = 0; i < 256; ++i) 
  state[i] = i; 
 for (i = 0, j = 0; i < 256; ++i) { 
  j = (j + state[i] + key[i % len]) % 256; 
  t = state[i]; 
  state[i] = state[j]; 
  state[j] = t; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""state"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""int"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""arcfour_key_setup"", ""file"": """", ""cases"": [], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
arcfour,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void arcfour_generate_stream(BYTE state[], BYTE out[], size_t len) 
{ 
 int i, j; 
 size_t idx; 
 BYTE t; 
 for (idx = 0, i = 0, j = 0; idx < len; ++idx) { 
  i = (i + 1) % 256; 
  j = (j + state[i]) % 256; 
  t = state[i]; 
  state[i] = state[j]; 
  state[j] = t; 
  out[idx] = state[(state[i] + state[j]) % 256]; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""state"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void arcfour_generate_stream(BYTE state[], BYTE out[], size_t len) 
{ 
 int i, j; 
 size_t idx; 
 BYTE t; 
 for (idx = 0, i = 0, j = 0; idx < len; ++idx) { 
  i = (i + 1) % 256; 
  j = (j + state[i]) % 256; 
  t = state[i]; 
  state[i] = state[j]; 
  state[j] = t; 
  out[idx] = state[(state[i] + state[j]) % 256]; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""state"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""arcfour_generate_stream"", ""file"": """", ""cases"": [{""desc"": ""Test with length zero"", ""inputs"": [{""expr"": ""len"", ""value"": 0}, {""expr"": ""state[0]"", ""value"": 0}, {""expr"": ""state[1]"", ""value"": 1}, {""expr"": ""state[2]"", ""value"": 2}, {""expr"": ""state[3]"", ""value"": 3}, {""expr"": ""state[4]"", ""value"": 4}, {""expr"": ""state[5]"", ""value"": 5}, {""expr"": ""state[6]"", ""value"": 6}, {""expr"": ""state[7]"", ""value"": 7}, {""expr"": ""state[8]"", ""value"": 8}, {""expr"": ""state[9]"", ""value"": 9}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with length one"", ""inputs"": [{""expr"": ""len"", ""value"": 1}, {""expr"": ""state[0]"", ""value"": 0}, {""expr"": ""state[1]"", ""value"": 1}, {""expr"": ""state[2]"", ""value"": 2}, {""expr"": ""state[3]"", ""value"": 3}, {""expr"": ""state[4]"", ""value"": 4}, {""expr"": ""state[5]"", ""value"": 5}, {""expr"": ""state[6]"", ""value"": 6}, {""expr"": ""state[7]"", ""value"": 7}, {""expr"": ""state[8]"", ""value"": 8}, {""expr"": ""state[9]"", ""value"": 9}, {""expr"": ""out[0]"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""out[0]"", ""value"": ""\""expected_value\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with length greater than state size"", ""inputs"": [{""expr"": ""len"", ""value"": 10}, {""expr"": ""state[0]"", ""value"": 0}, {""expr"": ""state[1]"", ""value"": 1}, {""expr"": ""state[2]"", ""value"": 2}, {""expr"": ""state[3]"", ""value"": 3}, {""expr"": ""state[4]"", ""value"": 4}, {""expr"": ""state[5]"", ""value"": 5}, {""expr"": ""state[6]"", ""value"": 6}, {""expr"": ""state[7]"", ""value"": 7}, {""expr"": ""state[8]"", ""value"": 8}, {""expr"": ""state[9]"", ""value"": 9}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""out[8]"", ""value"": 0}, {""expr"": ""out[9]"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""out[0]"", ""value"": ""\""expected_value_0\""""}, {""expr"": ""out[1]"", ""value"": ""\""expected_value_1\""""}, {""expr"": ""out[2]"", ""value"": ""\""expected_value_2\""""}, {""expr"": ""out[3]"", ""value"": ""\""expected_value_3\""""}, {""expr"": ""out[4]"", ""value"": ""\""expected_value_4\""""}, {""expr"": ""out[5]"", ""value"": ""\""expected_value_5\""""}, {""expr"": ""out[6]"", ""value"": ""\""expected_value_6\""""}, {""expr"": ""out[7]"", ""value"": ""\""expected_value_7\""""}, {""expr"": ""out[8]"", ""value"": ""\""expected_value_8\""""}, {""expr"": ""out[9]"", ""value"": ""\""expected_value_9\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with maximum state size"", ""inputs"": [{""expr"": ""len"", ""value"": 256}], ""stubins"": [], ""outputs"": [{""expr"": ""out[i]"", ""value"": ""\""expected_value_i\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with random state values"", ""inputs"": [{""expr"": ""len"", ""value"": 10}, {""expr"": ""state[0]"", ""value"": 42}, {""expr"": ""state[1]"", ""value"": 255}, {""expr"": ""state[2]"", ""value"": 1}, {""expr"": ""state[3]"", ""value"": 128}, {""expr"": ""state[4]"", ""value"": 64}, {""expr"": ""state[5]"", ""value"": 32}, {""expr"": ""state[6]"", ""value"": 16}, {""expr"": ""state[7]"", ""value"": 8}, {""expr"": ""state[8]"", ""value"": 4}, {""expr"": ""state[9]"", ""value"": 2}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""out[8]"", ""value"": 0}, {""expr"": ""out[9]"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""out[0]"", ""value"": ""\""expected_value_0\""""}, {""expr"": ""out[1]"", ""value"": ""\""expected_value_1\""""}, {""expr"": ""out[2]"", ""value"": ""\""expected_value_2\""""}, {""expr"": ""out[3]"", ""value"": ""\""expected_value_3\""""}, {""expr"": ""out[4]"", ""value"": ""\""expected_value_4\""""}, {""expr"": ""out[5]"", ""value"": ""\""expected_value_5\""""}, {""expr"": ""out[6]"", ""value"": ""\""expected_value_6\""""}, {""expr"": ""out[7]"", ""value"": ""\""expected_value_7\""""}, {""expr"": ""out[8]"", ""value"": ""\""expected_value_8\""""}, {""expr"": ""out[9]"", ""value"": ""\""expected_value_9\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with state containing identical values"", ""inputs"": [{""expr"": ""len"", ""value"": 10}, {""expr"": ""state[0]"", ""value"": 1}, {""expr"": ""state[1]"", ""value"": 1}, {""expr"": ""state[2]"", ""value"": 1}, {""expr"": ""state[3]"", ""value"": 1}, {""expr"": ""state[4]"", ""value"": 1}, {""expr"": ""state[5]"", ""value"": 1}, {""expr"": ""state[6]"", ""value"": 1}, {""expr"": ""state[7]"", ""value"": 1}, {""expr"": ""state[8]"", ""value"": 1}, {""expr"": ""state[9]"", ""value"": 1}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""out[8]"", ""value"": 0}, {""expr"": ""out[9]"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""out[0]"", ""value"": ""\""expected_value_0\""""}, {""expr"": ""out[1]"", ""value"": ""\""expected_value_1\""""}, {""expr"": ""out[2]"", ""value"": ""\""expected_value_2\""""}, {""expr"": ""out[3]"", ""value"": ""\""expected_value_3\""""}, {""expr"": ""out[4]"", ""value"": ""\""expected_value_4\""""}, {""expr"": ""out[5]"", ""value"": ""\""expected_value_5\""""}, {""expr"": ""out[6]"", ""value"": ""\""expected_value_6\""""}, {""expr"": ""out[7]"", ""value"": ""\""expected_value_7\""""}, {""expr"": ""out[8]"", ""value"": ""\""expected_value_8\""""}, {""expr"": ""out[9]"", ""value"": ""\""expected_value_9\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
base64,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
BYTE revchar(char ch) 
{ 
 if (ch >= 'A' && ch <= 'Z') 
  ch -= 'A'; 
 else if (ch >= 'a' && ch <='z') 
  ch = ch - 'a' + 26; 
 else if (ch >= '0' && ch <='9') 
  ch = ch - '0' + 52; 
 else if (ch == '+') 
  ch = 62; 
 else if (ch == '/') 
  ch = 63; 
 return(ch); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ch"", ""type"": ""char"", ""value"": ""a""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""BYTE"", ""value"": ""a""}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
BYTE revchar(char ch) 
{ 
 if (ch >= 'A' && ch <= 'Z') 
  ch -= 'A'; 
 else if (ch >= 'a' && ch <='z') 
  ch = ch - 'a' + 26; 
 else if (ch >= '0' && ch <='9') 
  ch = ch - '0' + 52; 
 else if (ch == '+') 
  ch = 62; 
 else if (ch == '/') 
  ch = 63; 
 return(ch); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ch"", ""type"": ""char"", ""value"": ""a""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""BYTE"", ""value"": ""a""}]}
{other test cases}
","{""func"": ""revchar"", ""file"": """", ""cases"": [{""desc"": ""Test case for uppercase letter 'B'"", ""inputs"": [{""expr"": ""ch"", ""value"": ""B""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 1}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for lowercase letter 'b'"", ""inputs"": [{""expr"": ""ch"", ""value"": ""b""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 27}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for digit '5'"", ""inputs"": [{""expr"": ""ch"", ""value"": ""5""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 57}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for '+' character"", ""inputs"": [{""expr"": ""ch"", ""value"": ""+""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 62}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for '/' character"", ""inputs"": [{""expr"": ""ch"", ""value"": ""/""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 63}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for character '@' which doesn't match any condition"", ""inputs"": [{""expr"": ""ch"", ""value"": ""@""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": ""\""@\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for the edge case of uppercase letter 'Z'"", ""inputs"": [{""expr"": ""ch"", ""value"": ""Z""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 25}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for the edge case of lowercase letter 'z'"", ""inputs"": [{""expr"": ""ch"", ""value"": ""z""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 51}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for the edge case of digit '0'"", ""inputs"": [{""expr"": ""ch"", ""value"": ""0""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 52}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for the edge case of digit '9'"", ""inputs"": [{""expr"": ""ch"", ""value"": ""9""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 61}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
base64,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE charset[]; 
size_t base64_encode(const BYTE in[], BYTE out[], size_t len, int newline_flag) 
{ 
 size_t idx, idx2, blks, blk_ceiling, left_over, newline_count = 0; 
 blks = (len / 3); 
 left_over = len % 3; 
 if (out == ((void *) 0)) { 
  idx2 = blks * 4 ; 
  if (left_over) 
   idx2 += 4; 
  if (newline_flag) 
   idx2 += len / 57; 
 } 
 else { 
  blk_ceiling = blks * 3; 
  for (idx = 0, idx2 = 0; idx < blk_ceiling; idx += 3, idx2 += 4) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)]; 
   out[idx2 + 2] = charset[((in[idx + 1] & 0x0f) << 2) | (in[idx + 2] >> 6)]; 
   out[idx2 + 3] = charset[in[idx + 2] & 0x3F]; 
   if (((idx2 - newline_count + 4) % 76 == 0) && newline_flag) { 
    out[idx2 + 4] = '\n'; 
    idx2++; 
    newline_count++; 
   } 
  } 
  if (left_over == 1) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[(in[idx] & 0x03) << 4]; 
   out[idx2 + 2] = '='; 
   out[idx2 + 3] = '='; 
   idx2 += 4; 
  } 
  else if (left_over == 2) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)]; 
   out[idx2 + 2] = charset[(in[idx + 1] & 0x0F) << 2]; 
   out[idx2 + 3] = '='; 
   idx2 += 4; 
  } 
 } 
 return(idx2); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0}, {""expr"": ""charset"", ""type"": ""const BYTE [1]"", ""value"": ""[0]""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE charset[]; 
size_t base64_encode(const BYTE in[], BYTE out[], size_t len, int newline_flag) 
{ 
 size_t idx, idx2, blks, blk_ceiling, left_over, newline_count = 0; 
 blks = (len / 3); 
 left_over = len % 3; 
 if (out == ((void *) 0)) { 
  idx2 = blks * 4 ; 
  if (left_over) 
   idx2 += 4; 
  if (newline_flag) 
   idx2 += len / 57; 
 } 
 else { 
  blk_ceiling = blks * 3; 
  for (idx = 0, idx2 = 0; idx < blk_ceiling; idx += 3, idx2 += 4) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)]; 
   out[idx2 + 2] = charset[((in[idx + 1] & 0x0f) << 2) | (in[idx + 2] >> 6)]; 
   out[idx2 + 3] = charset[in[idx + 2] & 0x3F]; 
   if (((idx2 - newline_count + 4) % 76 == 0) && newline_flag) { 
    out[idx2 + 4] = '\n'; 
    idx2++; 
    newline_count++; 
   } 
  } 
  if (left_over == 1) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[(in[idx] & 0x03) << 4]; 
   out[idx2 + 2] = '='; 
   out[idx2 + 3] = '='; 
   idx2 += 4; 
  } 
  else if (left_over == 2) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)]; 
   out[idx2 + 2] = charset[(in[idx + 1] & 0x0F) << 2]; 
   out[idx2 + 3] = '='; 
   idx2 += 4; 
  } 
 } 
 return(idx2); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0}, {""expr"": ""charset"", ""type"": ""const BYTE [1]"", ""value"": ""[0]""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}]}
{other test cases}
","{""func"": ""base64_encode"", ""file"": """", ""cases"": [{""desc"": ""Test with empty input and newline_flag set to 0"", ""inputs"": [{""expr"": ""len"", ""value"": 0}, {""expr"": ""newline_flag"", ""value"": 0}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with one byte of input and newline_flag set to 0"", ""inputs"": [{""expr"": ""in"", ""value"": ""a""}, {""expr"": ""len"", ""value"": 1}, {""expr"": ""newline_flag"", ""value"": 0}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with three bytes of input and newline_flag set to 0"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 3}, {""expr"": ""newline_flag"", ""value"": 0}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with three bytes of input and newline_flag set to 1"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 3}, {""expr"": ""newline_flag"", ""value"": 1}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with 57 bytes of input and newline_flag set to 1"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk""}, {""expr"": ""len"", ""value"": 57}, {""expr"": ""newline_flag"", ""value"": 1}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 80}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with null output buffer"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""out"", ""value"": ""null""}, {""expr"": ""len"", ""value"": 3}, {""expr"": ""newline_flag"", ""value"": 0}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with two bytes of input and newline_flag set to 0"", ""inputs"": [{""expr"": ""in"", ""value"": ""ab""}, {""expr"": ""len"", ""value"": 2}, {""expr"": ""newline_flag"", ""value"": 0}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with three bytes of input and newline_flag set to 1 with output buffer"", ""inputs"": [{""expr"": ""in"", ""value"": ""abc""}, {""expr"": ""out"", ""value"": ""AAAAAAAA""}, {""expr"": ""len"", ""value"": 3}, {""expr"": ""newline_flag"", ""value"": 1}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
base64,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
size_t base64_decode(const BYTE in[], BYTE out[], size_t len) 
{ 
 BYTE ch; 
 size_t idx, idx2, blks, blk_ceiling, left_over; 
 if (in[len - 1] == '=') 
  len--; 
 if (in[len - 1] == '=') 
  len--; 
 blks = len / 4; 
 left_over = len % 4; 
 if (out == ((void *) 0)) { 
  if (len >= 77 && in[76] == '\n') 
   len -= len / (76 + 1); 
  blks = len / 4; 
  left_over = len % 4; 
  idx = blks * 3; 
  if (left_over == 2) 
   idx ++; 
  else if (left_over == 3) 
   idx += 2; 
 } 
 else { 
  blk_ceiling = blks * 4; 
  for (idx = 0, idx2 = 0; idx2 < blk_ceiling; idx += 3, idx2 += 4) { 
   if (in[idx2] == '\n') 
    idx2++; 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   out[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2); 
   out[idx + 2] = (revchar(in[idx2 + 2]) << 6) | revchar(in[idx2 + 3]); 
  } 
  if (left_over == 2) { 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   idx++; 
  } 
  else if (left_over == 3) { 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   out[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2); 
   idx += 2; 
  } 
 } 
 return(idx); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
size_t base64_decode(const BYTE in[], BYTE out[], size_t len) 
{ 
 BYTE ch; 
 size_t idx, idx2, blks, blk_ceiling, left_over; 
 if (in[len - 1] == '=') 
  len--; 
 if (in[len - 1] == '=') 
  len--; 
 blks = len / 4; 
 left_over = len % 4; 
 if (out == ((void *) 0)) { 
  if (len >= 77 && in[76] == '\n') 
   len -= len / (76 + 1); 
  blks = len / 4; 
  left_over = len % 4; 
  idx = blks * 3; 
  if (left_over == 2) 
   idx ++; 
  else if (left_over == 3) 
   idx += 2; 
 } 
 else { 
  blk_ceiling = blks * 4; 
  for (idx = 0, idx2 = 0; idx2 < blk_ceiling; idx += 3, idx2 += 4) { 
   if (in[idx2] == '\n') 
    idx2++; 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   out[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2); 
   out[idx + 2] = (revchar(in[idx2 + 2]) << 6) | revchar(in[idx2 + 3]); 
  } 
  if (left_over == 2) { 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   idx++; 
  } 
  else if (left_over == 3) { 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   out[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2); 
   idx += 2; 
  } 
 } 
 return(idx); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}]}
{other test cases}
","{""func"": ""base64_decode"", ""file"": """", ""cases"": [{""desc"": ""Test with empty input array"", ""inputs"": [{""expr"": ""len"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length not a multiple of 4 and no padding"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJj""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 3}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 1, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 2}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length a multiple of 4 and padding"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJjPQ==""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 8}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 2, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 3}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with newline characters in input and no output buffer"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJj\\nZGVm""}, {""expr"": ""len"", ""value"": 8}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 3, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 6}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length a multiple of 4 and no padding"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJjZGVm""}, {""expr"": ""out"", ""value"": ""abcdefgh""}, {""expr"": ""len"", ""value"": 8}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 4, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 6}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length not a multiple of 4 and padding"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJjPQ==""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 7}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 5, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length exactly 4 and no padding"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJj""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 4}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 6, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 3}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length exactly 4 with padding"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJjPQ==""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 4}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 7, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 3}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length greater than 4 and no padding"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJjZGVm""}, {""expr"": ""out"", ""value"": ""abcdefgh""}, {""expr"": ""len"", ""value"": 8}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 8, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 6}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length greater than 4 with padding"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJjPQ==""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 8}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 9, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
blowfish,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
void blowfish_encrypt(const BYTE in[], BYTE out[], const BLOWFISH_KEY *keystruct) 
{ 
   WORD l,r,t; 
   l = (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]); 
   r = (in[4] << 24) | (in[5] << 16) | (in[6] << 8) | (in[7]); 
   l ^= keystruct->p[0]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[1]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[2]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[3]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[4]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[5]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[6]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[7]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[8]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[9]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[10]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[11]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[12]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[13]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[14]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[15]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; 
   r ^= keystruct->p[16]; 
   l ^= keystruct->p[17]; 
   out[0] = l >> 24; 
   out[1] = l >> 16; 
   out[2] = l >> 8; 
   out[3] = l; 
   out[4] = r >> 24; 
   out[5] = r >> 16; 
   out[6] = r >> 8; 
   out[7] = r; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
void blowfish_encrypt(const BYTE in[], BYTE out[], const BLOWFISH_KEY *keystruct) 
{ 
   WORD l,r,t; 
   l = (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]); 
   r = (in[4] << 24) | (in[5] << 16) | (in[6] << 8) | (in[7]); 
   l ^= keystruct->p[0]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[1]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[2]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[3]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[4]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[5]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[6]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[7]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[8]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[9]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[10]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[11]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[12]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[13]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[14]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[15]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; 
   r ^= keystruct->p[16]; 
   l ^= keystruct->p[17]; 
   out[0] = l >> 24; 
   out[1] = l >> 16; 
   out[2] = l >> 8; 
   out[3] = l; 
   out[4] = r >> 24; 
   out[5] = r >> 16; 
   out[6] = r >> 8; 
   out[7] = r; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""outputs"": []}
{other test cases}
","{""func"": ""blowfish_encrypt"", ""file"": """", ""cases"": [{""desc"": ""Basic test case with zero input and all keys set to zero"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 0}, {""expr"": ""in[1]"", ""value"": 0}, {""expr"": ""in[2]"", ""value"": 0}, {""expr"": ""in[3]"", ""value"": 0}, {""expr"": ""in[4]"", ""value"": 0}, {""expr"": ""in[5]"", ""value"": 0}, {""expr"": ""in[6]"", ""value"": 0}, {""expr"": ""in[7]"", ""value"": 0}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with maximum input values and all keys set to maximum"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 255}, {""expr"": ""in[1]"", ""value"": 255}, {""expr"": ""in[2]"", ""value"": 255}, {""expr"": ""in[3]"", ""value"": 255}, {""expr"": ""in[4]"", ""value"": 255}, {""expr"": ""in[5]"", ""value"": 255}, {""expr"": ""in[6]"", ""value"": 255}, {""expr"": ""in[7]"", ""value"": 255}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with alternating bits in input and random keys"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 170}, {""expr"": ""in[1]"", ""value"": 85}, {""expr"": ""in[2]"", ""value"": 170}, {""expr"": ""in[3]"", ""value"": 85}, {""expr"": ""in[4]"", ""value"": 170}, {""expr"": ""in[5]"", ""value"": 85}, {""expr"": ""in[6]"", ""value"": 170}, {""expr"": ""in[7]"", ""value"": 85}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with all ones in input and sequential keys"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 255}, {""expr"": ""in[1]"", ""value"": 255}, {""expr"": ""in[2]"", ""value"": 255}, {""expr"": ""in[3]"", ""value"": 255}, {""expr"": ""in[4]"", ""value"": 255}, {""expr"": ""in[5]"", ""value"": 255}, {""expr"": ""in[6]"", ""value"": 255}, {""expr"": ""in[7]"", ""value"": 255}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with random input and keys"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 123}, {""expr"": ""in[1]"", ""value"": 234}, {""expr"": ""in[2]"", ""value"": 56}, {""expr"": ""in[3]"", ""value"": 78}, {""expr"": ""in[4]"", ""value"": 90}, {""expr"": ""in[5]"", ""value"": 12}, {""expr"": ""in[6]"", ""value"": 34}, {""expr"": ""in[7]"", ""value"": 56}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""keystruct"", ""userVar"": ""keystruct_PTRTO""}], ""ios"": []}"
blowfish,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
void blowfish_decrypt(const BYTE in[], BYTE out[], const BLOWFISH_KEY *keystruct) 
{ 
   WORD l,r,t; 
   l = (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]); 
   r = (in[4] << 24) | (in[5] << 16) | (in[6] << 8) | (in[7]); 
   l ^= keystruct->p[17]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[16]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[15]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[14]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[13]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[12]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[11]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[10]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[9]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[8]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[7]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[6]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[5]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[4]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[3]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[2]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; 
   r ^= keystruct->p[1]; 
   l ^= keystruct->p[0]; 
   out[0] = l >> 24; 
   out[1] = l >> 16; 
   out[2] = l >> 8; 
   out[3] = l; 
   out[4] = r >> 24; 
   out[5] = r >> 16; 
   out[6] = r >> 8; 
   out[7] = r; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
void blowfish_decrypt(const BYTE in[], BYTE out[], const BLOWFISH_KEY *keystruct) 
{ 
   WORD l,r,t; 
   l = (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]); 
   r = (in[4] << 24) | (in[5] << 16) | (in[6] << 8) | (in[7]); 
   l ^= keystruct->p[17]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[16]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[15]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[14]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[13]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[12]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[11]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[10]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[9]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[8]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[7]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[6]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[5]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[4]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[3]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; t = l; l = r; r = t;;; 
   l ^= keystruct->p[2]; t = keystruct->s[0][(l) >> 24]; t += keystruct->s[1][((l) >> 16) & 0xff]; t ^= keystruct->s[2][((l) >> 8) & 0xff]; t += keystruct->s[3][(l) & 0xff];; r^= t; 
   r ^= keystruct->p[1]; 
   l ^= keystruct->p[0]; 
   out[0] = l >> 24; 
   out[1] = l >> 16; 
   out[2] = l >> 8; 
   out[3] = l; 
   out[4] = r >> 24; 
   out[5] = r >> 16; 
   out[6] = r >> 8; 
   out[7] = r; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""outputs"": []}
{other test cases}
","{""func"": ""blowfish_decrypt"", ""file"": """", ""cases"": [{""desc"": ""Basic decryption with a simple key structure"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 0}, {""expr"": ""in[1]"", ""value"": 0}, {""expr"": ""in[2]"", ""value"": 0}, {""expr"": ""in[3]"", ""value"": 1}, {""expr"": ""in[4]"", ""value"": 0}, {""expr"": ""in[5]"", ""value"": 0}, {""expr"": ""in[6]"", ""value"": 0}, {""expr"": ""in[7]"", ""value"": 2}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""(keystruct_PTRTO[0]).p[0]"", ""value"": 0}, {""expr"": ""(keystruct_PTRTO[0]).p[1]"", ""value"": 1}, {""expr"": ""(keystruct_PTRTO[0]).p[2]"", ""value"": 2}, {""expr"": ""(keystruct_PTRTO[0]).p[3]"", ""value"": 3}, {""expr"": ""(keystruct_PTRTO[0]).p[4]"", ""value"": 4}, {""expr"": ""(keystruct_PTRTO[0]).p[5]"", ""value"": 5}, {""expr"": ""(keystruct_PTRTO[0]).p[6]"", ""value"": 6}, {""expr"": ""(keystruct_PTRTO[0]).p[7]"", ""value"": 7}, {""expr"": ""(keystruct_PTRTO[0]).p[8]"", ""value"": 8}, {""expr"": ""(keystruct_PTRTO[0]).p[9]"", ""value"": 9}, {""expr"": ""(keystruct_PTRTO[0]).p[10]"", ""value"": 10}, {""expr"": ""(keystruct_PTRTO[0]).p[11]"", ""value"": 11}, {""expr"": ""(keystruct_PTRTO[0]).p[12]"", ""value"": 12}, {""expr"": ""(keystruct_PTRTO[0]).p[13]"", ""value"": 13}, {""expr"": ""(keystruct_PTRTO[0]).p[14]"", ""value"": 14}, {""expr"": ""(keystruct_PTRTO[0]).p[15]"", ""value"": 15}, {""expr"": ""(keystruct_PTRTO[0]).p[16]"", ""value"": 16}, {""expr"": ""(keystruct_PTRTO[0]).p[17]"", ""value"": 17}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""All zeros input"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 0}, {""expr"": ""in[1]"", ""value"": 0}, {""expr"": ""in[2]"", ""value"": 0}, {""expr"": ""in[3]"", ""value"": 0}, {""expr"": ""in[4]"", ""value"": 0}, {""expr"": ""in[5]"", ""value"": 0}, {""expr"": ""in[6]"", ""value"": 0}, {""expr"": ""in[7]"", ""value"": 0}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""(keystruct_PTRTO[0]).p[0]"", ""value"": 0}, {""expr"": ""(keystruct_PTRTO[0]).p[1]"", ""value"": 1}, {""expr"": ""(keystruct_PTRTO[0]).p[2]"", ""value"": 2}, {""expr"": ""(keystruct_PTRTO[0]).p[3]"", ""value"": 3}, {""expr"": ""(keystruct_PTRTO[0]).p[4]"", ""value"": 4}, {""expr"": ""(keystruct_PTRTO[0]).p[5]"", ""value"": 5}, {""expr"": ""(keystruct_PTRTO[0]).p[6]"", ""value"": 6}, {""expr"": ""(keystruct_PTRTO[0]).p[7]"", ""value"": 7}, {""expr"": ""(keystruct_PTRTO[0]).p[8]"", ""value"": 8}, {""expr"": ""(keystruct_PTRTO[0]).p[9]"", ""value"": 9}, {""expr"": ""(keystruct_PTRTO[0]).p[10]"", ""value"": 10}, {""expr"": ""(keystruct_PTRTO[0]).p[11]"", ""value"": 11}, {""expr"": ""(keystruct_PTRTO[0]).p[12]"", ""value"": 12}, {""expr"": ""(keystruct_PTRTO[0]).p[13]"", ""value"": 13}, {""expr"": ""(keystruct_PTRTO[0]).p[14]"", ""value"": 14}, {""expr"": ""(keystruct_PTRTO[0]).p[15]"", ""value"": 15}, {""expr"": ""(keystruct_PTRTO[0]).p[16]"", ""value"": 16}, {""expr"": ""(keystruct_PTRTO[0]).p[17]"", ""value"": 17}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Random input values"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 255}, {""expr"": ""in[1]"", ""value"": 254}, {""expr"": ""in[2]"", ""value"": 253}, {""expr"": ""in[3]"", ""value"": 252}, {""expr"": ""in[4]"", ""value"": 251}, {""expr"": ""in[5]"", ""value"": 250}, {""expr"": ""in[6]"", ""value"": 249}, {""expr"": ""in[7]"", ""value"": 248}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""(keystruct_PTRTO[0]).p[0]"", ""value"": 0}, {""expr"": ""(keystruct_PTRTO[0]).p[1]"", ""value"": 1}, {""expr"": ""(keystruct_PTRTO[0]).p[2]"", ""value"": 2}, {""expr"": ""(keystruct_PTRTO[0]).p[3]"", ""value"": 3}, {""expr"": ""(keystruct_PTRTO[0]).p[4]"", ""value"": 4}, {""expr"": ""(keystruct_PTRTO[0]).p[5]"", ""value"": 5}, {""expr"": ""(keystruct_PTRTO[0]).p[6]"", ""value"": 6}, {""expr"": ""(keystruct_PTRTO[0]).p[7]"", ""value"": 7}, {""expr"": ""(keystruct_PTRTO[0]).p[8]"", ""value"": 8}, {""expr"": ""(keystruct_PTRTO[0]).p[9]"", ""value"": 9}, {""expr"": ""(keystruct_PTRTO[0]).p[10]"", ""value"": 10}, {""expr"": ""(keystruct_PTRTO[0]).p[11]"", ""value"": 11}, {""expr"": ""(keystruct_PTRTO[0]).p[12]"", ""value"": 12}, {""expr"": ""(keystruct_PTRTO[0]).p[13]"", ""value"": 13}, {""expr"": ""(keystruct_PTRTO[0]).p[14]"", ""value"": 14}, {""expr"": ""(keystruct_PTRTO[0]).p[15]"", ""value"": 15}, {""expr"": ""(keystruct_PTRTO[0]).p[16]"", ""value"": 16}, {""expr"": ""(keystruct_PTRTO[0]).p[17]"", ""value"": 17}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Boundary values for input"", ""inputs"": [{""expr"": ""in[0]"", ""value"": 0}, {""expr"": ""in[1]"", ""value"": 0}, {""expr"": ""in[2]"", ""value"": 0}, {""expr"": ""in[3]"", ""value"": 127}, {""expr"": ""in[4]"", ""value"": 0}, {""expr"": ""in[5]"", ""value"": 0}, {""expr"": ""in[6]"", ""value"": 0}, {""expr"": ""in[7]"", ""value"": 128}, {""expr"": ""out[0]"", ""value"": 0}, {""expr"": ""out[1]"", ""value"": 0}, {""expr"": ""out[2]"", ""value"": 0}, {""expr"": ""out[3]"", ""value"": 0}, {""expr"": ""out[4]"", ""value"": 0}, {""expr"": ""out[5]"", ""value"": 0}, {""expr"": ""out[6]"", ""value"": 0}, {""expr"": ""out[7]"", ""value"": 0}, {""expr"": ""(keystruct_PTRTO[0]).p[0]"", ""value"": 0}, {""expr"": ""(keystruct_PTRTO[0]).p[1]"", ""value"": 1}, {""expr"": ""(keystruct_PTRTO[0]).p[2]"", ""value"": 2}, {""expr"": ""(keystruct_PTRTO[0]).p[3]"", ""value"": 3}, {""expr"": ""(keystruct_PTRTO[0]).p[4]"", ""value"": 4}, {""expr"": ""(keystruct_PTRTO[0]).p[5]"", ""value"": 5}, {""expr"": ""(keystruct_PTRTO[0]).p[6]"", ""value"": 6}, {""expr"": ""(keystruct_PTRTO[0]).p[7]"", ""value"": 7}, {""expr"": ""(keystruct_PTRTO[0]).p[8]"", ""value"": 8}, {""expr"": ""(keystruct_PTRTO[0]).p[9]"", ""value"": 9}, {""expr"": ""(keystruct_PTRTO[0]).p[10]"", ""value"": 10}, {""expr"": ""(keystruct_PTRTO[0]).p[11]"", ""value"": 11}, {""expr"": ""(keystruct_PTRTO[0]).p[12]"", ""value"": 12}, {""expr"": ""(keystruct_PTRTO[0]).p[13]"", ""value"": 13}, {""expr"": ""(keystruct_PTRTO[0]).p[14]"", ""value"": 14}, {""expr"": ""(keystruct_PTRTO[0]).p[15]"", ""value"": 15}, {""expr"": ""(keystruct_PTRTO[0]).p[16]"", ""value"": 16}, {""expr"": ""(keystruct_PTRTO[0]).p[17]"", ""value"": 17}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""keystruct"", ""userVar"": ""keystruct_PTRTO""}], ""ios"": []}"
blowfish,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
FISH_KEY; 
static const WORD p_perm[18] 
static const WORD s_perm[4][256] 
void blowfish_key_setup(const BYTE user_key[], BLOWFISH_KEY *keystruct, size_t len) 
{ 
   BYTE block[8]; 
   int idx,idx2; 
   memcpy(keystruct->p,p_perm,sizeof(WORD) * 18); 
   memcpy(keystruct->s,s_perm,sizeof(WORD) * 1024); 
   for (idx = 0, idx2 = 0; idx < 18; ++idx, idx2 += 4) 
      keystruct->p[idx] ^= (user_key[idx2 % len] << 24) | (user_key[(idx2+1) % len] << 16) 
                           | (user_key[(idx2+2) % len] << 8) | (user_key[(idx2+3) % len]); 
   memset(block, 0, 8); 
   for (idx = 0; idx < 18; idx += 2) { 
      blowfish_encrypt(block,block,keystruct); 
      keystruct->p[idx] = (block[0] << 24) | (block[1] << 16) | (block[2] << 8) | block[3]; 
      keystruct->p[idx+1]=(block[4] << 24) | (block[5] << 16) | (block[6] << 8) | block[7]; 
   } 
   for (idx = 0; idx < 4; ++idx) { 
      for (idx2 = 0; idx2 < 256; idx2 += 2) { 
         blowfish_encrypt(block,block,keystruct); 
         keystruct->s[idx][idx2] = (block[0] << 24) | (block[1] << 16) | 
                                   (block[2] << 8) | block[3]; 
         keystruct->s[idx][idx2+1] = (block[4] << 24) | (block[5] << 16) | 
                                     (block[6] << 8) | block[7]; 
      } 
   } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""user_key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""s_perm"", ""type"": ""const WORD [4][256]"", ""value"": ""[0]""}, {""expr"": ""p_perm"", ""type"": ""const WORD [18]"", ""value"": ""[0]""}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void blowfish_encrypt(const BYTE *in,BYTE *out,const BLOWFISH_KEY *keystruct)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""keystruct->p"", ""type"": ""WORD [18]"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
FISH_KEY; 
static const WORD p_perm[18] 
static const WORD s_perm[4][256] 
void blowfish_key_setup(const BYTE user_key[], BLOWFISH_KEY *keystruct, size_t len) 
{ 
   BYTE block[8]; 
   int idx,idx2; 
   memcpy(keystruct->p,p_perm,sizeof(WORD) * 18); 
   memcpy(keystruct->s,s_perm,sizeof(WORD) * 1024); 
   for (idx = 0, idx2 = 0; idx < 18; ++idx, idx2 += 4) 
      keystruct->p[idx] ^= (user_key[idx2 % len] << 24) | (user_key[(idx2+1) % len] << 16) 
                           | (user_key[(idx2+2) % len] << 8) | (user_key[(idx2+3) % len]); 
   memset(block, 0, 8); 
   for (idx = 0; idx < 18; idx += 2) { 
      blowfish_encrypt(block,block,keystruct); 
      keystruct->p[idx] = (block[0] << 24) | (block[1] << 16) | (block[2] << 8) | block[3]; 
      keystruct->p[idx+1]=(block[4] << 24) | (block[5] << 16) | (block[6] << 8) | block[7]; 
   } 
   for (idx = 0; idx < 4; ++idx) { 
      for (idx2 = 0; idx2 < 256; idx2 += 2) { 
         blowfish_encrypt(block,block,keystruct); 
         keystruct->s[idx][idx2] = (block[0] << 24) | (block[1] << 16) | 
                                   (block[2] << 8) | block[3]; 
         keystruct->s[idx][idx2+1] = (block[4] << 24) | (block[5] << 16) | 
                                     (block[6] << 8) | block[7]; 
      } 
   } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""user_key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""s_perm"", ""type"": ""const WORD [4][256]"", ""value"": ""[0]""}, {""expr"": ""p_perm"", ""type"": ""const WORD [18]"", ""value"": ""[0]""}], ""stubins"": [{""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}, {""called function"": ""void blowfish_encrypt(const BYTE *in,BYTE *out,const BLOWFISH_KEY *keystruct)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""keystruct->p"", ""type"": ""WORD [18]"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""blowfish_key_setup"", ""file"": """", ""cases"": [{""desc"": ""Test with user_key length 0"", ""inputs"": [{""expr"": ""user_key"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 0}, {""expr"": ""s_perm"", ""value"": ""[0]""}, {""expr"": ""p_perm"", ""value"": ""[0]""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""keystruct->p"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with user_key length 4"", ""inputs"": [{""expr"": ""user_key"", ""value"": ""abcd""}, {""expr"": ""len"", ""value"": 4}, {""expr"": ""s_perm"", ""value"": ""[0]""}, {""expr"": ""p_perm"", ""value"": ""[0]""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""keystruct->p"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with user_key length 8"", ""inputs"": [{""expr"": ""user_key"", ""value"": ""abcdefgh""}, {""expr"": ""len"", ""value"": 8}, {""expr"": ""s_perm"", ""value"": ""[0]""}, {""expr"": ""p_perm"", ""value"": ""[0]""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""keystruct->p"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with user_key length 16"", ""inputs"": [{""expr"": ""user_key"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""len"", ""value"": 16}, {""expr"": ""s_perm"", ""value"": ""[0]""}, {""expr"": ""p_perm"", ""value"": ""[0]""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""keystruct->p"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with user_key length 32"", ""inputs"": [{""expr"": ""user_key"", ""value"": ""abcdefghijklmnopqrstuvwxyz123456""}, {""expr"": ""len"", ""value"": 32}, {""expr"": ""s_perm"", ""value"": ""[0]""}, {""expr"": ""p_perm"", ""value"": ""[0]""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": 0, ""funcName"": ""memcpy""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""*out"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""keystruct->p"", ""value"": 0, ""funcName"": ""blowfish_encrypt""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""keystruct"", ""userVar"": ""keystruct_PTRTO""}], ""ios"": []}"
des,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
void IP(WORD state[], const BYTE in[]) 
{ 
 state[0] = (((in[(57)/8] >> (7 - (57%8))) & 0x01) << (31)) | (((in[(49)/8] >> (7 - (49%8))) & 0x01) << (30)) | (((in[(41)/8] >> (7 - (41%8))) & 0x01) << (29)) | (((in[(33)/8] >> (7 - (33%8))) & 0x01) << (28)) | 
      (((in[(25)/8] >> (7 - (25%8))) & 0x01) << (27)) | (((in[(17)/8] >> (7 - (17%8))) & 0x01) << (26)) | (((in[(9)/8] >> (7 - (9%8))) & 0x01) << (25)) | (((in[(1)/8] >> (7 - (1%8))) & 0x01) << (24)) | 
      (((in[(59)/8] >> (7 - (59%8))) & 0x01) << (23)) | (((in[(51)/8] >> (7 - (51%8))) & 0x01) << (22)) | (((in[(43)/8] >> (7 - (43%8))) & 0x01) << (21)) | (((in[(35)/8] >> (7 - (35%8))) & 0x01) << (20)) | 
      (((in[(27)/8] >> (7 - (27%8))) & 0x01) << (19)) | (((in[(19)/8] >> (7 - (19%8))) & 0x01) << (18)) | (((in[(11)/8] >> (7 - (11%8))) & 0x01) << (17)) | (((in[(3)/8] >> (7 - (3%8))) & 0x01) << (16)) | 
      (((in[(61)/8] >> (7 - (61%8))) & 0x01) << (15)) | (((in[(53)/8] >> (7 - (53%8))) & 0x01) << (14)) | (((in[(45)/8] >> (7 - (45%8))) & 0x01) << (13)) | (((in[(37)/8] >> (7 - (37%8))) & 0x01) << (12)) | 
      (((in[(29)/8] >> (7 - (29%8))) & 0x01) << (11)) | (((in[(21)/8] >> (7 - (21%8))) & 0x01) << (10)) | (((in[(13)/8] >> (7 - (13%8))) & 0x01) << (9)) | (((in[(5)/8] >> (7 - (5%8))) & 0x01) << (8)) | 
      (((in[(63)/8] >> (7 - (63%8))) & 0x01) << (7)) | (((in[(55)/8] >> (7 - (55%8))) & 0x01) << (6)) | (((in[(47)/8] >> (7 - (47%8))) & 0x01) << (5)) | (((in[(39)/8] >> (7 - (39%8))) & 0x01) << (4)) | 
      (((in[(31)/8] >> (7 - (31%8))) & 0x01) << (3)) | (((in[(23)/8] >> (7 - (23%8))) & 0x01) << (2)) | (((in[(15)/8] >> (7 - (15%8))) & 0x01) << (1)) | (((in[(7)/8] >> (7 - (7%8))) & 0x01) << (0)); 
 state[1] = (((in[(56)/8] >> (7 - (56%8))) & 0x01) << (31)) | (((in[(48)/8] >> (7 - (48%8))) & 0x01) << (30)) | (((in[(40)/8] >> (7 - (40%8))) & 0x01) << (29)) | (((in[(32)/8] >> (7 - (32%8))) & 0x01) << (28)) | 
      (((in[(24)/8] >> (7 - (24%8))) & 0x01) << (27)) | (((in[(16)/8] >> (7 - (16%8))) & 0x01) << (26)) | (((in[(8)/8] >> (7 - (8%8))) & 0x01) << (25)) | (((in[(0)/8] >> (7 - (0%8))) & 0x01) << (24)) | 
      (((in[(58)/8] >> (7 - (58%8))) & 0x01) << (23)) | (((in[(50)/8] >> (7 - (50%8))) & 0x01) << (22)) | (((in[(42)/8] >> (7 - (42%8))) & 0x01) << (21)) | (((in[(34)/8] >> (7 - (34%8))) & 0x01) << (20)) | 
      (((in[(26)/8] >> (7 - (26%8))) & 0x01) << (19)) | (((in[(18)/8] >> (7 - (18%8))) & 0x01) << (18)) | (((in[(10)/8] >> (7 - (10%8))) & 0x01) << (17)) | (((in[(2)/8] >> (7 - (2%8))) & 0x01) << (16)) | 
      (((in[(60)/8] >> (7 - (60%8))) & 0x01) << (15)) | (((in[(52)/8] >> (7 - (52%8))) & 0x01) << (14)) | (((in[(44)/8] >> (7 - (44%8))) & 0x01) << (13)) | (((in[(36)/8] >> (7 - (36%8))) & 0x01) << (12)) | 
      (((in[(28)/8] >> (7 - (28%8))) & 0x01) << (11)) | (((in[(20)/8] >> (7 - (20%8))) & 0x01) << (10)) | (((in[(12)/8] >> (7 - (12%8))) & 0x01) << (9)) | (((in[(4)/8] >> (7 - (4%8))) & 0x01) << (8)) | 
      (((in[(62)/8] >> (7 - (62%8))) & 0x01) << (7)) | (((in[(54)/8] >> (7 - (54%8))) & 0x01) << (6)) | (((in[(46)/8] >> (7 - (46%8))) & 0x01) << (5)) | (((in[(38)/8] >> (7 - (38%8))) & 0x01) << (4)) | 
      (((in[(30)/8] >> (7 - (30%8))) & 0x01) << (3)) | (((in[(22)/8] >> (7 - (22%8))) & 0x01) << (2)) | (((in[(14)/8] >> (7 - (14%8))) & 0x01) << (1)) | (((in[(6)/8] >> (7 - (6%8))) & 0x01) << (0)); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""state[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""state[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
void IP(WORD state[], const BYTE in[]) 
{ 
 state[0] = (((in[(57)/8] >> (7 - (57%8))) & 0x01) << (31)) | (((in[(49)/8] >> (7 - (49%8))) & 0x01) << (30)) | (((in[(41)/8] >> (7 - (41%8))) & 0x01) << (29)) | (((in[(33)/8] >> (7 - (33%8))) & 0x01) << (28)) | 
      (((in[(25)/8] >> (7 - (25%8))) & 0x01) << (27)) | (((in[(17)/8] >> (7 - (17%8))) & 0x01) << (26)) | (((in[(9)/8] >> (7 - (9%8))) & 0x01) << (25)) | (((in[(1)/8] >> (7 - (1%8))) & 0x01) << (24)) | 
      (((in[(59)/8] >> (7 - (59%8))) & 0x01) << (23)) | (((in[(51)/8] >> (7 - (51%8))) & 0x01) << (22)) | (((in[(43)/8] >> (7 - (43%8))) & 0x01) << (21)) | (((in[(35)/8] >> (7 - (35%8))) & 0x01) << (20)) | 
      (((in[(27)/8] >> (7 - (27%8))) & 0x01) << (19)) | (((in[(19)/8] >> (7 - (19%8))) & 0x01) << (18)) | (((in[(11)/8] >> (7 - (11%8))) & 0x01) << (17)) | (((in[(3)/8] >> (7 - (3%8))) & 0x01) << (16)) | 
      (((in[(61)/8] >> (7 - (61%8))) & 0x01) << (15)) | (((in[(53)/8] >> (7 - (53%8))) & 0x01) << (14)) | (((in[(45)/8] >> (7 - (45%8))) & 0x01) << (13)) | (((in[(37)/8] >> (7 - (37%8))) & 0x01) << (12)) | 
      (((in[(29)/8] >> (7 - (29%8))) & 0x01) << (11)) | (((in[(21)/8] >> (7 - (21%8))) & 0x01) << (10)) | (((in[(13)/8] >> (7 - (13%8))) & 0x01) << (9)) | (((in[(5)/8] >> (7 - (5%8))) & 0x01) << (8)) | 
      (((in[(63)/8] >> (7 - (63%8))) & 0x01) << (7)) | (((in[(55)/8] >> (7 - (55%8))) & 0x01) << (6)) | (((in[(47)/8] >> (7 - (47%8))) & 0x01) << (5)) | (((in[(39)/8] >> (7 - (39%8))) & 0x01) << (4)) | 
      (((in[(31)/8] >> (7 - (31%8))) & 0x01) << (3)) | (((in[(23)/8] >> (7 - (23%8))) & 0x01) << (2)) | (((in[(15)/8] >> (7 - (15%8))) & 0x01) << (1)) | (((in[(7)/8] >> (7 - (7%8))) & 0x01) << (0)); 
 state[1] = (((in[(56)/8] >> (7 - (56%8))) & 0x01) << (31)) | (((in[(48)/8] >> (7 - (48%8))) & 0x01) << (30)) | (((in[(40)/8] >> (7 - (40%8))) & 0x01) << (29)) | (((in[(32)/8] >> (7 - (32%8))) & 0x01) << (28)) | 
      (((in[(24)/8] >> (7 - (24%8))) & 0x01) << (27)) | (((in[(16)/8] >> (7 - (16%8))) & 0x01) << (26)) | (((in[(8)/8] >> (7 - (8%8))) & 0x01) << (25)) | (((in[(0)/8] >> (7 - (0%8))) & 0x01) << (24)) | 
      (((in[(58)/8] >> (7 - (58%8))) & 0x01) << (23)) | (((in[(50)/8] >> (7 - (50%8))) & 0x01) << (22)) | (((in[(42)/8] >> (7 - (42%8))) & 0x01) << (21)) | (((in[(34)/8] >> (7 - (34%8))) & 0x01) << (20)) | 
      (((in[(26)/8] >> (7 - (26%8))) & 0x01) << (19)) | (((in[(18)/8] >> (7 - (18%8))) & 0x01) << (18)) | (((in[(10)/8] >> (7 - (10%8))) & 0x01) << (17)) | (((in[(2)/8] >> (7 - (2%8))) & 0x01) << (16)) | 
      (((in[(60)/8] >> (7 - (60%8))) & 0x01) << (15)) | (((in[(52)/8] >> (7 - (52%8))) & 0x01) << (14)) | (((in[(44)/8] >> (7 - (44%8))) & 0x01) << (13)) | (((in[(36)/8] >> (7 - (36%8))) & 0x01) << (12)) | 
      (((in[(28)/8] >> (7 - (28%8))) & 0x01) << (11)) | (((in[(20)/8] >> (7 - (20%8))) & 0x01) << (10)) | (((in[(12)/8] >> (7 - (12%8))) & 0x01) << (9)) | (((in[(4)/8] >> (7 - (4%8))) & 0x01) << (8)) | 
      (((in[(62)/8] >> (7 - (62%8))) & 0x01) << (7)) | (((in[(54)/8] >> (7 - (54%8))) & 0x01) << (6)) | (((in[(46)/8] >> (7 - (46%8))) & 0x01) << (5)) | (((in[(38)/8] >> (7 - (38%8))) & 0x01) << (4)) | 
      (((in[(30)/8] >> (7 - (30%8))) & 0x01) << (3)) | (((in[(22)/8] >> (7 - (22%8))) & 0x01) << (2)) | (((in[(14)/8] >> (7 - (14%8))) & 0x01) << (1)) | (((in[(6)/8] >> (7 - (6%8))) & 0x01) << (0)); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""state[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""state[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""outputs"": []}
{other test cases}
","{""func"": ""IP"", ""file"": """", ""cases"": [{""desc"": ""Test case with all bits set to 0 in input array"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 0}, {""expr"": ""state_PTRTO[1]"", ""value"": 0}, {""expr"": ""in[0]"", ""value"": 0}, {""expr"": ""in[1]"", ""value"": 0}, {""expr"": ""in[2]"", ""value"": 0}, {""expr"": ""in[3]"", ""value"": 0}, {""expr"": ""in[4]"", ""value"": 0}, {""expr"": ""in[5]"", ""value"": 0}, {""expr"": ""in[6]"", ""value"": 0}, {""expr"": ""in[7]"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""state[0]"", ""value"": 0}, {""expr"": ""state[1]"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with all bits set to 1 in input array"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 0}, {""expr"": ""state_PTRTO[1]"", ""value"": 0}, {""expr"": ""in[0]"", ""value"": 255}, {""expr"": ""in[1]"", ""value"": 255}, {""expr"": ""in[2]"", ""value"": 255}, {""expr"": ""in[3]"", ""value"": 255}, {""expr"": ""in[4]"", ""value"": 255}, {""expr"": ""in[5]"", ""value"": 255}, {""expr"": ""in[6]"", ""value"": 255}, {""expr"": ""in[7]"", ""value"": 255}], ""stubins"": [], ""outputs"": [{""expr"": ""state[0]"", ""value"": 4294967295}, {""expr"": ""state[1]"", ""value"": 4294967295}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with alternating bits in input array"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 0}, {""expr"": ""state_PTRTO[1]"", ""value"": 0}, {""expr"": ""in[0]"", ""value"": 170}, {""expr"": ""in[1]"", ""value"": 85}, {""expr"": ""in[2]"", ""value"": 170}, {""expr"": ""in[3]"", ""value"": 85}, {""expr"": ""in[4]"", ""value"": 170}, {""expr"": ""in[5]"", ""value"": 85}, {""expr"": ""in[6]"", ""value"": 170}, {""expr"": ""in[7]"", ""value"": 85}], ""stubins"": [], ""outputs"": [{""expr"": ""state[0]"", ""value"": 2863311530}, {""expr"": ""state[1]"", ""value"": 2863311530}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with first half bits set to 1 and second half bits set to 0 in input array"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 0}, {""expr"": ""state_PTRTO[1]"", ""value"": 0}, {""expr"": ""in[0]"", ""value"": 255}, {""expr"": ""in[1]"", ""value"": 255}, {""expr"": ""in[2]"", ""value"": 255}, {""expr"": ""in[3]"", ""value"": 255}, {""expr"": ""in[4]"", ""value"": 0}, {""expr"": ""in[5]"", ""value"": 0}, {""expr"": ""in[6]"", ""value"": 0}, {""expr"": ""in[7]"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""state[0]"", ""value"": 4294967295}, {""expr"": ""state[1]"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with first half bits set to 0 and second half bits set to 1 in input array"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 0}, {""expr"": ""state_PTRTO[1]"", ""value"": 0}, {""expr"": ""in[0]"", ""value"": 0}, {""expr"": ""in[1]"", ""value"": 0}, {""expr"": ""in[2]"", ""value"": 0}, {""expr"": ""in[3]"", ""value"": 0}, {""expr"": ""in[4]"", ""value"": 255}, {""expr"": ""in[5]"", ""value"": 255}, {""expr"": ""in[6]"", ""value"": 255}, {""expr"": ""in[7]"", ""value"": 255}], ""stubins"": [], ""outputs"": [{""expr"": ""state[0]"", ""value"": 0}, {""expr"": ""state[1]"", ""value"": 4294967295}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with alternating bytes in input array"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 0}, {""expr"": ""state_PTRTO[1]"", ""value"": 0}, {""expr"": ""in[0]"", ""value"": 170}, {""expr"": ""in[1]"", ""value"": 170}, {""expr"": ""in[2]"", ""value"": 170}, {""expr"": ""in[3]"", ""value"": 170}, {""expr"": ""in[4]"", ""value"": 85}, {""expr"": ""in[5]"", ""value"": 85}, {""expr"": ""in[6]"", ""value"": 85}, {""expr"": ""in[7]"", ""value"": 85}], ""stubins"": [], ""outputs"": [{""expr"": ""state[0]"", ""value"": 2863311530}, {""expr"": ""state[1]"", ""value"": 1431655765}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""state"", ""userVar"": ""state_PTRTO""}], ""ios"": []}"
des,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
void InvIP(WORD state[], BYTE in[]) 
{ 
 in[0] = ((((state[1]) >> (31 - (7))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (7))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (15))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (15))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (23))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (23))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (31))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (31))) & 0x00000001) << (0)); 
 in[1] = ((((state[1]) >> (31 - (6))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (6))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (14))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (14))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (22))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (22))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (30))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (30))) & 0x00000001) << (0)); 
 in[2] = ((((state[1]) >> (31 - (5))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (5))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (13))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (13))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (21))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (21))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (29))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (29))) & 0x00000001) << (0)); 
 in[3] = ((((state[1]) >> (31 - (4))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (4))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (12))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (12))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (20))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (20))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (28))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (28))) & 0x00000001) << (0)); 
 in[4] = ((((state[1]) >> (31 - (3))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (3))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (11))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (11))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (19))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (19))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (27))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (27))) & 0x00000001) << (0)); 
 in[5] = ((((state[1]) >> (31 - (2))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (2))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (10))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (10))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (18))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (18))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (26))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (26))) & 0x00000001) << (0)); 
 in[6] = ((((state[1]) >> (31 - (1))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (1))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (9))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (9))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (17))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (17))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (25))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (25))) & 0x00000001) << (0)); 
 in[7] = ((((state[1]) >> (31 - (0))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (0))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (8))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (8))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (16))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (16))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (24))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (24))) & 0x00000001) << (0)); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""state[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""state[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""in"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
void InvIP(WORD state[], BYTE in[]) 
{ 
 in[0] = ((((state[1]) >> (31 - (7))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (7))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (15))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (15))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (23))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (23))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (31))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (31))) & 0x00000001) << (0)); 
 in[1] = ((((state[1]) >> (31 - (6))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (6))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (14))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (14))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (22))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (22))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (30))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (30))) & 0x00000001) << (0)); 
 in[2] = ((((state[1]) >> (31 - (5))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (5))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (13))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (13))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (21))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (21))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (29))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (29))) & 0x00000001) << (0)); 
 in[3] = ((((state[1]) >> (31 - (4))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (4))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (12))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (12))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (20))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (20))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (28))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (28))) & 0x00000001) << (0)); 
 in[4] = ((((state[1]) >> (31 - (3))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (3))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (11))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (11))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (19))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (19))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (27))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (27))) & 0x00000001) << (0)); 
 in[5] = ((((state[1]) >> (31 - (2))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (2))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (10))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (10))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (18))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (18))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (26))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (26))) & 0x00000001) << (0)); 
 in[6] = ((((state[1]) >> (31 - (1))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (1))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (9))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (9))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (17))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (17))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (25))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (25))) & 0x00000001) << (0)); 
 in[7] = ((((state[1]) >> (31 - (0))) & 0x00000001) << (7)) | ((((state[0]) >> (31 - (0))) & 0x00000001) << (6)) | ((((state[1]) >> (31 - (8))) & 0x00000001) << (5)) | 
     ((((state[0]) >> (31 - (8))) & 0x00000001) << (4)) | ((((state[1]) >> (31 - (16))) & 0x00000001) << (3)) | ((((state[0]) >> (31 - (16))) & 0x00000001) << (2)) | 
     ((((state[1]) >> (31 - (24))) & 0x00000001) << (1)) | ((((state[0]) >> (31 - (24))) & 0x00000001) << (0)); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""state[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""state[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""in"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""outputs"": []}
{other test cases}
","{""func"": ""InvIP"", ""file"": """", ""cases"": [{""desc"": ""All bits in state[0] and state[1] are 0"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 0}, {""expr"": ""state_PTRTO[1]"", ""value"": 0}, {""expr"": ""in"", ""value"": ""00000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""in[0]"", ""value"": 0}, {""expr"": ""in[1]"", ""value"": 0}, {""expr"": ""in[2]"", ""value"": 0}, {""expr"": ""in[3]"", ""value"": 0}, {""expr"": ""in[4]"", ""value"": 0}, {""expr"": ""in[5]"", ""value"": 0}, {""expr"": ""in[6]"", ""value"": 0}, {""expr"": ""in[7]"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""All bits in state[0] and state[1] are 1"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 4294967295}, {""expr"": ""state_PTRTO[1]"", ""value"": 4294967295}, {""expr"": ""in"", ""value"": ""00000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""in[0]"", ""value"": 255}, {""expr"": ""in[1]"", ""value"": 255}, {""expr"": ""in[2]"", ""value"": 255}, {""expr"": ""in[3]"", ""value"": 255}, {""expr"": ""in[4]"", ""value"": 255}, {""expr"": ""in[5]"", ""value"": 255}, {""expr"": ""in[6]"", ""value"": 255}, {""expr"": ""in[7]"", ""value"": 255}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Alternating bits in state[0] and state[1]"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 2863311530}, {""expr"": ""state_PTRTO[1]"", ""value"": 1431655765}, {""expr"": ""in"", ""value"": ""00000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""in[0]"", ""value"": 170}, {""expr"": ""in[1]"", ""value"": 170}, {""expr"": ""in[2]"", ""value"": 170}, {""expr"": ""in[3]"", ""value"": 170}, {""expr"": ""in[4]"", ""value"": 170}, {""expr"": ""in[5]"", ""value"": 170}, {""expr"": ""in[6]"", ""value"": 170}, {""expr"": ""in[7]"", ""value"": 170}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""state[0] and state[1] have different patterns"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 305419896}, {""expr"": ""state_PTRTO[1]"", ""value"": 2271560481}, {""expr"": ""in"", ""value"": ""00000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""in[0]"", ""value"": 18}, {""expr"": ""in[1]"", ""value"": 33}, {""expr"": ""in[2]"", ""value"": 66}, {""expr"": ""in[3]"", ""value"": 132}, {""expr"": ""in[4]"", ""value"": 36}, {""expr"": ""in[5]"", ""value"": 72}, {""expr"": ""in[6]"", ""value"": 144}, {""expr"": ""in[7]"", ""value"": 9}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""state[0] and state[1] have the same pattern"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 123456789}, {""expr"": ""state_PTRTO[1]"", ""value"": 123456789}, {""expr"": ""in"", ""value"": ""00000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""in[0]"", ""value"": 18}, {""expr"": ""in[1]"", ""value"": 36}, {""expr"": ""in[2]"", ""value"": 72}, {""expr"": ""in[3]"", ""value"": 145}, {""expr"": ""in[4]"", ""value"": 18}, {""expr"": ""in[5]"", ""value"": 36}, {""expr"": ""in[6]"", ""value"": 72}, {""expr"": ""in[7]"", ""value"": 145}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""state[0] is 0xFFFFFFFF and state[1] is 0"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 4294967295}, {""expr"": ""state_PTRTO[1]"", ""value"": 0}, {""expr"": ""in"", ""value"": ""00000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""in[0]"", ""value"": 85}, {""expr"": ""in[1]"", ""value"": 85}, {""expr"": ""in[2]"", ""value"": 85}, {""expr"": ""in[3]"", ""value"": 85}, {""expr"": ""in[4]"", ""value"": 85}, {""expr"": ""in[5]"", ""value"": 85}, {""expr"": ""in[6]"", ""value"": 85}, {""expr"": ""in[7]"", ""value"": 85}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""state[0] is 0 and state[1] is 0xFFFFFFFF"", ""inputs"": [{""expr"": ""state_PTRTO[0]"", ""value"": 0}, {""expr"": ""state_PTRTO[1]"", ""value"": 4294967295}, {""expr"": ""in"", ""value"": ""00000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""in[0]"", ""value"": 170}, {""expr"": ""in[1]"", ""value"": 170}, {""expr"": ""in[2]"", ""value"": 170}, {""expr"": ""in[3]"", ""value"": 170}, {""expr"": ""in[4]"", ""value"": 170}, {""expr"": ""in[5]"", ""value"": 170}, {""expr"": ""in[6]"", ""value"": 170}, {""expr"": ""in[7]"", ""value"": 170}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""state"", ""userVar"": ""state_PTRTO""}], ""ios"": []}"
des,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
static const BYTE sbox1[64] 
static const BYTE sbox2[64] 
static const BYTE sbox3[64] 
static const BYTE sbox4[64] 
static const BYTE sbox5[64] 
static const BYTE sbox6[64] 
static const BYTE sbox7[64] 
static const BYTE sbox8[64] 
WORD f(WORD state, const BYTE key[]) 
{ 
 BYTE lrgstate[6]; 
 WORD t1,t2; 
 t1 = ((((state) << (31)) & 0x80000000) >> (0)) | ((state & 0xf0000000) >> 1) | ((((state) << (4)) & 0x80000000) >> (5)) | 
    ((((state) << (3)) & 0x80000000) >> (6)) | ((state & 0x0f000000) >> 3) | ((((state) << (8)) & 0x80000000) >> (11)) | 
    ((((state) << (7)) & 0x80000000) >> (12)) | ((state & 0x00f00000) >> 5) | ((((state) << (12)) & 0x80000000) >> (17)) | 
    ((((state) << (11)) & 0x80000000) >> (18)) | ((state & 0x000f0000) >> 7) | ((((state) << (16)) & 0x80000000) >> (23)); 
 t2 = ((((state) << (15)) & 0x80000000) >> (0)) | ((state & 0x0000f000) << 15) | ((((state) << (20)) & 0x80000000) >> (5)) | 
    ((((state) << (19)) & 0x80000000) >> (6)) | ((state & 0x00000f00) << 13) | ((((state) << (24)) & 0x80000000) >> (11)) | 
    ((((state) << (23)) & 0x80000000) >> (12)) | ((state & 0x000000f0) << 11) | ((((state) << (28)) & 0x80000000) >> (17)) | 
    ((((state) << (27)) & 0x80000000) >> (18)) | ((state & 0x0000000f) << 9) | ((((state) << (0)) & 0x80000000) >> (23)); 
 lrgstate[0] = (t1 >> 24) & 0x000000ff; 
 lrgstate[1] = (t1 >> 16) & 0x000000ff; 
 lrgstate[2] = (t1 >> 8) & 0x000000ff; 
 lrgstate[3] = (t2 >> 24) & 0x000000ff; 
 lrgstate[4] = (t2 >> 16) & 0x000000ff; 
 lrgstate[5] = (t2 >> 8) & 0x000000ff; 
 lrgstate[0] ^= key[0]; 
 lrgstate[1] ^= key[1]; 
 lrgstate[2] ^= key[2]; 
 lrgstate[3] ^= key[3]; 
 lrgstate[4] ^= key[4]; 
 lrgstate[5] ^= key[5]; 
 state = (sbox1[(((lrgstate[0] >> 2) & 0x20) | (((lrgstate[0] >> 2) & 0x1f) >> 1) | (((lrgstate[0] >> 2) & 0x01) << 4))] << 28) | 
     (sbox2[(((((lrgstate[0] & 0x03) << 4) | (lrgstate[1] >> 4)) & 0x20) | (((((lrgstate[0] & 0x03) << 4) | (lrgstate[1] >> 4)) & 0x1f) >> 1) | (((((lrgstate[0] & 0x03) << 4) | (lrgstate[1] >> 4)) & 0x01) << 4))] << 24) | 
     (sbox3[(((((lrgstate[1] & 0x0f) << 2) | (lrgstate[2] >> 6)) & 0x20) | (((((lrgstate[1] & 0x0f) << 2) | (lrgstate[2] >> 6)) & 0x1f) >> 1) | (((((lrgstate[1] & 0x0f) << 2) | (lrgstate[2] >> 6)) & 0x01) << 4))] << 20) | 
     (sbox4[(((lrgstate[2] & 0x3f) & 0x20) | (((lrgstate[2] & 0x3f) & 0x1f) >> 1) | (((lrgstate[2] & 0x3f) & 0x01) << 4))] << 16) | 
     (sbox5[(((lrgstate[3] >> 2) & 0x20) | (((lrgstate[3] >> 2) & 0x1f) >> 1) | (((lrgstate[3] >> 2) & 0x01) << 4))] << 12) | 
     (sbox6[(((((lrgstate[3] & 0x03) << 4) | (lrgstate[4] >> 4)) & 0x20) | (((((lrgstate[3] & 0x03) << 4) | (lrgstate[4] >> 4)) & 0x1f) >> 1) | (((((lrgstate[3] & 0x03) << 4) | (lrgstate[4] >> 4)) & 0x01) << 4))] << 8) | 
     (sbox7[(((((lrgstate[4] & 0x0f) << 2) | (lrgstate[5] >> 6)) & 0x20) | (((((lrgstate[4] & 0x0f) << 2) | (lrgstate[5] >> 6)) & 0x1f) >> 1) | (((((lrgstate[4] & 0x0f) << 2) | (lrgstate[5] >> 6)) & 0x01) << 4))] << 4) | 
    sbox8[(((lrgstate[5] & 0x3f) & 0x20) | (((lrgstate[5] & 0x3f) & 0x1f) >> 1) | (((lrgstate[5] & 0x3f) & 0x01) << 4))]; 
 state = ((((state) << (15)) & 0x80000000) >> (0)) | ((((state) << (6)) & 0x80000000) >> (1)) | ((((state) << (19)) & 0x80000000) >> (2)) | 
     ((((state) << (20)) & 0x80000000) >> (3)) | ((((state) << (28)) & 0x80000000) >> (4)) | ((((state) << (11)) & 0x80000000) >> (5)) | 
     ((((state) << (27)) & 0x80000000) >> (6)) | ((((state) << (16)) & 0x80000000) >> (7)) | ((((state) << (0)) & 0x80000000) >> (8)) | 
     ((((state) << (14)) & 0x80000000) >> (9)) | ((((state) << (22)) & 0x80000000) >> (10)) | ((((state) << (25)) & 0x80000000) >> (11)) | 
     ((((state) << (4)) & 0x80000000) >> (12)) | ((((state) << (17)) & 0x80000000) >> (13)) | ((((state) << (30)) & 0x80000000) >> (14)) | 
     ((((state) << (9)) & 0x80000000) >> (15)) | ((((state) << (1)) & 0x80000000) >> (16)) | ((((state) << (7)) & 0x80000000) >> (17)) | 
     ((((state) << (23)) & 0x80000000) >> (18)) | ((((state) << (13)) & 0x80000000) >> (19)) | ((((state) << (31)) & 0x80000000) >> (20)) | 
     ((((state) << (26)) & 0x80000000) >> (21)) | ((((state) << (2)) & 0x80000000) >> (22)) | ((((state) << (8)) & 0x80000000) >> (23)) | 
     ((((state) << (18)) & 0x80000000) >> (24)) | ((((state) << (12)) & 0x80000000) >> (25)) | ((((state) << (29)) & 0x80000000) >> (26)) | 
     ((((state) << (5)) & 0x80000000) >> (27)) | ((((state) << (21)) & 0x80000000) >> (28)) | ((((state) << (10)) & 0x80000000) >> (29)) | 
     ((((state) << (3)) & 0x80000000) >> (30)) | ((((state) << (24)) & 0x80000000) >> (31)); 
 return(state); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""state"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""sbox8"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox2"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox3"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox1"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox6"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox7"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox4"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox5"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""WORD"", ""value"": 0}]}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
static const BYTE sbox1[64] 
static const BYTE sbox2[64] 
static const BYTE sbox3[64] 
static const BYTE sbox4[64] 
static const BYTE sbox5[64] 
static const BYTE sbox6[64] 
static const BYTE sbox7[64] 
static const BYTE sbox8[64] 
WORD f(WORD state, const BYTE key[]) 
{ 
 BYTE lrgstate[6]; 
 WORD t1,t2; 
 t1 = ((((state) << (31)) & 0x80000000) >> (0)) | ((state & 0xf0000000) >> 1) | ((((state) << (4)) & 0x80000000) >> (5)) | 
    ((((state) << (3)) & 0x80000000) >> (6)) | ((state & 0x0f000000) >> 3) | ((((state) << (8)) & 0x80000000) >> (11)) | 
    ((((state) << (7)) & 0x80000000) >> (12)) | ((state & 0x00f00000) >> 5) | ((((state) << (12)) & 0x80000000) >> (17)) | 
    ((((state) << (11)) & 0x80000000) >> (18)) | ((state & 0x000f0000) >> 7) | ((((state) << (16)) & 0x80000000) >> (23)); 
 t2 = ((((state) << (15)) & 0x80000000) >> (0)) | ((state & 0x0000f000) << 15) | ((((state) << (20)) & 0x80000000) >> (5)) | 
    ((((state) << (19)) & 0x80000000) >> (6)) | ((state & 0x00000f00) << 13) | ((((state) << (24)) & 0x80000000) >> (11)) | 
    ((((state) << (23)) & 0x80000000) >> (12)) | ((state & 0x000000f0) << 11) | ((((state) << (28)) & 0x80000000) >> (17)) | 
    ((((state) << (27)) & 0x80000000) >> (18)) | ((state & 0x0000000f) << 9) | ((((state) << (0)) & 0x80000000) >> (23)); 
 lrgstate[0] = (t1 >> 24) & 0x000000ff; 
 lrgstate[1] = (t1 >> 16) & 0x000000ff; 
 lrgstate[2] = (t1 >> 8) & 0x000000ff; 
 lrgstate[3] = (t2 >> 24) & 0x000000ff; 
 lrgstate[4] = (t2 >> 16) & 0x000000ff; 
 lrgstate[5] = (t2 >> 8) & 0x000000ff; 
 lrgstate[0] ^= key[0]; 
 lrgstate[1] ^= key[1]; 
 lrgstate[2] ^= key[2]; 
 lrgstate[3] ^= key[3]; 
 lrgstate[4] ^= key[4]; 
 lrgstate[5] ^= key[5]; 
 state = (sbox1[(((lrgstate[0] >> 2) & 0x20) | (((lrgstate[0] >> 2) & 0x1f) >> 1) | (((lrgstate[0] >> 2) & 0x01) << 4))] << 28) | 
     (sbox2[(((((lrgstate[0] & 0x03) << 4) | (lrgstate[1] >> 4)) & 0x20) | (((((lrgstate[0] & 0x03) << 4) | (lrgstate[1] >> 4)) & 0x1f) >> 1) | (((((lrgstate[0] & 0x03) << 4) | (lrgstate[1] >> 4)) & 0x01) << 4))] << 24) | 
     (sbox3[(((((lrgstate[1] & 0x0f) << 2) | (lrgstate[2] >> 6)) & 0x20) | (((((lrgstate[1] & 0x0f) << 2) | (lrgstate[2] >> 6)) & 0x1f) >> 1) | (((((lrgstate[1] & 0x0f) << 2) | (lrgstate[2] >> 6)) & 0x01) << 4))] << 20) | 
     (sbox4[(((lrgstate[2] & 0x3f) & 0x20) | (((lrgstate[2] & 0x3f) & 0x1f) >> 1) | (((lrgstate[2] & 0x3f) & 0x01) << 4))] << 16) | 
     (sbox5[(((lrgstate[3] >> 2) & 0x20) | (((lrgstate[3] >> 2) & 0x1f) >> 1) | (((lrgstate[3] >> 2) & 0x01) << 4))] << 12) | 
     (sbox6[(((((lrgstate[3] & 0x03) << 4) | (lrgstate[4] >> 4)) & 0x20) | (((((lrgstate[3] & 0x03) << 4) | (lrgstate[4] >> 4)) & 0x1f) >> 1) | (((((lrgstate[3] & 0x03) << 4) | (lrgstate[4] >> 4)) & 0x01) << 4))] << 8) | 
     (sbox7[(((((lrgstate[4] & 0x0f) << 2) | (lrgstate[5] >> 6)) & 0x20) | (((((lrgstate[4] & 0x0f) << 2) | (lrgstate[5] >> 6)) & 0x1f) >> 1) | (((((lrgstate[4] & 0x0f) << 2) | (lrgstate[5] >> 6)) & 0x01) << 4))] << 4) | 
    sbox8[(((lrgstate[5] & 0x3f) & 0x20) | (((lrgstate[5] & 0x3f) & 0x1f) >> 1) | (((lrgstate[5] & 0x3f) & 0x01) << 4))]; 
 state = ((((state) << (15)) & 0x80000000) >> (0)) | ((((state) << (6)) & 0x80000000) >> (1)) | ((((state) << (19)) & 0x80000000) >> (2)) | 
     ((((state) << (20)) & 0x80000000) >> (3)) | ((((state) << (28)) & 0x80000000) >> (4)) | ((((state) << (11)) & 0x80000000) >> (5)) | 
     ((((state) << (27)) & 0x80000000) >> (6)) | ((((state) << (16)) & 0x80000000) >> (7)) | ((((state) << (0)) & 0x80000000) >> (8)) | 
     ((((state) << (14)) & 0x80000000) >> (9)) | ((((state) << (22)) & 0x80000000) >> (10)) | ((((state) << (25)) & 0x80000000) >> (11)) | 
     ((((state) << (4)) & 0x80000000) >> (12)) | ((((state) << (17)) & 0x80000000) >> (13)) | ((((state) << (30)) & 0x80000000) >> (14)) | 
     ((((state) << (9)) & 0x80000000) >> (15)) | ((((state) << (1)) & 0x80000000) >> (16)) | ((((state) << (7)) & 0x80000000) >> (17)) | 
     ((((state) << (23)) & 0x80000000) >> (18)) | ((((state) << (13)) & 0x80000000) >> (19)) | ((((state) << (31)) & 0x80000000) >> (20)) | 
     ((((state) << (26)) & 0x80000000) >> (21)) | ((((state) << (2)) & 0x80000000) >> (22)) | ((((state) << (8)) & 0x80000000) >> (23)) | 
     ((((state) << (18)) & 0x80000000) >> (24)) | ((((state) << (12)) & 0x80000000) >> (25)) | ((((state) << (29)) & 0x80000000) >> (26)) | 
     ((((state) << (5)) & 0x80000000) >> (27)) | ((((state) << (21)) & 0x80000000) >> (28)) | ((((state) << (10)) & 0x80000000) >> (29)) | 
     ((((state) << (3)) & 0x80000000) >> (30)) | ((((state) << (24)) & 0x80000000) >> (31)); 
 return(state); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""state"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""sbox8"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox2"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox3"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox1"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox6"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox7"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox4"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}, {""expr"": ""sbox5"", ""type"": ""const BYTE [64]"", ""value"": ""[0]""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""WORD"", ""value"": 0}]}
{other test cases}
","{""func"": ""f"", ""file"": """", ""cases"": [{""desc"": ""Test with state set to 0 and key set to all zeros. All S-boxes are initialized with zeros."", ""inputs"": [{""expr"": ""state"", ""value"": 0}, {""expr"": ""key"", ""value"": ""[0, 0, 0, 0, 0, 0]""}, {""expr"": ""sbox1"", ""value"": ""[0]""}, {""expr"": ""sbox2"", ""value"": ""[0]""}, {""expr"": ""sbox3"", ""value"": ""[0]""}, {""expr"": ""sbox4"", ""value"": ""[0]""}, {""expr"": ""sbox5"", ""value"": ""[0]""}, {""expr"": ""sbox6"", ""value"": ""[0]""}, {""expr"": ""sbox7"", ""value"": ""[0]""}, {""expr"": ""sbox8"", ""value"": ""[0]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with state set to maximum value (0xFFFFFFFF) and key set to all ones. All S-boxes are initialized with maximum values."", ""inputs"": [{""expr"": ""state"", ""value"": 4294967295}, {""expr"": ""key"", ""value"": ""[255, 255, 255, 255, 255, 255]""}, {""expr"": ""sbox1"", ""value"": ""[255]""}, {""expr"": ""sbox2"", ""value"": ""[255]""}, {""expr"": ""sbox3"", ""value"": ""[255]""}, {""expr"": ""sbox4"", ""value"": ""[255]""}, {""expr"": ""sbox5"", ""value"": ""[255]""}, {""expr"": ""sbox6"", ""value"": ""[255]""}, {""expr"": ""sbox7"", ""value"": ""[255]""}, {""expr"": ""sbox8"", ""value"": ""[255]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4294967295}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
des,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
typedef enum Anonymous_enum_17b9cfea_2 { 
 DES_ENCRYPT, 
 DES_DECRYPT 
} DES_MODE; 
void des_key_setup(const BYTE key[], BYTE schedule[][6], DES_MODE mode) 
{ 
 WORD i, j, to_gen, C, D; 
 const WORD key_rnd_shift[16] = {1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1}; 
 const WORD key_perm_c[28] = {56,48,40,32,24,16,8,0,57,49,41,33,25,17, 
                              9,1,58,50,42,34,26,18,10,2,59,51,43,35}; 
 const WORD key_perm_d[28] = {62,54,46,38,30,22,14,6,61,53,45,37,29,21, 
                              13,5,60,52,44,36,28,20,12,4,27,19,11,3}; 
 const WORD key_compression[48] = {13,16,10,23,0,4,2,27,14,5,20,9, 
                                   22,18,11,3,25,7,15,6,26,19,12,1, 
                                   40,51,30,36,46,54,29,39,50,44,32,47, 
                                   43,48,38,55,33,52,45,41,49,35,28,31}; 
 for (i = 0, j = 31, C = 0; i < 28; ++i, --j) 
  C |= (((key[(key_perm_c[i])/8] >> (7 - (key_perm_c[i]%8))) & 0x01) << (j)); 
 for (i = 0, j = 31, D = 0; i < 28; ++i, --j) 
  D |= (((key[(key_perm_d[i])/8] >> (7 - (key_perm_d[i]%8))) & 0x01) << (j)); 
 for (i = 0; i < 16; ++i) { 
  C = ((C << key_rnd_shift[i]) | (C >> (28-key_rnd_shift[i]))) & 0xfffffff0; 
  D = ((D << key_rnd_shift[i]) | (D >> (28-key_rnd_shift[i]))) & 0xfffffff0; 
  if (mode == DES_DECRYPT) 
   to_gen = 15 - i; 
  else 
   to_gen = i; 
  for (j = 0; j < 6; ++j) 
   schedule[to_gen][j] = 0; 
  for (j = 0; j < 24; ++j) 
   schedule[to_gen][j/8] |= ((((C) >> (31 - (key_compression[j]))) & 0x00000001) << (7 - (j%8))); 
  for ( ; j < 48; ++j) 
   schedule[to_gen][j/8] |= ((((D) >> (31 - (key_compression[j] - 28))) & 0x00000001) << (7 - (j%8))); 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
typedef enum Anonymous_enum_17b9cfea_2 { 
 DES_ENCRYPT, 
 DES_DECRYPT 
} DES_MODE; 
void des_key_setup(const BYTE key[], BYTE schedule[][6], DES_MODE mode) 
{ 
 WORD i, j, to_gen, C, D; 
 const WORD key_rnd_shift[16] = {1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1}; 
 const WORD key_perm_c[28] = {56,48,40,32,24,16,8,0,57,49,41,33,25,17, 
                              9,1,58,50,42,34,26,18,10,2,59,51,43,35}; 
 const WORD key_perm_d[28] = {62,54,46,38,30,22,14,6,61,53,45,37,29,21, 
                              13,5,60,52,44,36,28,20,12,4,27,19,11,3}; 
 const WORD key_compression[48] = {13,16,10,23,0,4,2,27,14,5,20,9, 
                                   22,18,11,3,25,7,15,6,26,19,12,1, 
                                   40,51,30,36,46,54,29,39,50,44,32,47, 
                                   43,48,38,55,33,52,45,41,49,35,28,31}; 
 for (i = 0, j = 31, C = 0; i < 28; ++i, --j) 
  C |= (((key[(key_perm_c[i])/8] >> (7 - (key_perm_c[i]%8))) & 0x01) << (j)); 
 for (i = 0, j = 31, D = 0; i < 28; ++i, --j) 
  D |= (((key[(key_perm_d[i])/8] >> (7 - (key_perm_d[i]%8))) & 0x01) << (j)); 
 for (i = 0; i < 16; ++i) { 
  C = ((C << key_rnd_shift[i]) | (C >> (28-key_rnd_shift[i]))) & 0xfffffff0; 
  D = ((D << key_rnd_shift[i]) | (D >> (28-key_rnd_shift[i]))) & 0xfffffff0; 
  if (mode == DES_DECRYPT) 
   to_gen = 15 - i; 
  else 
   to_gen = i; 
  for (j = 0; j < 6; ++j) 
   schedule[to_gen][j] = 0; 
  for (j = 0; j < 24; ++j) 
   schedule[to_gen][j/8] |= ((((C) >> (31 - (key_compression[j]))) & 0x00000001) << (7 - (j%8))); 
  for ( ; j < 48; ++j) 
   schedule[to_gen][j/8] |= ((((D) >> (31 - (key_compression[j] - 28))) & 0x00000001) << (7 - (j%8))); 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""outputs"": []}
{other test cases}
","{""func"": ""des_key_setup"", ""file"": """", ""cases"": [{""desc"": ""Test with a simple key and DES_ENCRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_ENCRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x01""}, {""expr"": ""key[1]"", ""value"": ""0x23""}, {""expr"": ""key[2]"", ""value"": ""0x45""}, {""expr"": ""key[3]"", ""value"": ""0x67""}, {""expr"": ""key[4]"", ""value"": ""0x89""}, {""expr"": ""key[5]"", ""value"": ""0xAB""}, {""expr"": ""key[6]"", ""value"": ""0xCD""}, {""expr"": ""key[7]"", ""value"": ""0xEF""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with a different key and DES_DECRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_DECRYPT""}, {""expr"": ""key[0]"", ""value"": ""0xFF""}, {""expr"": ""key[1]"", ""value"": ""0xEE""}, {""expr"": ""key[2]"", ""value"": ""0xDD""}, {""expr"": ""key[3]"", ""value"": ""0xCC""}, {""expr"": ""key[4]"", ""value"": ""0xBB""}, {""expr"": ""key[5]"", ""value"": ""0xAA""}, {""expr"": ""key[6]"", ""value"": ""0x99""}, {""expr"": ""key[7]"", ""value"": ""0x88""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with all zero key and DES_ENCRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_ENCRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x00""}, {""expr"": ""key[1]"", ""value"": ""0x00""}, {""expr"": ""key[2]"", ""value"": ""0x00""}, {""expr"": ""key[3]"", ""value"": ""0x00""}, {""expr"": ""key[4]"", ""value"": ""0x00""}, {""expr"": ""key[5]"", ""value"": ""0x00""}, {""expr"": ""key[6]"", ""value"": ""0x00""}, {""expr"": ""key[7]"", ""value"": ""0x00""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with all one key and DES_DECRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_DECRYPT""}, {""expr"": ""key[0]"", ""value"": ""0xFF""}, {""expr"": ""key[1]"", ""value"": ""0xFF""}, {""expr"": ""key[2]"", ""value"": ""0xFF""}, {""expr"": ""key[3]"", ""value"": ""0xFF""}, {""expr"": ""key[4]"", ""value"": ""0xFF""}, {""expr"": ""key[5]"", ""value"": ""0xFF""}, {""expr"": ""key[6]"", ""value"": ""0xFF""}, {""expr"": ""key[7]"", ""value"": ""0xFF""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with alternating bit pattern key and DES_ENCRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_ENCRYPT""}, {""expr"": ""key[0]"", ""value"": ""0xAA""}, {""expr"": ""key[1]"", ""value"": ""0x55""}, {""expr"": ""key[2]"", ""value"": ""0xAA""}, {""expr"": ""key[3]"", ""value"": ""0x55""}, {""expr"": ""key[4]"", ""value"": ""0xAA""}, {""expr"": ""key[5]"", ""value"": ""0x55""}, {""expr"": ""key[6]"", ""value"": ""0xAA""}, {""expr"": ""key[7]"", ""value"": ""0x55""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with alternating bit pattern key and DES_DECRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_DECRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x55""}, {""expr"": ""key[1]"", ""value"": ""0xAA""}, {""expr"": ""key[2]"", ""value"": ""0x55""}, {""expr"": ""key[3]"", ""value"": ""0xAA""}, {""expr"": ""key[4]"", ""value"": ""0x55""}, {""expr"": ""key[5]"", ""value"": ""0xAA""}, {""expr"": ""key[6]"", ""value"": ""0x55""}, {""expr"": ""key[7]"", ""value"": ""0xAA""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with a random key and DES_ENCRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_ENCRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x13""}, {""expr"": ""key[1]"", ""value"": ""0x34""}, {""expr"": ""key[2]"", ""value"": ""0x57""}, {""expr"": ""key[3]"", ""value"": ""0x79""}, {""expr"": ""key[4]"", ""value"": ""0x9B""}, {""expr"": ""key[5]"", ""value"": ""0xBC""}, {""expr"": ""key[6]"", ""value"": ""0xDF""}, {""expr"": ""key[7]"", ""value"": ""0xF1""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with a random key and DES_DECRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_DECRYPT""}, {""expr"": ""key[0]"", ""value"": ""0xF1""}, {""expr"": ""key[1]"", ""value"": ""0xDF""}, {""expr"": ""key[2]"", ""value"": ""0xBC""}, {""expr"": ""key[3]"", ""value"": ""0x9B""}, {""expr"": ""key[4]"", ""value"": ""0x79""}, {""expr"": ""key[5]"", ""value"": ""0x57""}, {""expr"": ""key[6]"", ""value"": ""0x34""}, {""expr"": ""key[7]"", ""value"": ""0x13""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with a key containing all 0x80 values and DES_ENCRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_ENCRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x80""}, {""expr"": ""key[1]"", ""value"": ""0x80""}, {""expr"": ""key[2]"", ""value"": ""0x80""}, {""expr"": ""key[3]"", ""value"": ""0x80""}, {""expr"": ""key[4]"", ""value"": ""0x80""}, {""expr"": ""key[5]"", ""value"": ""0x80""}, {""expr"": ""key[6]"", ""value"": ""0x80""}, {""expr"": ""key[7]"", ""value"": ""0x80""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with a key containing all 0x80 values and DES_DECRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_DECRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x80""}, {""expr"": ""key[1]"", ""value"": ""0x80""}, {""expr"": ""key[2]"", ""value"": ""0x80""}, {""expr"": ""key[3]"", ""value"": ""0x80""}, {""expr"": ""key[4]"", ""value"": ""0x80""}, {""expr"": ""key[5]"", ""value"": ""0x80""}, {""expr"": ""key[6]"", ""value"": ""0x80""}, {""expr"": ""key[7]"", ""value"": ""0x80""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
des,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
void des_crypt(const BYTE in[], BYTE out[], const BYTE key[][6]) 
{ 
 WORD state[2],idx,t; 
 IP(state,in); 
 for (idx=0; idx < 15; ++idx) { 
  t = state[1]; 
  state[1] = f(state[1],key[idx]) ^ state[0]; 
  state[0] = t; 
 } 
 state[0] = f(state[1],key[15]) ^ state[0]; 
 InvIP(state,out); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void InvIP(WORD *state,BYTE *in)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*state"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""WORD f(WORD state,const BYTE *key)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""sbox6"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox8"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox4"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox3"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox5"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox7"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox2"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox1"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void IP(WORD *state,const BYTE *in)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*state"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
void des_crypt(const BYTE in[], BYTE out[], const BYTE key[][6]) 
{ 
 WORD state[2],idx,t; 
 IP(state,in); 
 for (idx=0; idx < 15; ++idx) { 
  t = state[1]; 
  state[1] = f(state[1],key[idx]) ^ state[0]; 
  state[0] = t; 
 } 
 state[0] = f(state[1],key[15]) ^ state[0]; 
 InvIP(state,out); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void InvIP(WORD *state,BYTE *in)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*state"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""WORD f(WORD state,const BYTE *key)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""sbox6"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox8"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox4"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox3"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox5"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox7"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox2"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""sbox1"", ""type"": ""const BYTE [64]"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void IP(WORD *state,const BYTE *in)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*state"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""des_crypt"", ""file"": """", ""cases"": [{""desc"": ""Test case 1: Basic functionality test with standard inputs"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefgh""}, {""expr"": ""out"", ""value"": ""        ""}, {""expr"": ""key[0]"", ""value"": ""\""123456\""""}, {""expr"": ""key[1]"", ""value"": ""\""234567\""""}, {""expr"": ""key[2]"", ""value"": ""\""345678\""""}, {""expr"": ""key[3]"", ""value"": ""\""456789\""""}, {""expr"": ""key[4]"", ""value"": ""\""567890\""""}, {""expr"": ""key[5]"", ""value"": ""\""678901\""""}, {""expr"": ""key[6]"", ""value"": ""\""789012\""""}, {""expr"": ""key[7]"", ""value"": ""\""890123\""""}, {""expr"": ""key[8]"", ""value"": ""\n\""901234\""""}, {""expr"": ""key[9]"", ""value"": ""\""012345\""""}, {""expr"": ""key[10]"", ""value"": ""\""123456\""""}, {""expr"": ""key[11]"", ""value"": ""\""234567\""""}, {""expr"": ""key[12]"", ""value"": ""\""345678\""""}, {""expr"": ""key[13]"", ""value"": ""\""456789\""""}, {""expr"": ""key[14]"", ""value"": ""\""567890\""""}, {""expr"": ""key[15]"", ""value"": ""\""678901\""""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": ""0x1234"", ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""returnValue"", ""value"": ""0x5678"", ""funcName"": ""f""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""f""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": ""0x9abc"", ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}], ""outputs"": [{""expr"": ""out"", ""value"": ""\""output1\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 2: Edge case with empty input"", ""inputs"": [{""expr"": ""out"", ""value"": ""        ""}, {""expr"": ""key[0]"", ""value"": ""\""abcdef\""""}, {""expr"": ""key[1]"", ""value"": ""\""bcdefg\""""}, {""expr"": ""key[2]"", ""value"": ""\""cdefgh\""""}, {""expr"": ""key[3]"", ""value"": ""\""defghi\""""}, {""expr"": ""key[4]"", ""value"": ""\""efghij\""""}, {""expr"": ""key[5]"", ""value"": ""\""fghijk\""""}, {""expr"": ""key[6]"", ""value"": ""\""ghijkl\""""}, {""expr"": ""key[7]"", ""value"": ""\""hijklm\""""}, {""expr"": ""key[8]"", ""value"": ""\n\""ijklmn\""""}, {""expr"": ""key[9]"", ""value"": ""\""jklmno\""""}, {""expr"": ""key[10]"", ""value"": ""\""klmnop\""""}, {""expr"": ""key[11]"", ""value"": ""\""lmnopq\""""}, {""expr"": ""key[12]"", ""value"": ""\""mnopqr\""""}, {""expr"": ""key[13]"", ""value"": ""\""nopqrs\""""}, {""expr"": ""key[14]"", ""value"": ""\""opqrst\""""}, {""expr"": ""key[15]"", ""value"": ""\""pqrstu\""""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""f""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""f""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}], ""outputs"": [{""expr"": ""out"", ""value"": ""\""output2\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 3: Test with maximum values for input"", ""inputs"": [{""expr"": ""in"", ""value"": ""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF""}, {""expr"": ""out"", ""value"": ""        ""}, {""expr"": ""key[0]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[1]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[2]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[3]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[4]"", ""value"": ""\n\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[5]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[6]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[7]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[8]"", ""value"": ""\n\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[9]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[10]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[11]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[12]"", ""value"": ""\n\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[13]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[14]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}, {""expr"": ""key[15]"", ""value"": ""\""\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\""""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": ""0xFFFF"", ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""returnValue"", ""value"": ""0xFFFF"", ""funcName"": ""f""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""f""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": ""0xFFFF"", ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}], ""outputs"": [{""expr"": ""out"", ""value"": ""\""output3\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 4: Test with alternating bits pattern"", ""inputs"": [{""expr"": ""in"", ""value"": ""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA""}, {""expr"": ""out"", ""value"": ""        ""}, {""expr"": ""key[0]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[1]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[2]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[3]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[4]"", ""value"": ""\n\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[5]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[6]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[7]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[8]"", ""value"": ""\n\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[9]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[10]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[11]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[12]"", ""value"": ""\n\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[13]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[14]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}, {""expr"": ""key[15]"", ""value"": ""\""\\xAA\\xAA\\xAA\\xAA\\xAA\\xAA\""""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": ""0xAAAA"", ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""returnValue"", ""value"": ""0xAAAA"", ""funcName"": ""f""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""f""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": ""0xAAAA"", ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}], ""outputs"": [{""expr"": ""out"", ""value"": ""\""output4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 5: Test with zero key"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefgh""}, {""expr"": ""out"", ""value"": ""        ""}, {""expr"": ""key[0]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[1]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[2]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[3]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[4]"", ""value"": ""\n\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[5]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[6]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[7]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[8]"", ""value"": ""\n\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[9]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[10]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[11]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[12]"", ""value"": ""\n\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[13]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[14]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}, {""expr"": ""key[15]"", ""value"": ""\""\\x00\\x00\\x00\\x00\\x00\\x00\""""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""f""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""f""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*state"", ""value"": 0, ""funcName"": ""IP""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""IP""}], ""outputs"": [{""expr"": ""out"", ""value"": ""\""output5\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
des,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef enum Anonymous_enum_17b9cfea_2 { 
 DES_ENCRYPT, 
 DES_DECRYPT 
} DES_MODE; 
void three_des_key_setup(const BYTE key[], BYTE schedule[][16][6], DES_MODE mode) 
{ 
 if (mode == DES_ENCRYPT) { 
  des_key_setup(&key[0],schedule[0],mode); 
  des_key_setup(&key[8],schedule[1],!mode); 
  des_key_setup(&key[16],schedule[2],mode); 
 } 
 else { 
  des_key_setup(&key[16],schedule[0],mode); 
  des_key_setup(&key[8],schedule[1],!mode); 
  des_key_setup(&key[0],schedule[2],mode); 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void des_key_setup(const BYTE *key,BYTE (*schedule)[6],DES_MODE mode)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""schedule"", ""type"": ""BYTE (*)[6]"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef enum Anonymous_enum_17b9cfea_2 { 
 DES_ENCRYPT, 
 DES_DECRYPT 
} DES_MODE; 
void three_des_key_setup(const BYTE key[], BYTE schedule[][16][6], DES_MODE mode) 
{ 
 if (mode == DES_ENCRYPT) { 
  des_key_setup(&key[0],schedule[0],mode); 
  des_key_setup(&key[8],schedule[1],!mode); 
  des_key_setup(&key[16],schedule[2],mode); 
 } 
 else { 
  des_key_setup(&key[16],schedule[0],mode); 
  des_key_setup(&key[8],schedule[1],!mode); 
  des_key_setup(&key[0],schedule[2],mode); 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void des_key_setup(const BYTE *key,BYTE (*schedule)[6],DES_MODE mode)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*key"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""schedule"", ""type"": ""BYTE (*)[6]"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""three_des_key_setup"", ""file"": """", ""cases"": [{""desc"": ""Test case 1: DES_ENCRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_ENCRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x01""}, {""expr"": ""key[1]"", ""value"": ""0x02""}, {""expr"": ""key[2]"", ""value"": ""0x03""}, {""expr"": ""key[3]"", ""value"": ""0x04""}, {""expr"": ""key[4]"", ""value"": ""0x05""}, {""expr"": ""key[5]"", ""value"": ""0x06""}, {""expr"": ""key[6]"", ""value"": ""0x07""}, {""expr"": ""key[7]"", ""value"": ""0x08""}, {""expr"": ""key[8]"", ""value"": ""0x09""}, {""expr"": ""key[9]"", ""value"": ""0x0A""}, {""expr"": ""key[10]"", ""value"": ""0x0B""}, {""expr"": ""key[11]"", ""value"": ""0x0C""}, {""expr"": ""key[12]"", ""value"": ""0x0D""}, {""expr"": ""key[13]"", ""value"": ""0x0E""}, {""expr"": ""key[14]"", ""value"": ""0x0F""}, {""expr"": ""key[15]"", ""value"": ""0x10""}, {""expr"": ""key[16]"", ""value"": ""0x11""}, {""expr"": ""key[17]"", ""value"": ""0x12""}, {""expr"": ""key[18]"", ""value"": ""0x13""}, {""expr"": ""key[19]"", ""value"": ""0x14""}, {""expr"": ""key[20]"", ""value"": ""0x15""}, {""expr"": ""key[21]"", ""value"": ""0x16""}, {""expr"": ""key[22]"", ""value"": ""0x17""}, {""expr"": ""key[23]"", ""value"": ""0x18""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""schedule"", ""value"": 0, ""funcName"": ""des_key_setup""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 2: DES_DECRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_DECRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x01""}, {""expr"": ""key[1]"", ""value"": ""0x02""}, {""expr"": ""key[2]"", ""value"": ""0x03""}, {""expr"": ""key[3]"", ""value"": ""0x04""}, {""expr"": ""key[4]"", ""value"": ""0x05""}, {""expr"": ""key[5]"", ""value"": ""0x06""}, {""expr"": ""key[6]"", ""value"": ""0x07""}, {""expr"": ""key[7]"", ""value"": ""0x08""}, {""expr"": ""key[8]"", ""value"": ""0x09""}, {""expr"": ""key[9]"", ""value"": ""0x0A""}, {""expr"": ""key[10]"", ""value"": ""0x0B""}, {""expr"": ""key[11]"", ""value"": ""0x0C""}, {""expr"": ""key[12]"", ""value"": ""0x0D""}, {""expr"": ""key[13]"", ""value"": ""0x0E""}, {""expr"": ""key[14]"", ""value"": ""0x0F""}, {""expr"": ""key[15]"", ""value"": ""0x10""}, {""expr"": ""key[16]"", ""value"": ""0x11""}, {""expr"": ""key[17]"", ""value"": ""0x12""}, {""expr"": ""key[18]"", ""value"": ""0x13""}, {""expr"": ""key[19]"", ""value"": ""0x14""}, {""expr"": ""key[20]"", ""value"": ""0x15""}, {""expr"": ""key[21]"", ""value"": ""0x16""}, {""expr"": ""key[22]"", ""value"": ""0x17""}, {""expr"": ""key[23]"", ""value"": ""0x18""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""schedule"", ""value"": 0, ""funcName"": ""des_key_setup""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 3: Different keys for each schedule entry in DES_ENCRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_ENCRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x00""}, {""expr"": ""key[1]"", ""value"": ""0x01""}, {""expr"": ""key[2]"", ""value"": ""0x02""}, {""expr"": ""key[3]"", ""value"": ""0x03""}, {""expr"": ""key[4]"", ""value"": ""0x04""}, {""expr"": ""key[5]"", ""value"": ""0x05""}, {""expr"": ""key[6]"", ""value"": ""0x06""}, {""expr"": ""key[7]"", ""value"": ""0x07""}, {""expr"": ""key[8]"", ""value"": ""0x08""}, {""expr"": ""key[9]"", ""value"": ""0x09""}, {""expr"": ""key[10]"", ""value"": ""0x0A""}, {""expr"": ""key[11]"", ""value"": ""0x0B""}, {""expr"": ""key[12]"", ""value"": ""0x0C""}, {""expr"": ""key[13]"", ""value"": ""0x0D""}, {""expr"": ""key[14]"", ""value"": ""0x0E""}, {""expr"": ""key[15]"", ""value"": ""0x0F""}, {""expr"": ""key[16]"", ""value"": ""0x10""}, {""expr"": ""key[17]"", ""value"": ""0x11""}, {""expr"": ""key[18]"", ""value"": ""0x12""}, {""expr"": ""key[19]"", ""value"": ""0x13""}, {""expr"": ""key[20]"", ""value"": ""0x14""}, {""expr"": ""key[21]"", ""value"": ""0x15""}, {""expr"": ""key[22]"", ""value"": ""0x16""}, {""expr"": ""key[23]"", ""value"": ""0x17""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""schedule"", ""value"": 0, ""funcName"": ""des_key_setup""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 4: Different keys for each schedule entry in DES_DECRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_DECRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x00""}, {""expr"": ""key[1]"", ""value"": ""0x01""}, {""expr"": ""key[2]"", ""value"": ""0x02""}, {""expr"": ""key[3]"", ""value"": ""0x03""}, {""expr"": ""key[4]"", ""value"": ""0x04""}, {""expr"": ""key[5]"", ""value"": ""0x05""}, {""expr"": ""key[6]"", ""value"": ""0x06""}, {""expr"": ""key[7]"", ""value"": ""0x07""}, {""expr"": ""key[8]"", ""value"": ""0x08""}, {""expr"": ""key[9]"", ""value"": ""0x09""}, {""expr"": ""key[10]"", ""value"": ""0x0A""}, {""expr"": ""key[11]"", ""value"": ""0x0B""}, {""expr"": ""key[12]"", ""value"": ""0x0C""}, {""expr"": ""key[13]"", ""value"": ""0x0D""}, {""expr"": ""key[14]"", ""value"": ""0x0E""}, {""expr"": ""key[15]"", ""value"": ""0x0F""}, {""expr"": ""key[16]"", ""value"": ""0x10""}, {""expr"": ""key[17]"", ""value"": ""0x11""}, {""expr"": ""key[18]"", ""value"": ""0x12""}, {""expr"": ""key[19]"", ""value"": ""0x13""}, {""expr"": ""key[20]"", ""value"": ""0x14""}, {""expr"": ""key[21]"", ""value"": ""0x15""}, {""expr"": ""key[22]"", ""value"": ""0x16""}, {""expr"": ""key[23]"", ""value"": ""0x17""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""schedule"", ""value"": 0, ""funcName"": ""des_key_setup""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 5: All zero keys in DES_ENCRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_ENCRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x00""}, {""expr"": ""key[1]"", ""value"": ""0x00""}, {""expr"": ""key[2]"", ""value"": ""0x00""}, {""expr"": ""key[3]"", ""value"": ""0x00""}, {""expr"": ""key[4]"", ""value"": ""0x00""}, {""expr"": ""key[5]"", ""value"": ""0x00""}, {""expr"": ""key[6]"", ""value"": ""0x00""}, {""expr"": ""key[7]"", ""value"": ""0x00""}, {""expr"": ""key[8]"", ""value"": ""0x00""}, {""expr"": ""key[9]"", ""value"": ""0x00""}, {""expr"": ""key[10]"", ""value"": ""0x00""}, {""expr"": ""key[11]"", ""value"": ""0x00""}, {""expr"": ""key[12]"", ""value"": ""0x00""}, {""expr"": ""key[13]"", ""value"": ""0x00""}, {""expr"": ""key[14]"", ""value"": ""0x00""}, {""expr"": ""key[15]"", ""value"": ""0x00""}, {""expr"": ""key[16]"", ""value"": ""0x00""}, {""expr"": ""key[17]"", ""value"": ""0x00""}, {""expr"": ""key[18]"", ""value"": ""0x00""}, {""expr"": ""key[19]"", ""value"": ""0x00""}, {""expr"": ""key[20]"", ""value"": ""0x00""}, {""expr"": ""key[21]"", ""value"": ""0x00""}, {""expr"": ""key[22]"", ""value"": ""0x00""}, {""expr"": ""key[23]"", ""value"": ""0x00""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""schedule"", ""value"": 0, ""funcName"": ""des_key_setup""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 6: All zero keys in DES_DECRYPT mode"", ""inputs"": [{""expr"": ""mode"", ""value"": ""DES_DECRYPT""}, {""expr"": ""key[0]"", ""value"": ""0x00""}, {""expr"": ""key[1]"", ""value"": ""0x00""}, {""expr"": ""key[2]"", ""value"": ""0x00""}, {""expr"": ""key[3]"", ""value"": ""0x00""}, {""expr"": ""key[4]"", ""value"": ""0x00""}, {""expr"": ""key[5]"", ""value"": ""0x00""}, {""expr"": ""key[6]"", ""value"": ""0x00""}, {""expr"": ""key[7]"", ""value"": ""0x00""}, {""expr"": ""key[8]"", ""value"": ""0x00""}, {""expr"": ""key[9]"", ""value"": ""0x00""}, {""expr"": ""key[10]"", ""value"": ""0x00""}, {""expr"": ""key[11]"", ""value"": ""0x00""}, {""expr"": ""key[12]"", ""value"": ""0x00""}, {""expr"": ""key[13]"", ""value"": ""0x00""}, {""expr"": ""key[14]"", ""value"": ""0x00""}, {""expr"": ""key[15]"", ""value"": ""0x00""}, {""expr"": ""key[16]"", ""value"": ""0x00""}, {""expr"": ""key[17]"", ""value"": ""0x00""}, {""expr"": ""key[18]"", ""value"": ""0x00""}, {""expr"": ""key[19]"", ""value"": ""0x00""}, {""expr"": ""key[20]"", ""value"": ""0x00""}, {""expr"": ""key[21]"", ""value"": ""0x00""}, {""expr"": ""key[22]"", ""value"": ""0x00""}, {""expr"": ""key[23]"", ""value"": ""0x00""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""*key"", ""value"": 0, ""funcName"": ""des_key_setup""}, {""expr"": ""schedule"", ""value"": 0, ""funcName"": ""des_key_setup""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
des,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void three_des_crypt(const BYTE in[], BYTE out[], const BYTE key[][16][6]) 
{ 
 des_crypt(in,out,key[0]); 
 des_crypt(out,out,key[1]); 
 des_crypt(out,out,key[2]); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void des_crypt(const BYTE *in,BYTE *out,const BYTE (*key)[6])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""key"", ""type"": ""const BYTE (*)[6]"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
void three_des_crypt(const BYTE in[], BYTE out[], const BYTE key[][16][6]) 
{ 
 des_crypt(in,out,key[0]); 
 des_crypt(out,out,key[1]); 
 des_crypt(out,out,key[2]); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void des_crypt(const BYTE *in,BYTE *out,const BYTE (*key)[6])"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""*in"", ""type"": ""const BYTE"", ""value"": 0}, {""expr"": ""*out"", ""type"": ""BYTE"", ""value"": 0}, {""expr"": ""key"", ""type"": ""const BYTE (*)[6]"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""three_des_crypt"", ""file"": """", ""cases"": [{""desc"": ""Test case 1: All keys are identical"", ""inputs"": [{""expr"": ""in[0]"", ""value"": ""0x01""}, {""expr"": ""in[1]"", ""value"": ""0x02""}, {""expr"": ""in[2]"", ""value"": ""0x03""}, {""expr"": ""in[3]"", ""value"": ""0x04""}, {""expr"": ""in[4]"", ""value"": ""0x05""}, {""expr"": ""in[5]"", ""value"": ""0x06""}, {""expr"": ""in[6]"", ""value"": ""0x07""}, {""expr"": ""in[7]"", ""value"": ""0x08""}, {""expr"": ""out[0]"", ""value"": ""0x00""}, {""expr"": ""out[1]"", ""value"": ""0x00""}, {""expr"": ""out[2]"", ""value"": ""0x00""}, {""expr"": ""out[3]"", ""value"": ""0x00""}, {""expr"": ""out[4]"", ""value"": ""0x00""}, {""expr"": ""out[5]"", ""value"": ""0x00""}, {""expr"": ""out[6]"", ""value"": ""0x00""}, {""expr"": ""out[7]"", ""value"": ""0x00""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*out"", ""value"": ""[0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80]"", ""funcName"": ""des_crypt""}, {""expr"": ""key"", ""value"": 0, ""funcName"": ""des_crypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 2: Different keys"", ""inputs"": [{""expr"": ""in[0]"", ""value"": ""0x01""}, {""expr"": ""in[1]"", ""value"": ""0x02""}, {""expr"": ""in[2]"", ""value"": ""0x03""}, {""expr"": ""in[3]"", ""value"": ""0x04""}, {""expr"": ""in[4]"", ""value"": ""0x05""}, {""expr"": ""in[5]"", ""value"": ""0x06""}, {""expr"": ""in[6]"", ""value"": ""0x07""}, {""expr"": ""in[7]"", ""value"": ""0x08""}, {""expr"": ""out[0]"", ""value"": ""0x00""}, {""expr"": ""out[1]"", ""value"": ""0x00""}, {""expr"": ""out[2]"", ""value"": ""0x00""}, {""expr"": ""out[3]"", ""value"": ""0x00""}, {""expr"": ""out[4]"", ""value"": ""0x00""}, {""expr"": ""out[5]"", ""value"": ""0x00""}, {""expr"": ""out[6]"", ""value"": ""0x00""}, {""expr"": ""out[7]"", ""value"": ""0x00""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*out"", ""value"": ""[0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80]"", ""funcName"": ""des_crypt""}, {""expr"": ""key"", ""value"": 0, ""funcName"": ""des_crypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 3: Input and output buffers are the same"", ""inputs"": [{""expr"": ""in[0]"", ""value"": ""0x01""}, {""expr"": ""in[1]"", ""value"": ""0x02""}, {""expr"": ""in[2]"", ""value"": ""0x03""}, {""expr"": ""in[3]"", ""value"": ""0x04""}, {""expr"": ""in[4]"", ""value"": ""0x05""}, {""expr"": ""in[5]"", ""value"": ""0x06""}, {""expr"": ""in[6]"", ""value"": ""0x07""}, {""expr"": ""in[7]"", ""value"": ""0x08""}, {""expr"": ""out[0]"", ""value"": ""0x01""}, {""expr"": ""out[1]"", ""value"": ""0x02""}, {""expr"": ""out[2]"", ""value"": ""0x03""}, {""expr"": ""out[3]"", ""value"": ""0x04""}, {""expr"": ""out[4]"", ""value"": ""0x05""}, {""expr"": ""out[5]"", ""value"": ""0x06""}, {""expr"": ""out[6]"", ""value"": ""0x07""}, {""expr"": ""out[7]"", ""value"": ""0x08""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*out"", ""value"": ""[0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80]"", ""funcName"": ""des_crypt""}, {""expr"": ""key"", ""value"": 0, ""funcName"": ""des_crypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 4: All zero input"", ""inputs"": [{""expr"": ""in[0]"", ""value"": ""0x00""}, {""expr"": ""in[1]"", ""value"": ""0x00""}, {""expr"": ""in[2]"", ""value"": ""0x00""}, {""expr"": ""in[3]"", ""value"": ""0x00""}, {""expr"": ""in[4]"", ""value"": ""0x00""}, {""expr"": ""in[5]"", ""value"": ""0x00""}, {""expr"": ""in[6]"", ""value"": ""0x00""}, {""expr"": ""in[7]"", ""value"": ""0x00""}, {""expr"": ""out[0]"", ""value"": ""0x00""}, {""expr"": ""out[1]"", ""value"": ""0x00""}, {""expr"": ""out[2]"", ""value"": ""0x00""}, {""expr"": ""out[3]"", ""value"": ""0x00""}, {""expr"": ""out[4]"", ""value"": ""0x00""}, {""expr"": ""out[5]"", ""value"": ""0x00""}, {""expr"": ""out[6]"", ""value"": ""0x00""}, {""expr"": ""out[7]"", ""value"": ""0x00""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*out"", ""value"": ""[0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80]"", ""funcName"": ""des_crypt""}, {""expr"": ""key"", ""value"": 0, ""funcName"": ""des_crypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 5: All zero keys"", ""inputs"": [{""expr"": ""in[0]"", ""value"": ""0x01""}, {""expr"": ""in[1]"", ""value"": ""0x02""}, {""expr"": ""in[2]"", ""value"": ""0x03""}, {""expr"": ""in[3]"", ""value"": ""0x04""}, {""expr"": ""in[4]"", ""value"": ""0x05""}, {""expr"": ""in[5]"", ""value"": ""0x06""}, {""expr"": ""in[6]"", ""value"": ""0x07""}, {""expr"": ""in[7]"", ""value"": ""0x08""}, {""expr"": ""out[0]"", ""value"": ""0x00""}, {""expr"": ""out[1]"", ""value"": ""0x00""}, {""expr"": ""out[2]"", ""value"": ""0x00""}, {""expr"": ""out[3]"", ""value"": ""0x00""}, {""expr"": ""out[4]"", ""value"": ""0x00""}, {""expr"": ""out[5]"", ""value"": ""0x00""}, {""expr"": ""out[6]"", ""value"": ""0x00""}, {""expr"": ""out[7]"", ""value"": ""0x00""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*out"", ""value"": ""[0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80]"", ""funcName"": ""des_crypt""}, {""expr"": ""key"", ""value"": 0, ""funcName"": ""des_crypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 6: Random input and keys"", ""inputs"": [{""expr"": ""in[0]"", ""value"": ""0xAA""}, {""expr"": ""in[1]"", ""value"": ""0xBB""}, {""expr"": ""in[2]"", ""value"": ""0xCC""}, {""expr"": ""in[3]"", ""value"": ""0xDD""}, {""expr"": ""in[4]"", ""value"": ""0xEE""}, {""expr"": ""in[5]"", ""value"": ""0xFF""}, {""expr"": ""in[6]"", ""value"": ""0x11""}, {""expr"": ""in[7]"", ""value"": ""0x22""}, {""expr"": ""out[0]"", ""value"": ""0x00""}, {""expr"": ""out[1]"", ""value"": ""0x00""}, {""expr"": ""out[2]"", ""value"": ""0x00""}, {""expr"": ""out[3]"", ""value"": ""0x00""}, {""expr"": ""out[4]"", ""value"": ""0x00""}, {""expr"": ""out[5]"", ""value"": ""0x00""}, {""expr"": ""out[6]"", ""value"": ""0x00""}, {""expr"": ""out[7]"", ""value"": ""0x00""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*in"", ""value"": 0, ""funcName"": ""des_crypt""}, {""expr"": ""*out"", ""value"": ""[0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA]"", ""funcName"": ""des_crypt""}, {""expr"": ""key"", ""value"": 0, ""funcName"": ""des_crypt""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
md2,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
static const BYTE s[256] 
void md2_transform(MD2_CTX *ctx, BYTE data[]) 
{ 
 int j,k,t; 
 for (j=0; j < 16; ++j) { 
  ctx->state[j + 16] = data[j]; 
  ctx->state[j + 32] = (ctx->state[j+16] ^ ctx->state[j]); 
 } 
 t = 0; 
 for (j = 0; j < 18; ++j) { 
  for (k = 0; k < 48; ++k) { 
   ctx->state[k] ^= s[t]; 
   t = ctx->state[k]; 
  } 
  t = (t+j) & 0xFF; 
 } 
 t = ctx->checksum[15]; 
 for (j=0; j < 16; ++j) { 
  ctx->checksum[j] ^= s[data[j] ^ t]; 
  t = ctx->checksum[j]; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""s"", ""type"": ""const BYTE [256]"", ""value"": ""[0]""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
static const BYTE s[256] 
void md2_transform(MD2_CTX *ctx, BYTE data[]) 
{ 
 int j,k,t; 
 for (j=0; j < 16; ++j) { 
  ctx->state[j + 16] = data[j]; 
  ctx->state[j + 32] = (ctx->state[j+16] ^ ctx->state[j]); 
 } 
 t = 0; 
 for (j = 0; j < 18; ++j) { 
  for (k = 0; k < 48; ++k) { 
   ctx->state[k] ^= s[t]; 
   t = ctx->state[k]; 
  } 
  t = (t+j) & 0xFF; 
 } 
 t = ctx->checksum[15]; 
 for (j=0; j < 16; ++j) { 
  ctx->checksum[j] ^= s[data[j] ^ t]; 
  t = ctx->checksum[j]; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""s"", ""type"": ""const BYTE [256]"", ""value"": ""[0]""}], ""outputs"": []}
{other test cases}
","{""func"": ""md2_transform"", ""file"": """", ""cases"": [{""desc"": ""Test with all zero data and state"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]""}, {""expr"": ""(ctx_PTRTO[0]).checksum"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]""}, {""expr"": ""data"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]""}, {""expr"": ""s"", ""value"": ""[0, 1, 2, ..., 255]""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state"", ""value"": ""\""[...]\""""}, {""expr"": ""ctx->checksum"", ""value"": ""\""[...]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with non-zero data and random state"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state"", ""value"": ""[1, 2, 3, ..., 48]""}, {""expr"": ""(ctx_PTRTO[0]).checksum"", ""value"": ""[15, 14, 13, ..., 0]""}, {""expr"": ""data"", ""value"": ""[255, 254, 253, ..., 240]""}, {""expr"": ""s"", ""value"": ""[255, 254, 253, ..., 0]""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state"", ""value"": ""\""[...]\""""}, {""expr"": ""ctx->checksum"", ""value"": ""\""[...]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with alternating bits in data"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state"", ""value"": ""[170, 85, 170, ..., 85]""}, {""expr"": ""(ctx_PTRTO[0]).checksum"", ""value"": ""[85, 170, 85, ..., 170]""}, {""expr"": ""data"", ""value"": ""[170, 85, 170, ..., 85]""}, {""expr"": ""s"", ""value"": ""[0, 1, 2, ..., 255]""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state"", ""value"": ""\""[...]\""""}, {""expr"": ""ctx->checksum"", ""value"": ""\""[...]\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with maximum byte values in data"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state"", ""value"": ""[255, 255, 255, ..., 255]""}, {""expr"": ""(ctx_PTRTO[0]).checksum"", ""value"": ""[255, 255, 255, ..., 255]""}, {""expr"": ""data"", ""value"": ""[255, 255, 255, ..., 255]""}, {""expr"": ""s"", ""value"": ""[0, 1, 2, ..., 255]""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state"", ""value"": ""\""[...]\""""}, {""expr"": ""ctx->checksum"", ""value"": ""\""[...]\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
md2,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef 
CTX; 
void md2_init(MD2_CTX *ctx) 
{ 
 int i; 
 for (i=0; i < 48; ++i) 
  ctx->state[i] = 0; 
 for (i=0; i < 16; ++i) 
  ctx->checksum[i] = 0; 
 ctx->len = 0; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->len"", ""type"": ""int"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef 
CTX; 
void md2_init(MD2_CTX *ctx) 
{ 
 int i; 
 for (i=0; i < 48; ++i) 
  ctx->state[i] = 0; 
 for (i=0; i < 16; ++i) 
  ctx->checksum[i] = 0; 
 ctx->len = 0; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->len"", ""type"": ""int"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""md2_init"", ""file"": """", ""cases"": [{""desc"": ""Initialize MD2_CTX with all zeros"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[5]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[6]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[7]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[8]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[9]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[10]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[11]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[12]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[13]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[14]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[15]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[16]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[17]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[18]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[19]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[20]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[21]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[22]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[23]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[24]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[25]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[26]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[27]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[28]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[29]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[30]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[31]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[32]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[33]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[34]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[35]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[36]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[37]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[38]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[39]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[40]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[41]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[42]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[43]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[44]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[45]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[0]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[1]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[2]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[3]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[4]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[5]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[6]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[7]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[8]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[9]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[10]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[11]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[12]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[13]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[14]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[15]"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Initialize MD2_CTX with non-zero values"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 5}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": 2}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": 3}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": 4}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": 5}, {""expr"": ""(ctx_PTRTO[0]).state[5]"", ""value"": 6}, {""expr"": ""(ctx_PTRTO[0]).state[6]"", ""value"": 7}, {""expr"": ""(ctx_PTRTO[0]).state[7]"", ""value"": 8}, {""expr"": ""(ctx_PTRTO[0]).state[8]"", ""value"": 9}, {""expr"": ""(ctx_PTRTO[0]).state[9]"", ""value"": 10}, {""expr"": ""(ctx_PTRTO[0]).state[10]"", ""value"": 11}, {""expr"": ""(ctx_PTRTO[0]).state[11]"", ""value"": 12}, {""expr"": ""(ctx_PTRTO[0]).state[12]"", ""value"": 13}, {""expr"": ""(ctx_PTRTO[0]).state[13]"", ""value"": 14}, {""expr"": ""(ctx_PTRTO[0]).state[14]"", ""value"": 15}, {""expr"": ""(ctx_PTRTO[0]).state[15]"", ""value"": 16}, {""expr"": ""(ctx_PTRTO[0]).state[16]"", ""value"": 17}, {""expr"": ""(ctx_PTRTO[0]).state[17]"", ""value"": 18}, {""expr"": ""(ctx_PTRTO[0]).state[18]"", ""value"": 19}, {""expr"": ""(ctx_PTRTO[0]).state[19]"", ""value"": 20}, {""expr"": ""(ctx_PTRTO[0]).state[20]"", ""value"": 21}, {""expr"": ""(ctx_PTRTO[0]).state[21]"", ""value"": 22}, {""expr"": ""(ctx_PTRTO[0]).state[22]"", ""value"": 23}, {""expr"": ""(ctx_PTRTO[0]).state[23]"", ""value"": 24}, {""expr"": ""(ctx_PTRTO[0]).state[24]"", ""value"": 25}, {""expr"": ""(ctx_PTRTO[0]).state[25]"", ""value"": 26}, {""expr"": ""(ctx_PTRTO[0]).state[26]"", ""value"": 27}, {""expr"": ""(ctx_PTRTO[0]).state[27]"", ""value"": 28}, {""expr"": ""(ctx_PTRTO[0]).state[28]"", ""value"": 29}, {""expr"": ""(ctx_PTRTO[0]).state[29]"", ""value"": 30}, {""expr"": ""(ctx_PTRTO[0]).state[30]"", ""value"": 31}, {""expr"": ""(ctx_PTRTO[0]).state[31]"", ""value"": 32}, {""expr"": ""(ctx_PTRTO[0]).state[32]"", ""value"": 33}, {""expr"": ""(ctx_PTRTO[0]).state[33]"", ""value"": 34}, {""expr"": ""(ctx_PTRTO[0]).state[34]"", ""value"": 35}, {""expr"": ""(ctx_PTRTO[0]).state[35]"", ""value"": 36}, {""expr"": ""(ctx_PTRTO[0]).state[36]"", ""value"": 37}, {""expr"": ""(ctx_PTRTO[0]).state[37]"", ""value"": 38}, {""expr"": ""(ctx_PTRTO[0]).state[38]"", ""value"": 39}, {""expr"": ""(ctx_PTRTO[0]).state[39]"", ""value"": 40}, {""expr"": ""(ctx_PTRTO[0]).state[40]"", ""value"": 41}, {""expr"": ""(ctx_PTRTO[0]).state[41]"", ""value"": 42}, {""expr"": ""(ctx_PTRTO[0]).state[42]"", ""value"": 43}, {""expr"": ""(ctx_PTRTO[0]).state[43]"", ""value"": 44}, {""expr"": ""(ctx_PTRTO[0]).state[44]"", ""value"": 45}, {""expr"": ""(ctx_PTRTO[0]).state[45]"", ""value"": 46}, {""expr"": ""(ctx_PTRTO[0]).state[46]"", ""value"": 47}, {""expr"": ""(ctx_PTRTO[0]).state[47]"", ""value"": 48}, {""expr"": ""(ctx_PTRTO[0]).checksum[0]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[1]"", ""value"": 2}, {""expr"": ""(ctx_PTRTO[0]).checksum[2]"", ""value"": 3}, {""expr"": ""(ctx_PTRTO[0]).checksum[3]"", ""value"": 4}, {""expr"": ""(ctx_PTRTO[0]).checksum[4]"", ""value"": 5}, {""expr"": ""(ctx_PTRTO[0]).checksum[5]"", ""value"": 6}, {""expr"": ""(ctx_PTRTO[0]).checksum[6]"", ""value"": 7}, {""expr"": ""(ctx_PTRTO[0]).checksum[7]"", ""value"": 8}, {""expr"": ""(ctx_PTRTO[0]).checksum[8]"", ""value"": 9}, {""expr"": ""(ctx_PTRTO[0]).checksum[9]"", ""value"": 10}, {""expr"": ""(ctx_PTRTO[0]).checksum[10]"", ""value"": 11}, {""expr"": ""(ctx_PTRTO[0]).checksum[11]"", ""value"": 12}, {""expr"": ""(ctx_PTRTO[0]).checksum[12]"", ""value"": 13}, {""expr"": ""(ctx_PTRTO[0]).checksum[13]"", ""value"": 14}, {""expr"": ""(ctx_PTRTO[0]).checksum[14]"", ""value"": 15}, {""expr"": ""(ctx_PTRTO[0]).checksum[15]"", ""value"": 16}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Initialize MD2_CTX with mixed values"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 10}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[5]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[6]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[7]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[8]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[9]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[10]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[11]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[12]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[13]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[14]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[15]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[16]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[17]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[18]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[19]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[20]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[21]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[22]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[23]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[24]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[25]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[26]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[27]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[28]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[29]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[30]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[31]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[32]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[33]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[34]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[35]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[36]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[37]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[38]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[39]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[40]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[41]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[42]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[43]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).state[44]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[45]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[0]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[1]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[2]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[3]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[4]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[5]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[6]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[7]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[8]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[9]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[10]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[11]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[12]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[13]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).checksum[14]"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).checksum[15]"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Initialize MD2_CTX with maximum possible values"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[5]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[6]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[7]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[8]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[9]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[10]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[11]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[12]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[13]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[14]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[15]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[16]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[17]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[18]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[19]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[20]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[21]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[22]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[23]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[24]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[25]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[26]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[27]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[28]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[29]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[30]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[31]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[32]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[33]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[34]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[35]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[36]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[37]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[38]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[39]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[40]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[41]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[42]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[43]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[44]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).state[45]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[0]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[1]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[2]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[3]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[4]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[5]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[6]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[7]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[8]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[9]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[10]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[11]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[12]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[13]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[14]"", ""value"": 255}, {""expr"": ""(ctx_PTRTO[0]).checksum[15]"", ""value"": 255}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
md2,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
void md2_update(MD2_CTX *ctx, const BYTE data[], size_t len) 
{ 
 size_t i; 
 for (i = 0; i < len; ++i) { 
  ctx->data[ctx->len] = data[i]; 
  ctx->len++; 
  if (ctx->len == 16) { 
   md2_transform(ctx, ctx->data); 
   ctx->len = 0; 
  } 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""void md2_transform(MD2_CTX *ctx,BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""s"", ""type"": ""const BYTE [256]"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [16]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""BYTE"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
void md2_update(MD2_CTX *ctx, const BYTE data[], size_t len) 
{ 
 size_t i; 
 for (i = 0; i < len; ++i) { 
  ctx->data[ctx->len] = data[i]; 
  ctx->len++; 
  if (ctx->len == 16) { 
   md2_transform(ctx, ctx->data); 
   ctx->len = 0; 
  } 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""void md2_transform(MD2_CTX *ctx,BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""s"", ""type"": ""const BYTE [256]"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [16]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""BYTE"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""md2_update"", ""file"": """", ""cases"": [{""desc"": ""Test with empty data"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 0}, {""expr"": ""len"", ""value"": 0}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with data length less than 16"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdef""}, {""expr"": ""len"", ""value"": 6}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->data"", ""value"": ""\""abcdef\""""}, {""expr"": ""ctx->len"", ""value"": 6}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with data length exactly 16"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md2_transform""}], ""outputs"": [{""expr"": ""ctx->data"", ""value"": ""\""abcdefghijklmnop\""""}, {""expr"": ""ctx->len"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with data length greater than 16 but not a multiple of 16"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyz""}, {""expr"": ""len"", ""value"": 26}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md2_transform""}], ""outputs"": [{""expr"": ""ctx->data"", ""value"": ""\""qrstuvwxyz\""""}, {""expr"": ""ctx->len"", ""value"": 10}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with ctx->len not zero and data length to complete a block"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 10}, {""expr"": ""data"", ""value"": ""abcdef""}, {""expr"": ""len"", ""value"": 6}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md2_transform""}], ""outputs"": [{""expr"": ""ctx->data"", ""value"": ""\""abcdefghijabcdef\""""}, {""expr"": ""ctx->len"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with ctx->len not zero and data length more than needed to complete a block"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 10}, {""expr"": ""data"", ""value"": ""abcdefghijklmnop""}, {""expr"": ""len"", ""value"": 16}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md2_transform""}], ""outputs"": [{""expr"": ""ctx->data"", ""value"": ""\""ghijklmnop\""""}, {""expr"": ""ctx->len"", ""value"": 6}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
md2,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
void md2_final(MD2_CTX *ctx, BYTE hash[]) 
{ 
 int to_pad; 
 to_pad = 16 - ctx->len; 
 while (ctx->len < 16) 
  ctx->data[ctx->len++] = to_pad; 
 md2_transform(ctx, ctx->data); 
 md2_transform(ctx, ctx->checksum); 
 memcpy(hash, ctx->state, 16); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""hash"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void md2_transform(MD2_CTX *ctx,BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""s"", ""type"": ""const BYTE [256]"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [16]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
void md2_final(MD2_CTX *ctx, BYTE hash[]) 
{ 
 int to_pad; 
 to_pad = 16 - ctx->len; 
 while (ctx->len < 16) 
  ctx->data[ctx->len++] = to_pad; 
 md2_transform(ctx, ctx->data); 
 md2_transform(ctx, ctx->checksum); 
 memcpy(hash, ctx->state, 16); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->len"", ""type"": ""int"", ""value"": 0}, {""expr"": ""hash"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void md2_transform(MD2_CTX *ctx,BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""s"", ""type"": ""const BYTE [256]"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [16]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""BYTE"", ""value"": 0}]}, {""called function"": ""void * memcpy(void *anony_param_0,const void *anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_1"", ""type"": ""const void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""md2_final"", ""file"": """", ""cases"": [{""desc"": ""Padding needed to reach 16 bytes"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 10}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md2_transform""}, {""expr"": ""returnValue"", ""value"": ""\""hash\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""hash\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""ctx->state\"""", ""funcName"": ""memcpy""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""No padding needed"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 16}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md2_transform""}, {""expr"": ""returnValue"", ""value"": ""\""hash\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""hash\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""ctx->state\"""", ""funcName"": ""memcpy""}], ""outputs"": [{""expr"": ""ctx->data"", ""value"": ""\""ctx->data\""""}, {""expr"": ""ctx->len"", ""value"": 16}, {""expr"": ""hash"", ""value"": ""\""ctx->state\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Padding one byte"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 15}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md2_transform""}, {""expr"": ""returnValue"", ""value"": ""\""hash\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""hash\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""ctx->state\"""", ""funcName"": ""memcpy""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Padding all 16 bytes"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).len"", ""value"": 0}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md2_transform""}, {""expr"": ""returnValue"", ""value"": ""\""hash\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_0"", ""value"": ""\""hash\"""", ""funcName"": ""memcpy""}, {""expr"": ""anony_param_1"", ""value"": ""\""ctx->state\"""", ""funcName"": ""memcpy""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
md5,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
typedef 
CTX; 
void md5_transform(MD5_CTX *ctx, const BYTE data[]) 
{ 
 WORD a, b, c, d, m[16], i, j; 
 for (i = 0, j = 0; i < 16; ++i, j += 4) 
  m[i] = (data[j]) + (data[j + 1] << 8) + (data[j + 2] << 16) + (data[j + 3] << 24); 
 a = ctx->state[0]; 
 b = ctx->state[1]; 
 c = ctx->state[2]; 
 d = ctx->state[3]; 
 { a += ((b & c) | (~b & d)) + m[0] + 0xd76aa478; a = b + ((a << 7) | (a >> (32-7))); }; 
 { d += ((a & b) | (~a & c)) + m[1] + 0xe8c7b756; d = a + ((d << 12) | (d >> (32-12))); }; 
 { c += ((d & a) | (~d & b)) + m[2] + 0x242070db; c = d + ((c << 17) | (c >> (32-17))); }; 
 { b += ((c & d) | (~c & a)) + m[3] + 0xc1bdceee; b = c + ((b << 22) | (b >> (32-22))); }; 
 { a += ((b & c) | (~b & d)) + m[4] + 0xf57c0faf; a = b + ((a << 7) | (a >> (32-7))); }; 
 { d += ((a & b) | (~a & c)) + m[5] + 0x4787c62a; d = a + ((d << 12) | (d >> (32-12))); }; 
 { c += ((d & a) | (~d & b)) + m[6] + 0xa8304613; c = d + ((c << 17) | (c >> (32-17))); }; 
 { b += ((c & d) | (~c & a)) + m[7] + 0xfd469501; b = c + ((b << 22) | (b >> (32-22))); }; 
 { a += ((b & c) | (~b & d)) + m[8] + 0x698098d8; a = b + ((a << 7) | (a >> (32-7))); }; 
 { d += ((a & b) | (~a & c)) + m[9] + 0x8b44f7af; d = a + ((d << 12) | (d >> (32-12))); }; 
 { c += ((d & a) | (~d & b)) + m[10] + 0xffff5bb1; c = d + ((c << 17) | (c >> (32-17))); }; 
 { b += ((c & d) | (~c & a)) + m[11] + 0x895cd7be; b = c + ((b << 22) | (b >> (32-22))); }; 
 { a += ((b & c) | (~b & d)) + m[12] + 0x6b901122; a = b + ((a << 7) | (a >> (32-7))); }; 
 { d += ((a & b) | (~a & c)) + m[13] + 0xfd987193; d = a + ((d << 12) | (d >> (32-12))); }; 
 { c += ((d & a) | (~d & b)) + m[14] + 0xa679438e; c = d + ((c << 17) | (c >> (32-17))); }; 
 { b += ((c & d) | (~c & a)) + m[15] + 0x49b40821; b = c + ((b << 22) | (b >> (32-22))); }; 
 { a += ((b & d) | (c & ~d)) + m[1] + 0xf61e2562; a = b + ((a << 5) | (a >> (32-5))); }; 
 { d += ((a & c) | (b & ~c)) + m[6] + 0xc040b340; d = a + ((d << 9) | (d >> (32-9))); }; 
 { c += ((d & b) | (a & ~b)) + m[11] + 0x265e5a51; c = d + ((c << 14) | (c >> (32-14))); }; 
 { b += ((c & a) | (d & ~a)) + m[0] + 0xe9b6c7aa; b = c + ((b << 20) | (b >> (32-20))); }; 
 { a += ((b & d) | (c & ~d)) + m[5] + 0xd62f105d; a = b + ((a << 5) | (a >> (32-5))); }; 
 { d += ((a & c) | (b & ~c)) + m[10] + 0x02441453; d = a + ((d << 9) | (d >> (32-9))); }; 
 { c += ((d & b) | (a & ~b)) + m[15] + 0xd8a1e681; c = d + ((c << 14) | (c >> (32-14))); }; 
 { b += ((c & a) | (d & ~a)) + m[4] + 0xe7d3fbc8; b = c + ((b << 20) | (b >> (32-20))); }; 
 { a += ((b & d) | (c & ~d)) + m[9] + 0x21e1cde6; a = b + ((a << 5) | (a >> (32-5))); }; 
 { d += ((a & c) | (b & ~c)) + m[14] + 0xc33707d6; d = a + ((d << 9) | (d >> (32-9))); }; 
 { c += ((d & b) | (a & ~b)) + m[3] + 0xf4d50d87; c = d + ((c << 14) | (c >> (32-14))); }; 
 { b += ((c & a) | (d & ~a)) + m[8] + 0x455a14ed; b = c + ((b << 20) | (b >> (32-20))); }; 
 { a += ((b & d) | (c & ~d)) + m[13] + 0xa9e3e905; a = b + ((a << 5) | (a >> (32-5))); }; 
 { d += ((a & c) | (b & ~c)) + m[2] + 0xfcefa3f8; d = a + ((d << 9) | (d >> (32-9))); }; 
 { c += ((d & b) | (a & ~b)) + m[7] + 0x676f02d9; c = d + ((c << 14) | (c >> (32-14))); }; 
 { b += ((c & a) | (d & ~a)) + m[12] + 0x8d2a4c8a; b = c + ((b << 20) | (b >> (32-20))); }; 
 { a += (b ^ c ^ d) + m[5] + 0xfffa3942; a = b + ((a << 4) | (a >> (32-4))); }; 
 { d += (a ^ b ^ c) + m[8] + 0x8771f681; d = a + ((d << 11) | (d >> (32-11))); }; 
 { c += (d ^ a ^ b) + m[11] + 0x6d9d6122; c = d + ((c << 16) | (c >> (32-16))); }; 
 { b += (c ^ d ^ a) + m[14] + 0xfde5380c; b = c + ((b << 23) | (b >> (32-23))); }; 
 { a += (b ^ c ^ d) + m[1] + 0xa4beea44; a = b + ((a << 4) | (a >> (32-4))); }; 
 { d += (a ^ b ^ c) + m[4] + 0x4bdecfa9; d = a + ((d << 11) | (d >> (32-11))); }; 
 { c += (d ^ a ^ b) + m[7] + 0xf6bb4b60; c = d + ((c << 16) | (c >> (32-16))); }; 
 { b += (c ^ d ^ a) + m[10] + 0xbebfbc70; b = c + ((b << 23) | (b >> (32-23))); }; 
 { a += (b ^ c ^ d) + m[13] + 0x289b7ec6; a = b + ((a << 4) | (a >> (32-4))); }; 
 { d += (a ^ b ^ c) + m[0] + 0xeaa127fa; d = a + ((d << 11) | (d >> (32-11))); }; 
 { c += (d ^ a ^ b) + m[3] + 0xd4ef3085; c = d + ((c << 16) | (c >> (32-16))); }; 
 { b += (c ^ d ^ a) + m[6] + 0x04881d05; b = c + ((b << 23) | (b >> (32-23))); }; 
 { a += (b ^ c ^ d) + m[9] + 0xd9d4d039; a = b + ((a << 4) | (a >> (32-4))); }; 
 { d += (a ^ b ^ c) + m[12] + 0xe6db99e5; d = a + ((d << 11) | (d >> (32-11))); }; 
 { c += (d ^ a ^ b) + m[15] + 0x1fa27cf8; c = d + ((c << 16) | (c >> (32-16))); }; 
 { b += (c ^ d ^ a) + m[2] + 0xc4ac5665; b = c + ((b << 23) | (b >> (32-23))); }; 
 { a += (c ^ (b | ~d)) + m[0] + 0xf4292244; a = b + ((a << 6) | (a >> (32-6))); }; 
 { d += (b ^ (a | ~c)) + m[7] + 0x432aff97; d = a + ((d << 10) | (d >> (32-10))); }; 
 { c += (a ^ (d | ~b)) + m[14] + 0xab9423a7; c = d + ((c << 15) | (c >> (32-15))); }; 
 { b += (d ^ (c | ~a)) + m[5] + 0xfc93a039; b = c + ((b << 21) | (b >> (32-21))); }; 
 { a += (c ^ (b | ~d)) + m[12] + 0x655b59c3; a = b + ((a << 6) | (a >> (32-6))); }; 
 { d += (b ^ (a | ~c)) + m[3] + 0x8f0ccc92; d = a + ((d << 10) | (d >> (32-10))); }; 
 { c += (a ^ (d | ~b)) + m[10] + 0xffeff47d; c = d + ((c << 15) | (c >> (32-15))); }; 
 { b += (d ^ (c | ~a)) + m[1] + 0x85845dd1; b = c + ((b << 21) | (b >> (32-21))); }; 
 { a += (c ^ (b | ~d)) + m[8] + 0x6fa87e4f; a = b + ((a << 6) | (a >> (32-6))); }; 
 { d += (b ^ (a | ~c)) + m[15] + 0xfe2ce6e0; d = a + ((d << 10) | (d >> (32-10))); }; 
 { c += (a ^ (d | ~b)) + m[6] + 0xa3014314; c = d + ((c << 15) | (c >> (32-15))); }; 
 { b += (d ^ (c | ~a)) + m[13] + 0x4e0811a1; b = c + ((b << 21) | (b >> (32-21))); }; 
 { a += (c ^ (b | ~d)) + m[4] + 0xf7537e82; a = b + ((a << 6) | (a >> (32-6))); }; 
 { d += (b ^ (a | ~c)) + m[11] + 0xbd3af235; d = a + ((d << 10) | (d >> (32-10))); }; 
 { c += (a ^ (d | ~b)) + m[2] + 0x2ad7d2bb; c = d + ((c << 15) | (c >> (32-15))); }; 
 { b += (d ^ (c | ~a)) + m[9] + 0xeb86d391; b = c + ((b << 21) | (b >> (32-21))); }; 
 ctx->state[0] += a; 
 ctx->state[1] += b; 
 ctx->state[2] += c; 
 ctx->state[3] += d; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
typedef 
CTX; 
void md5_transform(MD5_CTX *ctx, const BYTE data[]) 
{ 
 WORD a, b, c, d, m[16], i, j; 
 for (i = 0, j = 0; i < 16; ++i, j += 4) 
  m[i] = (data[j]) + (data[j + 1] << 8) + (data[j + 2] << 16) + (data[j + 3] << 24); 
 a = ctx->state[0]; 
 b = ctx->state[1]; 
 c = ctx->state[2]; 
 d = ctx->state[3]; 
 { a += ((b & c) | (~b & d)) + m[0] + 0xd76aa478; a = b + ((a << 7) | (a >> (32-7))); }; 
 { d += ((a & b) | (~a & c)) + m[1] + 0xe8c7b756; d = a + ((d << 12) | (d >> (32-12))); }; 
 { c += ((d & a) | (~d & b)) + m[2] + 0x242070db; c = d + ((c << 17) | (c >> (32-17))); }; 
 { b += ((c & d) | (~c & a)) + m[3] + 0xc1bdceee; b = c + ((b << 22) | (b >> (32-22))); }; 
 { a += ((b & c) | (~b & d)) + m[4] + 0xf57c0faf; a = b + ((a << 7) | (a >> (32-7))); }; 
 { d += ((a & b) | (~a & c)) + m[5] + 0x4787c62a; d = a + ((d << 12) | (d >> (32-12))); }; 
 { c += ((d & a) | (~d & b)) + m[6] + 0xa8304613; c = d + ((c << 17) | (c >> (32-17))); }; 
 { b += ((c & d) | (~c & a)) + m[7] + 0xfd469501; b = c + ((b << 22) | (b >> (32-22))); }; 
 { a += ((b & c) | (~b & d)) + m[8] + 0x698098d8; a = b + ((a << 7) | (a >> (32-7))); }; 
 { d += ((a & b) | (~a & c)) + m[9] + 0x8b44f7af; d = a + ((d << 12) | (d >> (32-12))); }; 
 { c += ((d & a) | (~d & b)) + m[10] + 0xffff5bb1; c = d + ((c << 17) | (c >> (32-17))); }; 
 { b += ((c & d) | (~c & a)) + m[11] + 0x895cd7be; b = c + ((b << 22) | (b >> (32-22))); }; 
 { a += ((b & c) | (~b & d)) + m[12] + 0x6b901122; a = b + ((a << 7) | (a >> (32-7))); }; 
 { d += ((a & b) | (~a & c)) + m[13] + 0xfd987193; d = a + ((d << 12) | (d >> (32-12))); }; 
 { c += ((d & a) | (~d & b)) + m[14] + 0xa679438e; c = d + ((c << 17) | (c >> (32-17))); }; 
 { b += ((c & d) | (~c & a)) + m[15] + 0x49b40821; b = c + ((b << 22) | (b >> (32-22))); }; 
 { a += ((b & d) | (c & ~d)) + m[1] + 0xf61e2562; a = b + ((a << 5) | (a >> (32-5))); }; 
 { d += ((a & c) | (b & ~c)) + m[6] + 0xc040b340; d = a + ((d << 9) | (d >> (32-9))); }; 
 { c += ((d & b) | (a & ~b)) + m[11] + 0x265e5a51; c = d + ((c << 14) | (c >> (32-14))); }; 
 { b += ((c & a) | (d & ~a)) + m[0] + 0xe9b6c7aa; b = c + ((b << 20) | (b >> (32-20))); }; 
 { a += ((b & d) | (c & ~d)) + m[5] + 0xd62f105d; a = b + ((a << 5) | (a >> (32-5))); }; 
 { d += ((a & c) | (b & ~c)) + m[10] + 0x02441453; d = a + ((d << 9) | (d >> (32-9))); }; 
 { c += ((d & b) | (a & ~b)) + m[15] + 0xd8a1e681; c = d + ((c << 14) | (c >> (32-14))); }; 
 { b += ((c & a) | (d & ~a)) + m[4] + 0xe7d3fbc8; b = c + ((b << 20) | (b >> (32-20))); }; 
 { a += ((b & d) | (c & ~d)) + m[9] + 0x21e1cde6; a = b + ((a << 5) | (a >> (32-5))); }; 
 { d += ((a & c) | (b & ~c)) + m[14] + 0xc33707d6; d = a + ((d << 9) | (d >> (32-9))); }; 
 { c += ((d & b) | (a & ~b)) + m[3] + 0xf4d50d87; c = d + ((c << 14) | (c >> (32-14))); }; 
 { b += ((c & a) | (d & ~a)) + m[8] + 0x455a14ed; b = c + ((b << 20) | (b >> (32-20))); }; 
 { a += ((b & d) | (c & ~d)) + m[13] + 0xa9e3e905; a = b + ((a << 5) | (a >> (32-5))); }; 
 { d += ((a & c) | (b & ~c)) + m[2] + 0xfcefa3f8; d = a + ((d << 9) | (d >> (32-9))); }; 
 { c += ((d & b) | (a & ~b)) + m[7] + 0x676f02d9; c = d + ((c << 14) | (c >> (32-14))); }; 
 { b += ((c & a) | (d & ~a)) + m[12] + 0x8d2a4c8a; b = c + ((b << 20) | (b >> (32-20))); }; 
 { a += (b ^ c ^ d) + m[5] + 0xfffa3942; a = b + ((a << 4) | (a >> (32-4))); }; 
 { d += (a ^ b ^ c) + m[8] + 0x8771f681; d = a + ((d << 11) | (d >> (32-11))); }; 
 { c += (d ^ a ^ b) + m[11] + 0x6d9d6122; c = d + ((c << 16) | (c >> (32-16))); }; 
 { b += (c ^ d ^ a) + m[14] + 0xfde5380c; b = c + ((b << 23) | (b >> (32-23))); }; 
 { a += (b ^ c ^ d) + m[1] + 0xa4beea44; a = b + ((a << 4) | (a >> (32-4))); }; 
 { d += (a ^ b ^ c) + m[4] + 0x4bdecfa9; d = a + ((d << 11) | (d >> (32-11))); }; 
 { c += (d ^ a ^ b) + m[7] + 0xf6bb4b60; c = d + ((c << 16) | (c >> (32-16))); }; 
 { b += (c ^ d ^ a) + m[10] + 0xbebfbc70; b = c + ((b << 23) | (b >> (32-23))); }; 
 { a += (b ^ c ^ d) + m[13] + 0x289b7ec6; a = b + ((a << 4) | (a >> (32-4))); }; 
 { d += (a ^ b ^ c) + m[0] + 0xeaa127fa; d = a + ((d << 11) | (d >> (32-11))); }; 
 { c += (d ^ a ^ b) + m[3] + 0xd4ef3085; c = d + ((c << 16) | (c >> (32-16))); }; 
 { b += (c ^ d ^ a) + m[6] + 0x04881d05; b = c + ((b << 23) | (b >> (32-23))); }; 
 { a += (b ^ c ^ d) + m[9] + 0xd9d4d039; a = b + ((a << 4) | (a >> (32-4))); }; 
 { d += (a ^ b ^ c) + m[12] + 0xe6db99e5; d = a + ((d << 11) | (d >> (32-11))); }; 
 { c += (d ^ a ^ b) + m[15] + 0x1fa27cf8; c = d + ((c << 16) | (c >> (32-16))); }; 
 { b += (c ^ d ^ a) + m[2] + 0xc4ac5665; b = c + ((b << 23) | (b >> (32-23))); }; 
 { a += (c ^ (b | ~d)) + m[0] + 0xf4292244; a = b + ((a << 6) | (a >> (32-6))); }; 
 { d += (b ^ (a | ~c)) + m[7] + 0x432aff97; d = a + ((d << 10) | (d >> (32-10))); }; 
 { c += (a ^ (d | ~b)) + m[14] + 0xab9423a7; c = d + ((c << 15) | (c >> (32-15))); }; 
 { b += (d ^ (c | ~a)) + m[5] + 0xfc93a039; b = c + ((b << 21) | (b >> (32-21))); }; 
 { a += (c ^ (b | ~d)) + m[12] + 0x655b59c3; a = b + ((a << 6) | (a >> (32-6))); }; 
 { d += (b ^ (a | ~c)) + m[3] + 0x8f0ccc92; d = a + ((d << 10) | (d >> (32-10))); }; 
 { c += (a ^ (d | ~b)) + m[10] + 0xffeff47d; c = d + ((c << 15) | (c >> (32-15))); }; 
 { b += (d ^ (c | ~a)) + m[1] + 0x85845dd1; b = c + ((b << 21) | (b >> (32-21))); }; 
 { a += (c ^ (b | ~d)) + m[8] + 0x6fa87e4f; a = b + ((a << 6) | (a >> (32-6))); }; 
 { d += (b ^ (a | ~c)) + m[15] + 0xfe2ce6e0; d = a + ((d << 10) | (d >> (32-10))); }; 
 { c += (a ^ (d | ~b)) + m[6] + 0xa3014314; c = d + ((c << 15) | (c >> (32-15))); }; 
 { b += (d ^ (c | ~a)) + m[13] + 0x4e0811a1; b = c + ((b << 21) | (b >> (32-21))); }; 
 { a += (c ^ (b | ~d)) + m[4] + 0xf7537e82; a = b + ((a << 6) | (a >> (32-6))); }; 
 { d += (b ^ (a | ~c)) + m[11] + 0xbd3af235; d = a + ((d << 10) | (d >> (32-10))); }; 
 { c += (a ^ (d | ~b)) + m[2] + 0x2ad7d2bb; c = d + ((c << 15) | (c >> (32-15))); }; 
 { b += (d ^ (c | ~a)) + m[9] + 0xeb86d391; b = c + ((b << 21) | (b >> (32-21))); }; 
 ctx->state[0] += a; 
 ctx->state[1] += b; 
 ctx->state[2] += c; 
 ctx->state[3] += d; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""outputs"": []}
{other test cases}
","{""func"": ""md5_transform"", ""file"": """", ""cases"": [{""desc"": ""Test with all zeros in data array"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0x67452301""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0xefcdab89""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0x98badcfe""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x10325476""}, {""expr"": ""data"", ""value"": ""00000000000000000000000000000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""result_value_1\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""result_value_2\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""result_value_3\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""result_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with all ones in data array"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0x67452301""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0xefcdab89""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0x98badcfe""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x10325476""}, {""expr"": ""data"", ""value"": ""ffffffffffffffffffffffffffffffff""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""result_value_1\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""result_value_2\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""result_value_3\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""result_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with alternating bits in data array"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0x67452301""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0xefcdab89""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0x98badcfe""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x10325476""}, {""expr"": ""data"", ""value"": ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""result_value_1\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""result_value_2\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""result_value_3\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""result_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with random data"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0x67452301""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0xefcdab89""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0x98badcfe""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x10325476""}, {""expr"": ""data"", ""value"": ""1234567890abcdef1234567890abcdef""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""result_value_1\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""result_value_2\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""result_value_3\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""result_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with maximum possible data length"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 64}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 512}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0x67452301""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0xefcdab89""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0x98badcfe""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x10325476""}, {""expr"": ""data"", ""value"": ""ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""result_value_1\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""result_value_2\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""result_value_3\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""result_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with minimum possible data length"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 8}, {""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0x67452301""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0xefcdab89""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0x98badcfe""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x10325476""}, {""expr"": ""data"", ""value"": ""00""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""result_value_1\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""result_value_2\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""result_value_3\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""result_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
md5,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef 
CTX; 
void md5_init(MD5_CTX *ctx) 
{ 
 ctx->datalen = 0; 
 ctx->bitlen = 0; 
 ctx->state[0] = 0x67452301; 
 ctx->state[1] = 0xEFCDAB89; 
 ctx->state[2] = 0x98BADCFE; 
 ctx->state[3] = 0x10325476; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef 
CTX; 
void md5_init(MD5_CTX *ctx) 
{ 
 ctx->datalen = 0; 
 ctx->bitlen = 0; 
 ctx->state[0] = 0x67452301; 
 ctx->state[1] = 0xEFCDAB89; 
 ctx->state[2] = 0x98BADCFE; 
 ctx->state[3] = 0x10325476; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""md5_init"", ""file"": """", ""cases"": [{""desc"": ""Test case 1: Initialize ctx with default values"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x67452301""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xEFCDAB89""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x98BADCFE""}, {""expr"": ""ctx->state[3]"", ""value"": ""0x10325476""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 2: Initialize ctx with non-zero datalen and bitlen"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 1234}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 5678}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x67452301""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xEFCDAB89""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x98BADCFE""}, {""expr"": ""ctx->state[3]"", ""value"": ""0x10325476""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 3: Initialize ctx with maximum possible values"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 4294967295}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 18446744073709551615}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x67452301""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xEFCDAB89""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x98BADCFE""}, {""expr"": ""ctx->state[3]"", ""value"": ""0x10325476""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case 4: Initialize ctx with random values"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 42}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 9876543210}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x67452301""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xEFCDAB89""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x98BADCFE""}, {""expr"": ""ctx->state[3]"", ""value"": ""0x10325476""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
md5,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
void md5_update(MD5_CTX *ctx, const BYTE data[], size_t len) 
{ 
 size_t i; 
 for (i = 0; i < len; ++i) { 
  ctx->data[ctx->datalen] = data[i]; 
  ctx->datalen++; 
  if (ctx->datalen == 64) { 
   md5_transform(ctx, ctx->data); 
   ctx->bitlen += 512; 
   ctx->datalen = 0; 
  } 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""void md5_transform(MD5_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
void md5_update(MD5_CTX *ctx, const BYTE data[], size_t len) 
{ 
 size_t i; 
 for (i = 0; i < len; ++i) { 
  ctx->data[ctx->datalen] = data[i]; 
  ctx->datalen++; 
  if (ctx->datalen == 64) { 
   md5_transform(ctx, ctx->data); 
   ctx->bitlen += 512; 
   ctx->datalen = 0; 
  } 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""void md5_transform(MD5_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""md5_update"", ""file"": """", ""cases"": [{""desc"": ""Test with len = 0, no data to process"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""md5_transform""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with len = 1, single byte data"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""a""}, {""expr"": ""len"", ""value"": 1}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""md5_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 1}, {""expr"": ""ctx->data[0]"", ""value"": 97}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with len = 64, exactly fills buffer"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmn""}, {""expr"": ""len"", ""value"": 64}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""md5_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 512}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with len = 65, buffer overflow"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnz""}, {""expr"": ""len"", ""value"": 65}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""md5_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 1}, {""expr"": ""ctx->bitlen"", ""value"": 512}, {""expr"": ""ctx->data[0]"", ""value"": 122}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with initial datalen = 63, len = 1, triggers transform"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 63}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""a""}, {""expr"": ""len"", ""value"": 1}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""md5_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 512}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with initial datalen = 63, len = 2, triggers transform and processes remaining data"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 63}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""ab""}, {""expr"": ""len"", ""value"": 2}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""md5_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""md5_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 1}, {""expr"": ""ctx->bitlen"", ""value"": 512}, {""expr"": ""ctx->data[0]"", ""value"": 98}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
md5,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
void md5_final(MD5_CTX *ctx, BYTE hash[]) 
{ 
 size_t i; 
 i = ctx->datalen; 
 if (ctx->datalen < 56) { 
  ctx->data[i++] = 0x80; 
  while (i < 56) 
   ctx->data[i++] = 0x00; 
 } 
 else if (ctx->datalen >= 56) { 
  ctx->data[i++] = 0x80; 
  while (i < 64) 
   ctx->data[i++] = 0x00; 
  md5_transform(ctx, ctx->data); 
  memset(ctx->data, 0, 56); 
 } 
 ctx->bitlen += ctx->datalen * 8; 
 ctx->data[56] = ctx->bitlen; 
 ctx->data[57] = ctx->bitlen >> 8; 
 ctx->data[58] = ctx->bitlen >> 16; 
 ctx->data[59] = ctx->bitlen >> 24; 
 ctx->data[60] = ctx->bitlen >> 32; 
 ctx->data[61] = ctx->bitlen >> 40; 
 ctx->data[62] = ctx->bitlen >> 48; 
 ctx->data[63] = ctx->bitlen >> 56; 
 md5_transform(ctx, ctx->data); 
 for (i = 0; i < 4; ++i) { 
  hash[i] = (ctx->state[0] >> (i * 8)) & 0x000000ff; 
  hash[i + 4] = (ctx->state[1] >> (i * 8)) & 0x000000ff; 
  hash[i + 8] = (ctx->state[2] >> (i * 8)) & 0x000000ff; 
  hash[i + 12] = (ctx->state[3] >> (i * 8)) & 0x000000ff; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""hash"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void md5_transform(MD5_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
CTX; 
void md5_final(MD5_CTX *ctx, BYTE hash[]) 
{ 
 size_t i; 
 i = ctx->datalen; 
 if (ctx->datalen < 56) { 
  ctx->data[i++] = 0x80; 
  while (i < 56) 
   ctx->data[i++] = 0x00; 
 } 
 else if (ctx->datalen >= 56) { 
  ctx->data[i++] = 0x80; 
  while (i < 64) 
   ctx->data[i++] = 0x00; 
  md5_transform(ctx, ctx->data); 
  memset(ctx->data, 0, 56); 
 } 
 ctx->bitlen += ctx->datalen * 8; 
 ctx->data[56] = ctx->bitlen; 
 ctx->data[57] = ctx->bitlen >> 8; 
 ctx->data[58] = ctx->bitlen >> 16; 
 ctx->data[59] = ctx->bitlen >> 24; 
 ctx->data[60] = ctx->bitlen >> 32; 
 ctx->data[61] = ctx->bitlen >> 40; 
 ctx->data[62] = ctx->bitlen >> 48; 
 ctx->data[63] = ctx->bitlen >> 56; 
 md5_transform(ctx, ctx->data); 
 for (i = 0; i < 4; ++i) { 
  hash[i] = (ctx->state[0] >> (i * 8)) & 0x000000ff; 
  hash[i + 4] = (ctx->state[1] >> (i * 8)) & 0x000000ff; 
  hash[i + 8] = (ctx->state[2] >> (i * 8)) & 0x000000ff; 
  hash[i + 12] = (ctx->state[3] >> (i * 8)) & 0x000000ff; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""hash"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void md5_transform(MD5_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""md5_final"", ""file"": """", ""cases"": [], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
rot-13,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
void rot13(char str[]) 
{ 
   int case_type, idx, len; 
   for (idx = 0, len = strlen(str); idx < len; idx++) { 
      if (str[idx] < 'A' || (str[idx] > 'Z' && str[idx] < 'a') || str[idx] > 'z') 
         continue; 
      if (str[idx] >= 'a') 
         case_type = 'a'; 
      else 
         case_type = 'A'; 
      str[idx] = (str[idx] + 13) % (case_type + 26); 
      if (str[idx] < 26) 
         str[idx] += case_type; 
   } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""str"", ""type"": ""char *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""size_t strlen(const char *anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""*anony_param_0"", ""type"": ""const char"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
void rot13(char str[]) 
{ 
   int case_type, idx, len; 
   for (idx = 0, len = strlen(str); idx < len; idx++) { 
      if (str[idx] < 'A' || (str[idx] > 'Z' && str[idx] < 'a') || str[idx] > 'z') 
         continue; 
      if (str[idx] >= 'a') 
         case_type = 'a'; 
      else 
         case_type = 'A'; 
      str[idx] = (str[idx] + 13) % (case_type + 26); 
      if (str[idx] < 26) 
         str[idx] += case_type; 
   } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""str"", ""type"": ""char *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""size_t strlen(const char *anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""*anony_param_0"", ""type"": ""const char"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""rot13"", ""file"": """", ""cases"": [{""desc"": ""Test case with a simple lowercase string"", ""inputs"": [{""expr"": ""str"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 3, ""funcName"": ""strlen""}], ""outputs"": [{""expr"": ""str"", ""value"": ""\""nop\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with a simple uppercase string"", ""inputs"": [{""expr"": ""str"", ""value"": ""ABC""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 3, ""funcName"": ""strlen""}], ""outputs"": [{""expr"": ""str"", ""value"": ""\""NOP\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with mixed case string"", ""inputs"": [{""expr"": ""str"", ""value"": ""aBcDeF""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 6, ""funcName"": ""strlen""}], ""outputs"": [{""expr"": ""str"", ""value"": ""\""nOpQrS\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with non-alphabetic characters"", ""inputs"": [{""expr"": ""str"", ""value"": ""123abc!@#""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 9, ""funcName"": ""strlen""}], ""outputs"": [{""expr"": ""str"", ""value"": ""\""123nop!@#\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with empty string"", ""inputs"": [], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""strlen""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with string containing only non-alphabetic characters"", ""inputs"": [{""expr"": ""str"", ""value"": ""123!@#""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 6, ""funcName"": ""strlen""}], ""outputs"": [{""expr"": ""str"", ""value"": ""\""123!@#\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with string containing alphabetic and non-alphabetic characters"", ""inputs"": [{""expr"": ""str"", ""value"": ""a1b2c3""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 6, ""funcName"": ""strlen""}], ""outputs"": [{""expr"": ""str"", ""value"": ""\""n1o2p3\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
sha1,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
typedef 
_CTX; 
void sha1_transform(SHA1_CTX *ctx, const BYTE data[]) 
{ 
 WORD a, b, c, d, e, i, j, t, m[80]; 
 for (i = 0, j = 0; i < 16; ++i, j += 4) 
  m[i] = (data[j] << 24) + (data[j + 1] << 16) + (data[j + 2] << 8) + (data[j + 3]); 
 for ( ; i < 80; ++i) { 
  m[i] = (m[i - 3] ^ m[i - 8] ^ m[i - 14] ^ m[i - 16]); 
  m[i] = (m[i] << 1) | (m[i] >> 31); 
 } 
 a = ctx->state[0]; 
 b = ctx->state[1]; 
 c = ctx->state[2]; 
 d = ctx->state[3]; 
 e = ctx->state[4]; 
 for (i = 0; i < 20; ++i) { 
  t = ((a << 5) | (a >> (32 - 5))) + ((b & c) ^ (~b & d)) + e + ctx->k[0] + m[i]; 
  e = d; 
  d = c; 
  c = ((b << 30) | (b >> (32 - 30))); 
  b = a; 
  a = t; 
 } 
 for ( ; i < 40; ++i) { 
  t = ((a << 5) | (a >> (32 - 5))) + (b ^ c ^ d) + e + ctx->k[1] + m[i]; 
  e = d; 
  d = c; 
  c = ((b << 30) | (b >> (32 - 30))); 
  b = a; 
  a = t; 
 } 
 for ( ; i < 60; ++i) { 
  t = ((a << 5) | (a >> (32 - 5))) + ((b & c) ^ (b & d) ^ (c & d)) + e + ctx->k[2] + m[i]; 
  e = d; 
  d = c; 
  c = ((b << 30) | (b >> (32 - 30))); 
  b = a; 
  a = t; 
 } 
 for ( ; i < 80; ++i) { 
  t = ((a << 5) | (a >> (32 - 5))) + (b ^ c ^ d) + e + ctx->k[3] + m[i]; 
  e = d; 
  d = c; 
  c = ((b << 30) | (b >> (32 - 30))); 
  b = a; 
  a = t; 
 } 
 ctx->state[0] += a; 
 ctx->state[1] += b; 
 ctx->state[2] += c; 
 ctx->state[3] += d; 
 ctx->state[4] += e; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
typedef 
_CTX; 
void sha1_transform(SHA1_CTX *ctx, const BYTE data[]) 
{ 
 WORD a, b, c, d, e, i, j, t, m[80]; 
 for (i = 0, j = 0; i < 16; ++i, j += 4) 
  m[i] = (data[j] << 24) + (data[j + 1] << 16) + (data[j + 2] << 8) + (data[j + 3]); 
 for ( ; i < 80; ++i) { 
  m[i] = (m[i - 3] ^ m[i - 8] ^ m[i - 14] ^ m[i - 16]); 
  m[i] = (m[i] << 1) | (m[i] >> 31); 
 } 
 a = ctx->state[0]; 
 b = ctx->state[1]; 
 c = ctx->state[2]; 
 d = ctx->state[3]; 
 e = ctx->state[4]; 
 for (i = 0; i < 20; ++i) { 
  t = ((a << 5) | (a >> (32 - 5))) + ((b & c) ^ (~b & d)) + e + ctx->k[0] + m[i]; 
  e = d; 
  d = c; 
  c = ((b << 30) | (b >> (32 - 30))); 
  b = a; 
  a = t; 
 } 
 for ( ; i < 40; ++i) { 
  t = ((a << 5) | (a >> (32 - 5))) + (b ^ c ^ d) + e + ctx->k[1] + m[i]; 
  e = d; 
  d = c; 
  c = ((b << 30) | (b >> (32 - 30))); 
  b = a; 
  a = t; 
 } 
 for ( ; i < 60; ++i) { 
  t = ((a << 5) | (a >> (32 - 5))) + ((b & c) ^ (b & d) ^ (c & d)) + e + ctx->k[2] + m[i]; 
  e = d; 
  d = c; 
  c = ((b << 30) | (b >> (32 - 30))); 
  b = a; 
  a = t; 
 } 
 for ( ; i < 80; ++i) { 
  t = ((a << 5) | (a >> (32 - 5))) + (b ^ c ^ d) + e + ctx->k[3] + m[i]; 
  e = d; 
  d = c; 
  c = ((b << 30) | (b >> (32 - 30))); 
  b = a; 
  a = t; 
 } 
 ctx->state[0] += a; 
 ctx->state[1] += b; 
 ctx->state[2] += c; 
 ctx->state[3] += d; 
 ctx->state[4] += e; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}], ""outputs"": []}
{other test cases}
","{""func"": ""sha1_transform"", ""file"": """", ""cases"": [{""desc"": ""Test case with all zeros in the initial state"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).k[0]"", ""value"": ""0x5A827999""}, {""expr"": ""(ctx_PTRTO[0]).k[1]"", ""value"": ""0x6ED9EBA1""}, {""expr"": ""(ctx_PTRTO[0]).k[2]"", ""value"": ""0x8F1BBCDC""}, {""expr"": ""(ctx_PTRTO[0]).k[3]"", ""value"": ""0xCA62C1D6""}, {""expr"": ""data"", ""value"": ""0000000000000000000000000000000000000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""expected_value_0\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""expected_value_1\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""expected_value_2\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""expected_value_3\""""}, {""expr"": ""ctx->state[4]"", ""value"": ""\""expected_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with alternating bits in the initial state"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0xAAAAAAAA""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0x55555555""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0xAAAAAAAA""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x55555555""}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": ""0xAAAAAAAA""}, {""expr"": ""(ctx_PTRTO[0]).k[0]"", ""value"": ""0x5A827999""}, {""expr"": ""(ctx_PTRTO[0]).k[1]"", ""value"": ""0x6ED9EBA1""}, {""expr"": ""(ctx_PTRTO[0]).k[2]"", ""value"": ""0x8F1BBCDC""}, {""expr"": ""(ctx_PTRTO[0]).k[3]"", ""value"": ""0xCA62C1D6""}, {""expr"": ""data"", ""value"": ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""expected_value_0\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""expected_value_1\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""expected_value_2\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""expected_value_3\""""}, {""expr"": ""ctx->state[4]"", ""value"": ""\""expected_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with maximum possible values in the initial state"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0xFFFFFFFF""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0xFFFFFFFF""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0xFFFFFFFF""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0xFFFFFFFF""}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": ""0xFFFFFFFF""}, {""expr"": ""(ctx_PTRTO[0]).k[0]"", ""value"": ""0x5A827999""}, {""expr"": ""(ctx_PTRTO[0]).k[1]"", ""value"": ""0x6ED9EBA1""}, {""expr"": ""(ctx_PTRTO[0]).k[2]"", ""value"": ""0x8F1BBCDC""}, {""expr"": ""(ctx_PTRTO[0]).k[3]"", ""value"": ""0xCA62C1D6""}, {""expr"": ""data"", ""value"": ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""expected_value_0\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""expected_value_1\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""expected_value_2\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""expected_value_3\""""}, {""expr"": ""ctx->state[4]"", ""value"": ""\""expected_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with minimum possible values in the initial state"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0x00000000""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0x00000000""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0x00000000""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x00000000""}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": ""0x00000000""}, {""expr"": ""(ctx_PTRTO[0]).k[0]"", ""value"": ""0x5A827999""}, {""expr"": ""(ctx_PTRTO[0]).k[1]"", ""value"": ""0x6ED9EBA1""}, {""expr"": ""(ctx_PTRTO[0]).k[2]"", ""value"": ""0x8F1BBCDC""}, {""expr"": ""(ctx_PTRTO[0]).k[3]"", ""value"": ""0xCA62C1D6""}, {""expr"": ""data"", ""value"": ""0000000000000000000000000000000000000000""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""expected_value_0\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""expected_value_1\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""expected_value_2\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""expected_value_3\""""}, {""expr"": ""ctx->state[4]"", ""value"": ""\""expected_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with a specific pattern in the initial state"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).state[0]"", ""value"": ""0x12345678""}, {""expr"": ""(ctx_PTRTO[0]).state[1]"", ""value"": ""0x9ABCDEF0""}, {""expr"": ""(ctx_PTRTO[0]).state[2]"", ""value"": ""0x0FEDCBA9""}, {""expr"": ""(ctx_PTRTO[0]).state[3]"", ""value"": ""0x87654321""}, {""expr"": ""(ctx_PTRTO[0]).state[4]"", ""value"": ""0x13579BDF""}, {""expr"": ""(ctx_PTRTO[0]).k[0]"", ""value"": ""0x5A827999""}, {""expr"": ""(ctx_PTRTO[0]).k[1]"", ""value"": ""0x6ED9EBA1""}, {""expr"": ""(ctx_PTRTO[0]).k[2]"", ""value"": ""0x8F1BBCDC""}, {""expr"": ""(ctx_PTRTO[0]).k[3]"", ""value"": ""0xCA62C1D6""}, {""expr"": ""data"", ""value"": ""00112233445566778899AABBCCDDEEFF""}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""\""expected_value_0\""""}, {""expr"": ""ctx->state[1]"", ""value"": ""\""expected_value_1\""""}, {""expr"": ""ctx->state[2]"", ""value"": ""\""expected_value_2\""""}, {""expr"": ""ctx->state[3]"", ""value"": ""\""expected_value_3\""""}, {""expr"": ""ctx->state[4]"", ""value"": ""\""expected_value_4\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
sha1,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef 
_CTX; 
void sha1_init(SHA1_CTX *ctx) 
{ 
 ctx->datalen = 0; 
 ctx->bitlen = 0; 
 ctx->state[0] = 0x67452301; 
 ctx->state[1] = 0xEFCDAB89; 
 ctx->state[2] = 0x98BADCFE; 
 ctx->state[3] = 0x10325476; 
 ctx->state[4] = 0xc3d2e1f0; 
 ctx->k[0] = 0x5a827999; 
 ctx->k[1] = 0x6ed9eba1; 
 ctx->k[2] = 0x8f1bbcdc; 
 ctx->k[3] = 0xca62c1d6; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef 
_CTX; 
void sha1_init(SHA1_CTX *ctx) 
{ 
 ctx->datalen = 0; 
 ctx->bitlen = 0; 
 ctx->state[0] = 0x67452301; 
 ctx->state[1] = 0xEFCDAB89; 
 ctx->state[2] = 0x98BADCFE; 
 ctx->state[3] = 0x10325476; 
 ctx->state[4] = 0xc3d2e1f0; 
 ctx->k[0] = 0x5a827999; 
 ctx->k[1] = 0x6ed9eba1; 
 ctx->k[2] = 0x8f1bbcdc; 
 ctx->k[3] = 0xca62c1d6; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""sha1_init"", ""file"": """", ""cases"": [{""desc"": ""Initial values of datalen and bitlen are set to 0"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""0x67452301""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xEFCDAB89""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x98BADCFE""}, {""expr"": ""ctx->state[3]"", ""value"": ""0x10325476""}, {""expr"": ""ctx->state[4]"", ""value"": ""0xc3d2e1f0""}, {""expr"": ""ctx->k[0]"", ""value"": ""0x5a827999""}, {""expr"": ""ctx->k[1]"", ""value"": ""0x6ed9eba1""}, {""expr"": ""ctx->k[2]"", ""value"": ""0x8f1bbcdc""}, {""expr"": ""ctx->k[3]"", ""value"": ""0xca62c1d6""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Non-zero initial values of datalen and bitlen are reset to 0"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 100}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 123456}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x67452301""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xEFCDAB89""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x98BADCFE""}, {""expr"": ""ctx->state[3]"", ""value"": ""0x10325476""}, {""expr"": ""ctx->state[4]"", ""value"": ""0xc3d2e1f0""}, {""expr"": ""ctx->k[0]"", ""value"": ""0x5a827999""}, {""expr"": ""ctx->k[1]"", ""value"": ""0x6ed9eba1""}, {""expr"": ""ctx->k[2]"", ""value"": ""0x8f1bbcdc""}, {""expr"": ""ctx->k[3]"", ""value"": ""0xca62c1d6""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""State and k values are correctly initialized"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->state[0]"", ""value"": ""0x67452301""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xEFCDAB89""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x98BADCFE""}, {""expr"": ""ctx->state[3]"", ""value"": ""0x10325476""}, {""expr"": ""ctx->state[4]"", ""value"": ""0xc3d2e1f0""}, {""expr"": ""ctx->k[0]"", ""value"": ""0x5a827999""}, {""expr"": ""ctx->k[1]"", ""value"": ""0x6ed9eba1""}, {""expr"": ""ctx->k[2]"", ""value"": ""0x8f1bbcdc""}, {""expr"": ""ctx->k[3]"", ""value"": ""0xca62c1d6""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Uninitialized context values are set correctly"", ""inputs"": [], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x67452301""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xEFCDAB89""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x98BADCFE""}, {""expr"": ""ctx->state[3]"", ""value"": ""0x10325476""}, {""expr"": ""ctx->state[4]"", ""value"": ""0xc3d2e1f0""}, {""expr"": ""ctx->k[0]"", ""value"": ""0x5a827999""}, {""expr"": ""ctx->k[1]"", ""value"": ""0x6ed9eba1""}, {""expr"": ""ctx->k[2]"", ""value"": ""0x8f1bbcdc""}, {""expr"": ""ctx->k[3]"", ""value"": ""0xca62c1d6""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
sha1,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
_CTX; 
void sha1_update(SHA1_CTX *ctx, const BYTE data[], size_t len) 
{ 
 size_t i; 
 for (i = 0; i < len; ++i) { 
  ctx->data[ctx->datalen] = data[i]; 
  ctx->datalen++; 
  if (ctx->datalen == 64) { 
   sha1_transform(ctx, ctx->data); 
   ctx->bitlen += 512; 
   ctx->datalen = 0; 
  } 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""void sha1_transform(SHA1_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef 
_CTX; 
void sha1_update(SHA1_CTX *ctx, const BYTE data[], size_t len) 
{ 
 size_t i; 
 for (i = 0; i < len; ++i) { 
  ctx->data[ctx->datalen] = data[i]; 
  ctx->datalen++; 
  if (ctx->datalen == 64) { 
   sha1_transform(ctx, ctx->data); 
   ctx->bitlen += 512; 
   ctx->datalen = 0; 
  } 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""void sha1_transform(SHA1_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""sha1_update"", ""file"": """", ""cases"": [{""desc"": ""Test with empty data array"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""len"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with data length less than 64"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 3}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 3}, {""expr"": ""ctx->bitlen"", ""value"": 0}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with data length equal to 64"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmn""}, {""expr"": ""len"", ""value"": 64}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 512}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with data length greater than 64"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuv""}, {""expr"": ""len"", ""value"": 70}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 6}, {""expr"": ""ctx->bitlen"", ""value"": 512}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with initial datalen not zero"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 60}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcd""}, {""expr"": ""len"", ""value"": 4}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 512}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with data length causing multiple transforms"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz""}, {""expr"": ""len"", ""value"": 104}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 40}, {""expr"": ""ctx->bitlen"", ""value"": 512}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
sha1,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
typedef 
_CTX; 
void sha1_final(SHA1_CTX *ctx, BYTE hash[]) 
{ 
 WORD i; 
 i = ctx->datalen; 
 if (ctx->datalen < 56) { 
  ctx->data[i++] = 0x80; 
  while (i < 56) 
   ctx->data[i++] = 0x00; 
 } 
 else { 
  ctx->data[i++] = 0x80; 
  while (i < 64) 
   ctx->data[i++] = 0x00; 
  sha1_transform(ctx, ctx->data); 
  memset(ctx->data, 0, 56); 
 } 
 ctx->bitlen += ctx->datalen * 8; 
 ctx->data[63] = ctx->bitlen; 
 ctx->data[62] = ctx->bitlen >> 8; 
 ctx->data[61] = ctx->bitlen >> 16; 
 ctx->data[60] = ctx->bitlen >> 24; 
 ctx->data[59] = ctx->bitlen >> 32; 
 ctx->data[58] = ctx->bitlen >> 40; 
 ctx->data[57] = ctx->bitlen >> 48; 
 ctx->data[56] = ctx->bitlen >> 56; 
 sha1_transform(ctx, ctx->data); 
 for (i = 0; i < 4; ++i) { 
  hash[i] = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""hash"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void sha1_transform(SHA1_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
typedef 
_CTX; 
void sha1_final(SHA1_CTX *ctx, BYTE hash[]) 
{ 
 WORD i; 
 i = ctx->datalen; 
 if (ctx->datalen < 56) { 
  ctx->data[i++] = 0x80; 
  while (i < 56) 
   ctx->data[i++] = 0x00; 
 } 
 else { 
  ctx->data[i++] = 0x80; 
  while (i < 64) 
   ctx->data[i++] = 0x00; 
  sha1_transform(ctx, ctx->data); 
  memset(ctx->data, 0, 56); 
 } 
 ctx->bitlen += ctx->datalen * 8; 
 ctx->data[63] = ctx->bitlen; 
 ctx->data[62] = ctx->bitlen >> 8; 
 ctx->data[61] = ctx->bitlen >> 16; 
 ctx->data[60] = ctx->bitlen >> 24; 
 ctx->data[59] = ctx->bitlen >> 32; 
 ctx->data[58] = ctx->bitlen >> 40; 
 ctx->data[57] = ctx->bitlen >> 48; 
 ctx->data[56] = ctx->bitlen >> 56; 
 sha1_transform(ctx, ctx->data); 
 for (i = 0; i < 4; ++i) { 
  hash[i] = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""hash"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void sha1_transform(SHA1_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""sha1_final"", ""file"": """", ""cases"": [{""desc"": ""Test case where ctx->datalen is less than 56"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 50}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where ctx->datalen is greater than or equal to 56"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 60}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where ctx->datalen is exactly 56"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 56}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where ctx->datalen is 0 and ctx->bitlen is non-zero"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 128}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where ctx->datalen is 64"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 64}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case where ctx->datalen is 55"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 55}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha1_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
sha256,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
typedef 
56_CTX; 
static const WORD k[64] 
void sha256_transform(SHA256_CTX *ctx, const BYTE data[]) 
{ 
 WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64]; 
 for (i = 0, j = 0; i < 16; ++i, j += 4) 
  m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]); 
 for ( ; i < 64; ++i) 
  m[i] = ((((m[i - 2]) >> (17)) | ((m[i - 2]) << (32-(17)))) ^ (((m[i - 2]) >> (19)) | ((m[i - 2]) << (32-(19)))) ^ ((m[i - 2]) >> 10)) + m[i - 7] + ((((m[i - 15]) >> (7)) | ((m[i - 15]) << (32-(7)))) ^ (((m[i - 15]) >> (18)) | ((m[i - 15]) << (32-(18)))) ^ ((m[i - 15]) >> 3)) + m[i - 16]; 
 a = ctx->state[0]; 
 b = ctx->state[1]; 
 c = ctx->state[2]; 
 d = ctx->state[3]; 
 e = ctx->state[4]; 
 f = ctx->state[5]; 
 g = ctx->state[6]; 
 h = ctx->state[7]; 
 for (i = 0; i < 64; ++i) { 
  t1 = h + ((((e) >> (6)) | ((e) << (32-(6)))) ^ (((e) >> (11)) | ((e) << (32-(11)))) ^ (((e) >> (25)) | ((e) << (32-(25))))) + (((e) & (f)) ^ (~(e) & (g))) + k[i] + m[i]; 
  t2 = ((((a) >> (2)) | ((a) << (32-(2)))) ^ (((a) >> (13)) | ((a) << (32-(13)))) ^ (((a) >> (22)) | ((a) << (32-(22))))) + (((a) & (b)) ^ ((a) & (c)) ^ ((b) & (c))); 
  h = g; 
  g = f; 
  f = e; 
  e = d + t1; 
  d = c; 
  c = b; 
  b = a; 
  a = t1 + t2; 
 } 
 ctx->state[0] += a; 
 ctx->state[1] += b; 
 ctx->state[2] += c; 
 ctx->state[3] += d; 
 ctx->state[4] += e; 
 ctx->state[5] += f; 
 ctx->state[6] += g; 
 ctx->state[7] += h; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""k"", ""type"": ""const WORD [64]"", ""value"": ""[0]""}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
typedef 
56_CTX; 
static const WORD k[64] 
void sha256_transform(SHA256_CTX *ctx, const BYTE data[]) 
{ 
 WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64]; 
 for (i = 0, j = 0; i < 16; ++i, j += 4) 
  m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]); 
 for ( ; i < 64; ++i) 
  m[i] = ((((m[i - 2]) >> (17)) | ((m[i - 2]) << (32-(17)))) ^ (((m[i - 2]) >> (19)) | ((m[i - 2]) << (32-(19)))) ^ ((m[i - 2]) >> 10)) + m[i - 7] + ((((m[i - 15]) >> (7)) | ((m[i - 15]) << (32-(7)))) ^ (((m[i - 15]) >> (18)) | ((m[i - 15]) << (32-(18)))) ^ ((m[i - 15]) >> 3)) + m[i - 16]; 
 a = ctx->state[0]; 
 b = ctx->state[1]; 
 c = ctx->state[2]; 
 d = ctx->state[3]; 
 e = ctx->state[4]; 
 f = ctx->state[5]; 
 g = ctx->state[6]; 
 h = ctx->state[7]; 
 for (i = 0; i < 64; ++i) { 
  t1 = h + ((((e) >> (6)) | ((e) << (32-(6)))) ^ (((e) >> (11)) | ((e) << (32-(11)))) ^ (((e) >> (25)) | ((e) << (32-(25))))) + (((e) & (f)) ^ (~(e) & (g))) + k[i] + m[i]; 
  t2 = ((((a) >> (2)) | ((a) << (32-(2)))) ^ (((a) >> (13)) | ((a) << (32-(13)))) ^ (((a) >> (22)) | ((a) << (32-(22))))) + (((a) & (b)) ^ ((a) & (c)) ^ ((b) & (c))); 
  h = g; 
  g = f; 
  f = e; 
  e = d + t1; 
  d = c; 
  c = b; 
  b = a; 
  a = t1 + t2; 
 } 
 ctx->state[0] += a; 
 ctx->state[1] += b; 
 ctx->state[2] += c; 
 ctx->state[3] += d; 
 ctx->state[4] += e; 
 ctx->state[5] += f; 
 ctx->state[6] += g; 
 ctx->state[7] += h; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""k"", ""type"": ""const WORD [64]"", ""value"": ""[0]""}], ""outputs"": []}
{other test cases}
","{""func"": ""sha256_transform"", ""file"": """", ""cases"": [{""desc"": ""Test case with all zeros in the data array"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]""}, {""expr"": ""k"", ""value"": ""[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with alternating bits in the data array"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""[170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170]""}, {""expr"": ""k"", ""value"": ""[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63]""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
sha256,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef 
56_CTX; 
void sha256_init(SHA256_CTX *ctx) 
{ 
 ctx->datalen = 0; 
 ctx->bitlen = 0; 
 ctx->state[0] = 0x6a09e667; 
 ctx->state[1] = 0xbb67ae85; 
 ctx->state[2] = 0x3c6ef372; 
 ctx->state[3] = 0xa54ff53a; 
 ctx->state[4] = 0x510e527f; 
 ctx->state[5] = 0x9b05688c; 
 ctx->state[6] = 0x1f83d9ab; 
 ctx->state[7] = 0x5be0cd19; 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef 
56_CTX; 
void sha256_init(SHA256_CTX *ctx) 
{ 
 ctx->datalen = 0; 
 ctx->bitlen = 0; 
 ctx->state[0] = 0x6a09e667; 
 ctx->state[1] = 0xbb67ae85; 
 ctx->state[2] = 0x3c6ef372; 
 ctx->state[3] = 0xa54ff53a; 
 ctx->state[4] = 0x510e527f; 
 ctx->state[5] = 0x9b05688c; 
 ctx->state[6] = 0x1f83d9ab; 
 ctx->state[7] = 0x5be0cd19; 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}], ""outputs"": []}
{other test cases}
","{""func"": ""sha256_init"", ""file"": """", ""cases"": [{""desc"": ""Initialize SHA256_CTX structure"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x6a09e667""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xbb67ae85""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x3c6ef372""}, {""expr"": ""ctx->state[3]"", ""value"": ""0xa54ff53a""}, {""expr"": ""ctx->state[4]"", ""value"": ""0x510e527f""}, {""expr"": ""ctx->state[5]"", ""value"": ""0x9b05688c""}, {""expr"": ""ctx->state[6]"", ""value"": ""0x1f83d9ab""}, {""expr"": ""ctx->state[7]"", ""value"": ""0x5be0cd19""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Initialize SHA256_CTX structure with non-zero datalen"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 100}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x6a09e667""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xbb67ae85""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x3c6ef372""}, {""expr"": ""ctx->state[3]"", ""value"": ""0xa54ff53a""}, {""expr"": ""ctx->state[4]"", ""value"": ""0x510e527f""}, {""expr"": ""ctx->state[5]"", ""value"": ""0x9b05688c""}, {""expr"": ""ctx->state[6]"", ""value"": ""0x1f83d9ab""}, {""expr"": ""ctx->state[7]"", ""value"": ""0x5be0cd19""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Initialize SHA256_CTX structure with non-zero bitlen"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 123456789}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x6a09e667""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xbb67ae85""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x3c6ef372""}, {""expr"": ""ctx->state[3]"", ""value"": ""0xa54ff53a""}, {""expr"": ""ctx->state[4]"", ""value"": ""0x510e527f""}, {""expr"": ""ctx->state[5]"", ""value"": ""0x9b05688c""}, {""expr"": ""ctx->state[6]"", ""value"": ""0x1f83d9ab""}, {""expr"": ""ctx->state[7]"", ""value"": ""0x5be0cd19""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Initialize SHA256_CTX structure with non-zero datalen and bitlen"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 50}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 987654321}], ""stubins"": [], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->state[0]"", ""value"": ""0x6a09e667""}, {""expr"": ""ctx->state[1]"", ""value"": ""0xbb67ae85""}, {""expr"": ""ctx->state[2]"", ""value"": ""0x3c6ef372""}, {""expr"": ""ctx->state[3]"", ""value"": ""0xa54ff53a""}, {""expr"": ""ctx->state[4]"", ""value"": ""0x510e527f""}, {""expr"": ""ctx->state[5]"", ""value"": ""0x9b05688c""}, {""expr"": ""ctx->state[6]"", ""value"": ""0x1f83d9ab""}, {""expr"": ""ctx->state[7]"", ""value"": ""0x5be0cd19""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
sha256,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
typedef 
56_CTX; 
void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len) 
{ 
 WORD i; 
 for (i = 0; i < len; ++i) { 
  ctx->data[ctx->datalen] = data[i]; 
  ctx->datalen++; 
  if (ctx->datalen == 64) { 
   sha256_transform(ctx, ctx->data); 
   ctx->bitlen += 512; 
   ctx->datalen = 0; 
  } 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""void sha256_transform(SHA256_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""k"", ""type"": ""const WORD [64]"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
typedef 
56_CTX; 
void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len) 
{ 
 WORD i; 
 for (i = 0; i < len; ++i) { 
  ctx->data[ctx->datalen] = data[i]; 
  ctx->datalen++; 
  if (ctx->datalen == 64) { 
   sha256_transform(ctx, ctx->data); 
   ctx->bitlen += 512; 
   ctx->datalen = 0; 
  } 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""data"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""void sha256_transform(SHA256_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""k"", ""type"": ""const WORD [64]"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""sha256_update"", ""file"": """", ""cases"": [{""desc"": ""Test with len = 0, no transformation should occur"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 0}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with len = 1, no transformation should occur"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""a""}, {""expr"": ""len"", ""value"": 1}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 1}, {""expr"": ""ctx->bitlen"", ""value"": 0}, {""expr"": ""ctx->data[0]"", ""value"": 97}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with len = 64, transformation should occur once"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmn""}, {""expr"": ""len"", ""value"": 64}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 512}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with len = 65, transformation should occur once and datalen should be 1"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmn0""}, {""expr"": ""len"", ""value"": 65}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 1}, {""expr"": ""ctx->bitlen"", ""value"": 512}, {""expr"": ""ctx->data[0]"", ""value"": 48}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with len = 128, transformation should occur twice"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""data"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz""}, {""expr"": ""len"", ""value"": 128}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}], ""outputs"": [{""expr"": ""ctx->datalen"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""value"": 1024}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
sha256,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
typedef 
56_CTX; 
void sha256_final(SHA256_CTX *ctx, BYTE hash[]) 
{ 
 WORD i; 
 i = ctx->datalen; 
 if (ctx->datalen < 56) { 
  ctx->data[i++] = 0x80; 
  while (i < 56) 
   ctx->data[i++] = 0x00; 
 } 
 else { 
  ctx->data[i++] = 0x80; 
  while (i < 64) 
   ctx->data[i++] = 0x00; 
  sha256_transform(ctx, ctx->data); 
  memset(ctx->data, 0, 56); 
 } 
 ctx->bitlen += ctx->datalen * 8; 
 ctx->data[63] = ctx->bitlen; 
 ctx->data[62] = ctx->bitlen >> 8; 
 ctx->data[61] = ctx->bitlen >> 16; 
 ctx->data[60] = ctx->bitlen >> 24; 
 ctx->data[59] = ctx->bitlen >> 32; 
 ctx->data[58] = ctx->bitlen >> 40; 
 ctx->data[57] = ctx->bitlen >> 48; 
 ctx->data[56] = ctx->bitlen >> 56; 
 sha256_transform(ctx, ctx->data); 
 for (i = 0; i < 4; ++i) { 
  hash[i] = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""hash"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void sha256_transform(SHA256_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""k"", ""type"": ""const WORD [64]"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}","Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
typedef unsigned int WORD; 
typedef 
56_CTX; 
void sha256_final(SHA256_CTX *ctx, BYTE hash[]) 
{ 
 WORD i; 
 i = ctx->datalen; 
 if (ctx->datalen < 56) { 
  ctx->data[i++] = 0x80; 
  while (i < 56) 
   ctx->data[i++] = 0x00; 
 } 
 else { 
  ctx->data[i++] = 0x80; 
  while (i < 64) 
   ctx->data[i++] = 0x00; 
  sha256_transform(ctx, ctx->data); 
  memset(ctx->data, 0, 56); 
 } 
 ctx->bitlen += ctx->datalen * 8; 
 ctx->data[63] = ctx->bitlen; 
 ctx->data[62] = ctx->bitlen >> 8; 
 ctx->data[61] = ctx->bitlen >> 16; 
 ctx->data[60] = ctx->bitlen >> 24; 
 ctx->data[59] = ctx->bitlen >> 32; 
 ctx->data[58] = ctx->bitlen >> 40; 
 ctx->data[57] = ctx->bitlen >> 48; 
 ctx->data[56] = ctx->bitlen >> 56; 
 sha256_transform(ctx, ctx->data); 
 for (i = 0; i < 4; ++i) { 
  hash[i] = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 4] = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 8] = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff; 
  hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""ctx->datalen"", ""type"": ""WORD"", ""value"": 0}, {""expr"": ""ctx->bitlen"", ""type"": ""unsigned long long int"", ""value"": 0}, {""expr"": ""hash"", ""type"": ""BYTE *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""void sha256_transform(SHA256_CTX *ctx,const BYTE *data)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void"", ""value"": 0}, {""expr"": ""k"", ""type"": ""const WORD [64]"", ""value"": 0}, {""expr"": ""ctx->data"", ""type"": ""BYTE [64]"", ""value"": 0}, {""expr"": ""*data"", ""type"": ""const BYTE"", ""value"": 0}]}, {""called function"": ""void * memset(void *anony_param_0,int anony_param_1,size_t anony_param_2)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""void *"", ""value"": 0}, {""expr"": ""anony_param_0"", ""type"": ""void *"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
","{""func"": ""sha256_final"", ""file"": """", ""cases"": [{""desc"": ""ctx->datalen is less than 56, no call to sha256_transform"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 40}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 320}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""ctx->datalen is greater than or equal to 56, call to sha256_transform once"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 60}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 480}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""ctx->datalen is 56, call to sha256_transform twice"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 56}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 448}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""ctx->datalen is 0, minimal data length"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 0}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 0}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""ctx->datalen is 63, maximal data length before wrapping"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 63}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 504}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""ctx->datalen is 1, minimal non-zero data length"", ""inputs"": [{""expr"": ""(ctx_PTRTO[0]).datalen"", ""value"": 1}, {""expr"": ""(ctx_PTRTO[0]).bitlen"", ""value"": 8}, {""expr"": ""hash"", ""value"": ""abc""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""k"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""ctx->data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""*data"", ""value"": 0, ""funcName"": ""sha256_transform""}, {""expr"": ""returnValue"", ""value"": 0, ""funcName"": ""memset""}, {""expr"": ""anony_param_0"", ""value"": 0, ""funcName"": ""memset""}], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""ctx"", ""userVar"": ""ctx_PTRTO""}], ""ios"": []}"
aes,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
void aes_key_setup(const BYTE key[], WORD w[], int keysize) 
{ 
 int Nb=4,Nr,Nk,idx; 
 WORD temp,Rcon[]={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000, 
                   0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000, 
                   0xab000000,0x4d000000,0x9a000000}; 
 switch (keysize) { 
  case 128: Nr = 10; Nk = 4; break; 
  case 192: Nr = 12; Nk = 6; break; 
  case 256: Nr = 14; Nk = 8; break; 
  default: return; 
 } 
 for (idx=0; idx < Nk; ++idx) { 
  w[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) | 
       ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3])); 
 } 
 for (idx = Nk; idx < Nb * (Nr+1); ++idx) { 
  temp = w[idx - 1]; 
  if ((idx % Nk) == 0) 
   temp = SubWord((((temp) << 8) | ((temp) >> 24))) ^ Rcon[(idx-1)/Nk]; 
  else if (Nk > 6 && (idx % Nk) == 4) 
   temp = SubWord(temp); 
  w[idx] = w[idx-Nk] ^ temp; 
 } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""WORD SubWord(WORD word)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": 0}]}], ""outputs"": []}","User:Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned int WORD; 
void aes_key_setup(const BYTE key[], WORD w[], int keysize) 
{ 
 int Nb=4,Nr,Nk,idx; 
 WORD temp,Rcon[]={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000, 
                   0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000, 
                   0xab000000,0x4d000000,0x9a000000}; 
 switch (keysize) { 
  case 128: Nr = 10; Nk = 4; break; 
  case 192: Nr = 12; Nk = 6; break; 
  case 256: Nr = 14; Nk = 8; break; 
  default: return; 
 } 
 for (idx=0; idx < Nk; ++idx) { 
  w[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) | 
       ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3])); 
 } 
 for (idx = Nk; idx < Nb * (Nr+1); ++idx) { 
  temp = w[idx - 1]; 
  if ((idx % Nk) == 0) 
   temp = SubWord((((temp) << 8) | ((temp) >> 24))) ^ Rcon[(idx-1)/Nk]; 
  else if (Nk > 6 && (idx % Nk) == 4) 
   temp = SubWord(temp); 
  w[idx] = w[idx-Nk] ^ temp; 
 } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""keysize"", ""type"": ""int"", ""value"": 0}], ""stubins"": [{""called function"": ""WORD SubWord(WORD word)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""aes_sbox"", ""type"": ""const BYTE [16][16]"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
AI:```json
{
  ""desc"": ""Test case with keysize 128"",
  ""inputs"": [
    {""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": [0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0xcf, 0x9f, 0x93, 0x69, 0x7b, 0x3e]},
    {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[2]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[3]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""keysize"", ""type"": ""int"", ""value"": 128}
  ],
  ""stubins"": [
    {
      ""called function"": ""WORD SubWord(WORD word)"",
      ""changed variable"": [
        {""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0x00102030}
      ]
    }
  ],
  ""outputs"": [
    {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0x2b7e1516},
    {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0x28aed2a6},
    {""expr"": ""w[2]"", ""type"": ""unsigned int"", ""value"": 0xabf7cf9f},
    {""expr"": ""w[3]"", ""type"": ""unsigned int"", ""value"": 0x93697b3e},
    {""expr"": ""w[4]"", ""type"": ""unsigned int"", ""value"": 0xa0fafe17},
    {""expr"": ""w[5]"", ""type"": ""unsigned int"", ""value"": 0x88542cb1},
    {""expr"": ""w[6]"", ""type"": ""unsigned int"", ""value"": 0x23a33939},
    {""expr"": ""w[7]"", ""type"": ""unsigned int"", ""value"": 0x2a6c7605},
    {""expr"": ""w[8]"", ""type"": ""unsigned int"", ""value"": 0xf2c295f2},
    {""expr"": ""w[9]"", ""type"": ""unsigned int"", ""value"": 0x7a96b943},
    {""expr"": ""w[10]"", ""type"": ""unsigned int"", ""value"": 0x5935807a},
    {""expr"": ""w[11]"", ""type"": ""unsigned int"", ""value"": 0x7359f67f},
    {""expr"": ""w[12]"", ""type"": ""unsigned int"", ""value"": 0x3d80477d},
    {""expr"": ""w[13]"", ""type"": ""unsigned int"", ""value"": 0x4716fe3e},
    {""expr"": ""w[14]"", ""type"": ""unsigned int"", ""value"": 0x1e237e44},
    {""expr"": ""w[15]"", ""type"": ""unsigned int"", ""value"": 0x6d7a883b},
    {""expr"": ""w[16]"", ""type"": ""unsigned int"", ""value"": 0xef44a541},
    {""expr"": ""w[17]"", ""type"": ""unsigned int"", ""value"": 0xa8525b7f},
    {""expr"": ""w[18]"", ""type"": ""unsigned int"", ""value"": 0xb671253b},
    {""expr"": ""w[19]"", ""type"": ""unsigned int"", ""value"": 0xdb0bad00},
    {""expr"": ""w[20]"", ""type"": ""unsigned int"", ""value"": 0xd4d1c6f8},
    {""expr"": ""w[21]"", ""type"": ""unsigned int"", ""value"": 0x7c839d87},
    {""expr"": ""w[22]"", ""type"": ""unsigned int"", ""value"": 0xcaf2b8bc},
    {""expr"": ""w[23]"", ""type"": ""unsigned int"", ""value"": 0x11f915bc},
    {""expr"": ""w[24]"", ""type"": ""unsigned int"", ""value"": 0x6d88a37a},
    {""expr"": ""w[25]"", ""type"": ""unsigned int"", ""value"": 0x110b3efd},
    {""expr"": ""w[26]"", ""type"": ""unsigned int"", ""value"": 0xdbf98641},
    {""expr"": ""w[27]"", ""type"": ""unsigned int"", ""value"": 0xca0093fd},
    {""expr"": ""w[28]"", ""type"": ""unsigned int"", ""value"": 0x4e54f70e},
    {""expr"": ""w[29]"", ""type"": ""unsigned int"", ""value"": 0x5f5fc9f3},
    {""expr"": ""w[30]"", ""type"": ""unsigned int"", ""value"": 0x84a64fb2},
    {""expr"": ""w[31]"", ""type"": ""unsigned int"", ""value"": 0x4ea6dc4f},
    {""expr"": ""w[32]"", ""type"": ""unsigned int"", ""value"": 0xead27321},
    {""expr"": ""w[33]"", ""type"": ""unsigned int"", ""value"": 0xb58dbad2},
    {""expr"": ""w[34]"", ""type"": ""unsigned int"", ""value"": 0x312bf560},
    {""expr"": ""w[35]"", ""type"": ""unsigned int"", ""value"": 0x7f8d292f},
    {""expr"": ""w[36]"", ""type"": ""unsigned int"", ""value"": 0xac7766f3},
    {""expr"": ""w[37]"", ""type"": ""unsigned int"", ""value"": 0x19fadc21},
    {""expr"": ""w[38]"", ""type"": ""unsigned int"", ""value"": 0x28d12941},
    {""expr"": ""w[39]"", ""type"": ""unsigned int"", ""value"": 0x575c006e},
    {""expr"": ""w[40]"", ""type"": ""unsigned int"", ""value"": 0xd014f9a8},
    {""expr"": ""w[41]"", ""type"": ""unsigned int"", ""value"": 0xc9ee2589},
    {""expr"": ""w[42]"", ""type"": ""unsigned int"", ""value"": 0xe13f0cc8},
    {""expr"": ""w[43]"", ""type"": ""unsigned int"", ""value"": 0xb6630ca6}
  ]
}
```

```json
{
  ""desc"": ""Test case with keysize 192"",
  ""inputs"": [
    {""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": [0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5, 0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b]},
    {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[2]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[3]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[4]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[5]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""keysize"", ""type"": ""int"", ""value"": 192}
  ],
  ""stubins"": [
    {
      ""called function"": ""WORD SubWord(WORD word)"",
      ""changed variable"": [
        {""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0x00102030}
      ]
    }
  ],
  ""outputs"": [
    {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0x8e73b0f7},
    {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0xda0e6452},
    {""expr"": ""w[2]"", ""type"": ""unsigned int"", ""value"": 0xc810f32b},
    {""expr"": ""w[3]"", ""type"": ""unsigned int"", ""value"": 0x809079e5},
    {""expr"": ""w[4]"", ""type"": ""unsigned int"", ""value"": 0x62f8ead2},
    {""expr"": ""w[5]"", ""type"": ""unsigned int"", ""value"": 0x522c6b7b},
    {""expr"": ""w[6]"", ""type"": ""unsigned int"", ""value"": 0xfe0c91f7},
    {""expr"": ""w[7]"", ""type"": ""unsigned int"", ""value"": 0x2402f5a5},
    {""expr"": ""w[8]"", ""type"": ""unsigned int"", ""value"": 0xec12068e},
    {""expr"": ""w[9]"", ""type"": ""unsigned int"", ""value"": 0x6c827f6b},
    {""expr"": ""w[10]"", ""type"": ""unsigned int"", ""value"": 0x0e7a95b9},
    {""expr"": ""w[11]"", ""type"": ""unsigned int"", ""value"": 0x5c56fec2},
    {""expr"": ""w[12]"", ""type"": ""unsigned int"", ""value"": 0x4db7b4bd},
    {""expr"": ""w[13]"", ""type"": ""unsigned int"", ""value"": 0x69b54118},
    {""expr"": ""w[14]"", ""type"": ""unsigned int"", ""value"": 0x85a74796},
    {""expr"": ""w[15]"", ""type"": ""unsigned int"", ""value"": 0xe92538fd},
    {""expr"": ""w[16]"", ""type"": ""unsigned int"", ""value"": 0xe75fad44},
    {""expr"": ""w[17]"", ""type"": ""unsigned int"", ""value"": 0xbb095386},
    {""expr"": ""w[18]"", ""type"": ""unsigned int"", ""value"": 0x485af057},
    {""expr"": ""w[19]"", ""type"": ""unsigned int"", ""value"": 0x21efb14f},
    {""expr"": ""w[20]"", ""type"": ""unsigned int"", ""value"": 0xa448f6d9},
    {""expr"": ""w[21]"", ""type"": ""unsigned int"", ""value"": 0x4d6dce24},
    {""expr"": ""w[22]"", ""type"": ""unsigned int"", ""value"": 0xaa326360},
    {""expr"": ""w[23]"", ""type"": ""unsigned int"", ""value"": 0x113b30e6},
    {""expr"": ""w[24]"", ""type"": ""unsigned int"", ""value"": 0xa25e7ed5},
    {""expr"": ""w[25]"", ""type"": ""unsigned int"", ""value"": 0x83b1cf9a},
    {""expr"": ""w[26]"", ""type"": ""unsigned int"", ""value"": 0x27f93943},
    {""expr"": ""w[27]"", ""type"": ""unsigned int"", ""value"": 0x6a94f767},
    {""expr"": ""w[28]"", ""type"": ""unsigned int"", ""value"": 0xc0a69407},
    {""expr"": ""w[29]"", ""type"": ""unsigned int"", ""value"": 0xd19da4e1},
    {""expr"": ""w[30]"", ""type"": ""unsigned int"", ""value"": 0xec1786eb},
    {""expr"": ""w[31]"", ""type"": ""unsigned int"", ""value"": 0x6fa64971},
    {""expr"": ""w[32]"", ""type"": ""unsigned int"", ""value"": 0x485f7032},
    {""expr"": ""w[33]"", ""type"": ""unsigned int"", ""value"": 0x22cb8755},
    {""expr"": ""w[34]"", ""type"": ""unsigned int"", ""value"": 0xe26d1352},
    {""expr"": ""w[35]"", ""type"": ""unsigned int"", ""value"": 0x33b5e7c3},
    {""expr"": ""w[36]"", ""type"": ""unsigned int"", ""value"": 0x8ec9e771},
    {""expr"": ""w[37]"", ""type"": ""unsigned int"", ""value"": 0x9ba9f7f2},
    {""expr"": ""w[38]"", ""type"": ""unsigned int"", ""value"": 0x5b6d5c3b},
    {""expr"": ""w[39]"", ""type"": ""unsigned int"", ""value"": 0x3b2e6c1f},
    {""expr"": ""w[40]"", ""type"": ""unsigned int"", ""value"": 0x2c5c1f89},
    {""expr"": ""w[41]"", ""type"": ""unsigned int"", ""value"": 0x5b7a9cfc},
    {""expr"": ""w[42]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[43]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[44]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[45]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[46]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[47]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[48]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[49]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[50]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc},
    {""expr"": ""w[51]"", ""type"": ""unsigned int"", ""value"": 0x5a7a9cfc}
  ]
}
```

```json
{
  ""desc"": ""Test case with keysize 256"",
  ""inputs"": [
    {""expr"": ""key"", ""type"": ""const BYTE *"", ""value"": [0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81, 0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4]},
    {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[2]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[3]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[4]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[5]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[6]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""w[7]"", ""type"": ""unsigned int"", ""value"": 0},
    {""expr"": ""keysize"", ""type"": ""int"", ""value"": 256}
  ],
  ""stubins"": [
    {
      ""called function"": ""WORD SubWord(WORD word)"",
      ""changed variable"": [
        {""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0x00102030}
      ]
    }
  ],
  ""outputs"": [
    {""expr"": ""w[0]"", ""type"": ""unsigned int"", ""value"": 0x603deb10},
    {""expr"": ""w[1]"", ""type"": ""unsigned int"", ""value"": 0x15ca71be},
    {""expr"": ""w[2]"", ""type"": ""unsigned int"", ""value"": 0x2b73aef0},
    {""expr"": ""w[3]"", ""type"": ""unsigned int"", ""value"": 0x857d7781},
    {""expr"": ""w[4]"", ""type"": ""unsigned int"", ""value"": 0x1f352c07},
    {""expr"": ""w[5]"", ""type"": ""unsigned int"", ""value"": 0x3b6108d7},
    {""expr"": ""w[6]"", ""type"": ""unsigned int"", ""value"": 0x2d9810a3},
    {""expr"": ""w[7]"", ""type"": ""unsigned int"", ""value"": 0x0914dff4},
    {""expr"": ""w[8]"", ""type"": ""unsigned int"", ""value"": 0x9ba35411},
    {""expr"": ""w[9
User:Well done. But the following branches are not covered. I will provide you with the uncovered conditions. Please generate test cases for the uncovered branches. The test cases you design need to be able to reach this branch and cover this branch. Do not output test cases that are repeated with the previous ones.
1. branch: default: return;}: true condition uncovered.
2. branch: case 256: Nr = 14; Nk = 8; break;: true condition uncovered.
3. branch: else if (Nk > 6 && (idx % Nk) == 4): true condition uncovered.
","{""func"": ""aes_key_setup"", ""file"": """", ""cases"": [{""desc"": ""Test case with unsupported keysize"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 0}, {""expr"": ""w_PTRTO[1]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 100}, {""expr"": ""key[0]"", ""value"": ""0x00""}, {""expr"": ""key[1]"", ""value"": ""0x00""}, {""expr"": ""key[2]"", ""value"": ""0x00""}, {""expr"": ""key[3]"", ""value"": ""0x00""}], ""stubins"": [], ""outputs"": [], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case with keysize 256"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 0}, {""expr"": ""w_PTRTO[1]"", ""value"": 0}, {""expr"": ""w_PTRTO[2]"", ""value"": 0}, {""expr"": ""w_PTRTO[3]"", ""value"": 0}, {""expr"": ""w_PTRTO[4]"", ""value"": 0}, {""expr"": ""w_PTRTO[5]"", ""value"": 0}, {""expr"": ""w_PTRTO[6]"", ""value"": 0}, {""expr"": ""w_PTRTO[7]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 256}, {""expr"": ""key[0]"", ""value"": ""0x60""}, {""expr"": ""key[1]"", ""value"": ""0x3d""}, {""expr"": ""key[2]"", ""value"": ""0xeb""}, {""expr"": ""key[3]"", ""value"": ""0x10""}, {""expr"": ""key[4]"", ""value"": ""0x15""}, {""expr"": ""key[5]"", ""value"": ""0xca""}, {""expr"": ""key[6]"", ""value"": ""0x71""}, {""expr"": ""key[7]"", ""value"": ""0xbe""}, {""expr"": ""key[8]"", ""value"": ""0x2b""}, {""expr"": ""key[9]"", ""value"": ""0x73""}, {""expr"": ""key[10]"", ""value"": ""0xae""}, {""expr"": ""key[11]"", ""value"": ""0xf0""}, {""expr"": ""key[12]"", ""value"": ""0x85""}, {""expr"": ""key[13]"", ""value"": ""0x7d""}, {""expr"": ""key[14]"", ""value"": ""0x77""}, {""expr"": ""key[15]"", ""value"": ""0x81""}, {""expr"": ""key[16]"", ""value"": ""0x1f""}, {""expr"": ""key[17]"", ""value"": ""0x35""}, {""expr"": ""key[18]"", ""value"": ""0x2c""}, {""expr"": ""key[19]"", ""value"": ""0x07""}, {""expr"": ""key[20]"", ""value"": ""0x3b""}, {""expr"": ""key[21]"", ""value"": ""0x61""}, {""expr"": ""key[22]"", ""value"": ""0x08""}, {""expr"": ""key[23]"", ""value"": ""0xd7""}, {""expr"": ""key[24]"", ""value"": ""0x2d""}, {""expr"": ""key[25]"", ""value"": ""0x98""}, {""expr"": ""key[26]"", ""value"": ""0x10""}, {""expr"": ""key[27]"", ""value"": ""0xa3""}, {""expr"": ""key[28]"", ""value"": ""0x09""}, {""expr"": ""key[29]"", ""value"": ""0x14""}, {""expr"": ""key[30]"", ""value"": ""0xdf""}, {""expr"": ""key[31]"", ""value"": ""0xf4""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""0x00102030"", ""funcName"": ""SubWord""}], ""outputs"": [{""expr"": ""w[0]"", ""value"": ""0x603deb10""}, {""expr"": ""w[1]"", ""value"": ""0x15ca71be""}, {""expr"": ""w[2]"", ""value"": ""0x2b73aef0""}, {""expr"": ""w[3]"", ""value"": ""0x857d7781""}, {""expr"": ""w[4]"", ""value"": ""0x1f352c07""}, {""expr"": ""w[5]"", ""value"": ""0x3b6108d7""}, {""expr"": ""w[6]"", ""value"": ""0x2d9810a3""}, {""expr"": ""w[7]"", ""value"": ""0x0914dff4""}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test case for Nk > 6 and idx % Nk == 4"", ""inputs"": [{""expr"": ""w_PTRTO[0]"", ""value"": 0}, {""expr"": ""w_PTRTO[1]"", ""value"": 0}, {""expr"": ""w_PTRTO[2]"", ""value"": 0}, {""expr"": ""w_PTRTO[3]"", ""value"": 0}, {""expr"": ""w_PTRTO[4]"", ""value"": 0}, {""expr"": ""w_PTRTO[5]"", ""value"": 0}, {""expr"": ""w_PTRTO[6]"", ""value"": 0}, {""expr"": ""w_PTRTO[7]"", ""value"": 0}, {""expr"": ""keysize"", ""value"": 256}, {""expr"": ""key[0]"", ""value"": ""0x60""}, {""expr"": ""key[1]"", ""value"": ""0x3d""}, {""expr"": ""key[2]"", ""value"": ""0xeb""}, {""expr"": ""key[3]"", ""value"": ""0x10""}, {""expr"": ""key[4]"", ""value"": ""0x15""}, {""expr"": ""key[5]"", ""value"": ""0xca""}, {""expr"": ""key[6]"", ""value"": ""0x71""}, {""expr"": ""key[7]"", ""value"": ""0xbe""}, {""expr"": ""key[8]"", ""value"": ""0x2b""}, {""expr"": ""key[9]"", ""value"": ""0x73""}, {""expr"": ""key[10]"", ""value"": ""0xae""}, {""expr"": ""key[11]"", ""value"": ""0xf0""}, {""expr"": ""key[12]"", ""value"": ""0x85""}, {""expr"": ""key[13]"", ""value"": ""0x7d""}, {""expr"": ""key[14]"", ""value"": ""0x77""}, {""expr"": ""key[15]"", ""value"": ""0x81""}, {""expr"": ""key[16]"", ""value"": ""0x1f""}, {""expr"": ""key[17]"", ""value"": ""0x35""}, {""expr"": ""key[18]"", ""value"": ""0x2c""}, {""expr"": ""key[19]"", ""value"": ""0x07""}, {""expr"": ""key[20]"", ""value"": ""0x3b""}, {""expr"": ""key[21]"", ""value"": ""0x61""}, {""expr"": ""key[22]"", ""value"": ""0x08""}, {""expr"": ""key[23]"", ""value"": ""0xd7""}, {""expr"": ""key[24]"", ""value"": ""0x2d""}, {""expr"": ""key[25]"", ""value"": ""0x98""}, {""expr"": ""key[26]"", ""value"": ""0x10""}, {""expr"": ""key[27]"", ""value"": ""0xa3""}, {""expr"": ""key[28]"", ""value"": ""0x09""}, {""expr"": ""key[29]"", ""value"": ""0x14""}, {""expr"": ""key[30]"", ""value"": ""0xdf""}, {""expr"": ""key[31]"", ""value"": ""0xf4""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": ""0xabcdef01"", ""funcName"": ""SubWord""}], ""outputs"": [{""expr"": ""w[4]"", ""value"": ""0xabcdef01""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [{""expr"": ""w"", ""userVar"": ""w_PTRTO""}], ""ios"": []}"
base64,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE charset[]; 
size_t base64_encode(const BYTE in[], BYTE out[], size_t len, int newline_flag) 
{ 
 size_t idx, idx2, blks, blk_ceiling, left_over, newline_count = 0; 
 blks = (len / 3); 
 left_over = len % 3; 
 if (out == ((void *) 0)) { 
  idx2 = blks * 4 ; 
  if (left_over) 
   idx2 += 4; 
  if (newline_flag) 
   idx2 += len / 57; 
 } 
 else { 
  blk_ceiling = blks * 3; 
  for (idx = 0, idx2 = 0; idx < blk_ceiling; idx += 3, idx2 += 4) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)]; 
   out[idx2 + 2] = charset[((in[idx + 1] & 0x0f) << 2) | (in[idx + 2] >> 6)]; 
   out[idx2 + 3] = charset[in[idx + 2] & 0x3F]; 
   if (((idx2 - newline_count + 4) % 76 == 0) && newline_flag) { 
    out[idx2 + 4] = '\n'; 
    idx2++; 
    newline_count++; 
   } 
  } 
  if (left_over == 1) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[(in[idx] & 0x03) << 4]; 
   out[idx2 + 2] = '='; 
   out[idx2 + 3] = '='; 
   idx2 += 4; 
  } 
  else if (left_over == 2) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)]; 
   out[idx2 + 2] = charset[(in[idx + 1] & 0x0F) << 2]; 
   out[idx2 + 3] = '='; 
   idx2 += 4; 
  } 
 } 
 return(idx2); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0}, {""expr"": ""charset"", ""type"": ""const BYTE [1]"", ""value"": ""[0]""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}]}","User:Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into two parts:input and output.We use 'expr', 'type' and 'value' key to represent an input or output data.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
static const BYTE charset[]; 
size_t base64_encode(const BYTE in[], BYTE out[], size_t len, int newline_flag) 
{ 
 size_t idx, idx2, blks, blk_ceiling, left_over, newline_count = 0; 
 blks = (len / 3); 
 left_over = len % 3; 
 if (out == ((void *) 0)) { 
  idx2 = blks * 4 ; 
  if (left_over) 
   idx2 += 4; 
  if (newline_flag) 
   idx2 += len / 57; 
 } 
 else { 
  blk_ceiling = blks * 3; 
  for (idx = 0, idx2 = 0; idx < blk_ceiling; idx += 3, idx2 += 4) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)]; 
   out[idx2 + 2] = charset[((in[idx + 1] & 0x0f) << 2) | (in[idx + 2] >> 6)]; 
   out[idx2 + 3] = charset[in[idx + 2] & 0x3F]; 
   if (((idx2 - newline_count + 4) % 76 == 0) && newline_flag) { 
    out[idx2 + 4] = '\n'; 
    idx2++; 
    newline_count++; 
   } 
  } 
  if (left_over == 1) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[(in[idx] & 0x03) << 4]; 
   out[idx2 + 2] = '='; 
   out[idx2 + 3] = '='; 
   idx2 += 4; 
  } 
  else if (left_over == 2) { 
   out[idx2] = charset[in[idx] >> 2]; 
   out[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)]; 
   out[idx2 + 2] = charset[(in[idx + 1] & 0x0F) << 2]; 
   out[idx2 + 3] = '='; 
   idx2 += 4; 
  } 
 } 
 return(idx2); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}, {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0}, {""expr"": ""charset"", ""type"": ""const BYTE [1]"", ""value"": ""[0]""}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}]}
{other test cases}
AI:Here are some additional test cases to cover various branches of the function:

```json
{
  ""desc"": ""Test with empty input and newline_flag set to 0"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": """"},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": """"},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0},
    {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0},
    {""expr"": ""charset"", ""type"": ""const BYTE [64]"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}
  ]
}
{
  ""desc"": ""Test with one byte of input and newline_flag set to 0"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""a""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": """"},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 1},
    {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0},
    {""expr"": ""charset"", ""type"": ""const BYTE [64]"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 4}
  ]
}
{
  ""desc"": ""Test with three bytes of input and newline_flag set to 0"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": """"},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 3},
    {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0},
    {""expr"": ""charset"", ""type"": ""const BYTE [64]"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 4}
  ]
}
{
  ""desc"": ""Test with three bytes of input and newline_flag set to 1"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": """"},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 3},
    {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 1},
    {""expr"": ""charset"", ""type"": ""const BYTE [64]"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 4}
  ]
}
{
  ""desc"": ""Test with 57 bytes of input and newline_flag set to 1"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": """"},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 57},
    {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 1},
    {""expr"": ""charset"", ""type"": ""const BYTE [64]"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 80}
  ]
}
{
  ""desc"": ""Test with null output buffer"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""null""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 3},
    {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0},
    {""expr"": ""charset"", ""type"": ""const BYTE [64]"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 4}
  ]
}
{
  ""desc"": ""Test with two bytes of input and newline_flag set to 0"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""ab""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": """"},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 2},
    {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 0},
    {""expr"": ""charset"", ""type"": ""const BYTE [64]"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 4}
  ]
}
{
  ""desc"": ""Test with three bytes of input and newline_flag set to 1 with output buffer"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""AAAAAAAA""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 3},
    {""expr"": ""newline_flag"", ""type"": ""int"", ""value"": 1},
    {""expr"": ""charset"", ""type"": ""const BYTE [64]"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 4}
  ]
}
```
User:Well done. But the following branches are not covered. I will provide you with the uncovered conditions. Please generate test cases for the uncovered branches. The test cases you design need to be able to reach this branch and cover this branch. Do not output test cases that are repeated with the previous ones.
1. branch: if (left_over == 1) {: true condition uncovered.
2. branch: if (((idx2 - newline_count + 4) % NEWLINE_INVL == 0) && newline_flag) {: true condition uncovered.
3. branch: else if (left_over == 2) {: true condition uncovered.
","{""func"": ""base64_encode"", ""file"": """", ""cases"": [{""desc"": ""Test with one leftover byte (left_over == 1) and newline_flag set to 0"", ""inputs"": [{""expr"": ""in"", ""value"": ""a""}, {""expr"": ""len"", ""value"": 1}, {""expr"": ""newline_flag"", ""value"": 0}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with newline_flag set to 1 and newline condition satisfied"", ""inputs"": [{""expr"": ""in"", ""value"": ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdef""}, {""expr"": ""len"", ""value"": 57}, {""expr"": ""newline_flag"", ""value"": 1}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 80}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with two leftover bytes (left_over == 2) and newline_flag set to 0"", ""inputs"": [{""expr"": ""in"", ""value"": ""ab""}, {""expr"": ""len"", ""value"": 2}, {""expr"": ""newline_flag"", ""value"": 0}, {""expr"": ""charset"", ""value"": ""[65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]""}], ""stubins"": [], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
base64,"typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
size_t base64_decode(const BYTE in[], BYTE out[], size_t len) 
{ 
 BYTE ch; 
 size_t idx, idx2, blks, blk_ceiling, left_over; 
 if (in[len - 1] == '=') 
  len--; 
 if (in[len - 1] == '=') 
  len--; 
 blks = len / 4; 
 left_over = len % 4; 
 if (out == ((void *) 0)) { 
  if (len >= 77 && in[76] == '\n') 
   len -= len / (76 + 1); 
  blks = len / 4; 
  left_over = len % 4; 
  idx = blks * 3; 
  if (left_over == 2) 
   idx ++; 
  else if (left_over == 3) 
   idx += 2; 
 } 
 else { 
  blk_ceiling = blks * 4; 
  for (idx = 0, idx2 = 0; idx2 < blk_ceiling; idx += 3, idx2 += 4) { 
   if (in[idx2] == '\n') 
    idx2++; 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   out[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2); 
   out[idx + 2] = (revchar(in[idx2 + 2]) << 6) | revchar(in[idx2 + 3]); 
  } 
  if (left_over == 2) { 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   idx++; 
  } 
  else if (left_over == 3) { 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   out[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2); 
   idx += 2; 
  } 
 } 
 return(idx); 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}]}","User:Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
typedef unsigned int size_t; 
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
typedef unsigned char BYTE; 
size_t base64_decode(const BYTE in[], BYTE out[], size_t len) 
{ 
 BYTE ch; 
 size_t idx, idx2, blks, blk_ceiling, left_over; 
 if (in[len - 1] == '=') 
  len--; 
 if (in[len - 1] == '=') 
  len--; 
 blks = len / 4; 
 left_over = len % 4; 
 if (out == ((void *) 0)) { 
  if (len >= 77 && in[76] == '\n') 
   len -= len / (76 + 1); 
  blks = len / 4; 
  left_over = len % 4; 
  idx = blks * 3; 
  if (left_over == 2) 
   idx ++; 
  else if (left_over == 3) 
   idx += 2; 
 } 
 else { 
  blk_ceiling = blks * 4; 
  for (idx = 0, idx2 = 0; idx2 < blk_ceiling; idx += 3, idx2 += 4) { 
   if (in[idx2] == '\n') 
    idx2++; 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   out[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2); 
   out[idx + 2] = (revchar(in[idx2 + 2]) << 6) | revchar(in[idx2 + 3]); 
  } 
  if (left_over == 2) { 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   idx++; 
  } 
  else if (left_over == 3) { 
   out[idx] = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4); 
   out[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2); 
   idx += 2; 
  } 
 } 
 return(idx); 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""abc""}, {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""}, {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}], ""stubins"": [{""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 0}]}], ""outputs"": [{""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}]}
{other test cases}
AI:```json
{
  ""desc"": ""Test with empty input array"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": """"},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": """"},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 0}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 0}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 0}
  ]
}
```

```json
{
  ""desc"": ""Test with input length not a multiple of 4 and no padding"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJj""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 3}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 1}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 2}
  ]
}
```

```json
{
  ""desc"": ""Test with input length a multiple of 4 and padding"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJjPQ==""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 8}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 2}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 3}
  ]
}
```

```json
{
  ""desc"": ""Test with newline characters in input and no output buffer"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJj\nZGVm""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": null},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 8}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 3}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 6}
  ]
}
```

```json
{
  ""desc"": ""Test with input length a multiple of 4 and no padding"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJjZGVm""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abcdefgh""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 8}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 4}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 6}
  ]
}
```

```json
{
  ""desc"": ""Test with input length not a multiple of 4 and padding"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJjPQ==""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 7}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 5}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 4}
  ]
}
```

```json
{
  ""desc"": ""Test with input length exactly 4 and no padding"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJj""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 4}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 6}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 3}
  ]
}
```

```json
{
  ""desc"": ""Test with input length exactly 4 with padding"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJjPQ==""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 4}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 7}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 3}
  ]
}
```

```json
{
  ""desc"": ""Test with input length greater than 4 and no padding"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJjZGVm""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abcdefgh""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 8}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 8}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 6}
  ]
}
```

```json
{
  ""desc"": ""Test with input length greater than 4 with padding"",
  ""inputs"": [
    {""expr"": ""in"", ""type"": ""const BYTE *"", ""value"": ""YWJjPQ==""},
    {""expr"": ""out"", ""type"": ""BYTE *"", ""value"": ""abc""},
    {""expr"": ""len"", ""type"": ""size_t"", ""value"": 8}
  ],
  ""stubins"": [
    {""called function"": ""BYTE revchar(char ch)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned char"", ""value"": 9}]}
  ],
  ""outputs"": [
    {""expr"": ""returnValue"", ""type"": ""size_t"", ""value"": 4}
  ]
}
```

User:Well done. But the following branches are not covered. I will provide you with the uncovered conditions. Please generate test cases for the uncovered branches. The test cases you design need to be able to reach this branch and cover this branch. Do not output test cases that are repeated with the previous ones.
1. branch: else if (left_over == 3): true condition uncovered.
2. branch: if (left_over == 2): true condition uncovered.
3. branch: if (len >= 77 && in[NEWLINE_INVL] == '\n')   // Verify that newlines where used.: true condition uncovered.
4. branch: if (in[idx2] == '\n'): true condition uncovered.
","{""func"": ""base64_decode"", ""file"": """", ""cases"": [{""desc"": ""Test with leftover equal to 3 (true condition)"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJjZ""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 5}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 10, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with leftover equal to 2 (true condition)"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJj""}, {""expr"": ""out"", ""value"": ""abc""}, {""expr"": ""len"", ""value"": 6}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 11, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 4}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with input length >= 77 and newline at position 76 (true condition)"", ""inputs"": [{""expr"": ""in"", ""value"": ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\\n""}, {""expr"": ""len"", ""value"": 78}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 12, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 57}], ""doBoundary"": 0, ""ioins"": []}, {""desc"": ""Test with newline character in input (true condition)"", ""inputs"": [{""expr"": ""in"", ""value"": ""YWJj\\nZGVm""}, {""expr"": ""out"", ""value"": ""abcdefgh""}, {""expr"": ""len"", ""value"": 8}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 13, ""funcName"": ""revchar""}], ""outputs"": [{""expr"": ""returnValue"", ""value"": 6}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
rot-13,"#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
void rot13(char str[]) 
{ 
   int case_type, idx, len; 
   for (idx = 0, len = strlen(str); idx < len; idx++) { 
      if (str[idx] < 'A' || (str[idx] > 'Z' && str[idx] < 'a') || str[idx] > 'z') 
         continue; 
      if (str[idx] >= 'a') 
         case_type = 'a'; 
      else 
         case_type = 'A'; 
      str[idx] = (str[idx] + 13) % (case_type + 26); 
      if (str[idx] < 26) 
         str[idx] += case_type; 
   } 
}
","{""desc"": ""description text"", ""inputs"": [{""expr"": ""str"", ""type"": ""char *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""size_t strlen(const char *anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""*anony_param_0"", ""type"": ""const char"", ""value"": 0}]}], ""outputs"": []}","User:Please generate some test cases for the following C function.I will provide you a test case example with json format. This example is divide into three parts:inputs,outputs,stubins.We use 'expr', 'type' and 'value' key to represent an input or output data. In the stubins list, I'll provide the called function signature as well as the called function return value or pointer type parameters that the called function may change, and you'll need to decide which data to assign values to based on the test case.Please continue to generate with this format. Satisfy the following requirements.1.Assign values to the data according to the situation you want to test.2.Try to cover all branches.3.Use the stub function to simulate the return value of the called function.I will provide you with all the data that the called function may change.It is up to you to decide which values to change in each test.4.Output legal json format for each test case.
****The function under test starts****
#pragma PRQA_MACRO_MESSAGES_OFF ""offsetof"" 
void rot13(char str[]) 
{ 
   int case_type, idx, len; 
   for (idx = 0, len = strlen(str); idx < len; idx++) { 
      if (str[idx] < 'A' || (str[idx] > 'Z' && str[idx] < 'a') || str[idx] > 'z') 
         continue; 
      if (str[idx] >= 'a') 
         case_type = 'a'; 
      else 
         case_type = 'A'; 
      str[idx] = (str[idx] + 13) % (case_type + 26); 
      if (str[idx] < 26) 
         str[idx] += case_type; 
   } 
}

****The function under test ends****
{""desc"": ""description text"", ""inputs"": [{""expr"": ""str"", ""type"": ""char *"", ""value"": ""abc""}], ""stubins"": [{""called function"": ""size_t strlen(const char *anony_param_0)"", ""changed variable"": [{""expr"": ""returnValue"", ""type"": ""unsigned int"", ""value"": 0}, {""expr"": ""*anony_param_0"", ""type"": ""const char"", ""value"": 0}]}], ""outputs"": []}
{other test cases}
AI:```json
{
  ""desc"": ""Test case with a simple lowercase string"",
  ""inputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""abc""
    }
  ],
  ""stubins"": [
    {
      ""called function"": ""size_t strlen(const char *anony_param_0)"",
      ""changed variable"": [
        {
          ""expr"": ""returnValue"",
          ""type"": ""unsigned int"",
          ""value"": 3
        }
      ]
    }
  ],
  ""outputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""nop""
    }
  ]
}
```

```json
{
  ""desc"": ""Test case with a simple uppercase string"",
  ""inputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""ABC""
    }
  ],
  ""stubins"": [
    {
      ""called function"": ""size_t strlen(const char *anony_param_0)"",
      ""changed variable"": [
        {
          ""expr"": ""returnValue"",
          ""type"": ""unsigned int"",
          ""value"": 3
        }
      ]
    }
  ],
  ""outputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""NOP""
    }
  ]
}
```

```json
{
  ""desc"": ""Test case with mixed case string"",
  ""inputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""aBcDeF""
    }
  ],
  ""stubins"": [
    {
      ""called function"": ""size_t strlen(const char *anony_param_0)"",
      ""changed variable"": [
        {
          ""expr"": ""returnValue"",
          ""type"": ""unsigned int"",
          ""value"": 6
        }
      ]
    }
  ],
  ""outputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""nOpQrS""
    }
  ]
}
```

```json
{
  ""desc"": ""Test case with non-alphabetic characters"",
  ""inputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""123abc!@#""
    }
  ],
  ""stubins"": [
    {
      ""called function"": ""size_t strlen(const char *anony_param_0)"",
      ""changed variable"": [
        {
          ""expr"": ""returnValue"",
          ""type"": ""unsigned int"",
          ""value"": 9
        }
      ]
    }
  ],
  ""outputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""123nop!@#""
    }
  ]
}
```

```json
{
  ""desc"": ""Test case with empty string"",
  ""inputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": """"
    }
  ],
  ""stubins"": [
    {
      ""called function"": ""size_t strlen(const char *anony_param_0)"",
      ""changed variable"": [
        {
          ""expr"": ""returnValue"",
          ""type"": ""unsigned int"",
          ""value"": 0
        }
      ]
    }
  ],
  ""outputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": """"
    }
  ]
}
```

```json
{
  ""desc"": ""Test case with string containing only non-alphabetic characters"",
  ""inputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""123!@#""
    }
  ],
  ""stubins"": [
    {
      ""called function"": ""size_t strlen(const char *anony_param_0)"",
      ""changed variable"": [
        {
          ""expr"": ""returnValue"",
          ""type"": ""unsigned int"",
          ""value"": 6
        }
      ]
    }
  ],
  ""outputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""123!@#""
    }
  ]
}
```

```json
{
  ""desc"": ""Test case with string containing alphabetic and non-alphabetic characters"",
  ""inputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""a1b2c3""
    }
  ],
  ""stubins"": [
    {
      ""called function"": ""size_t strlen(const char *anony_param_0)"",
      ""changed variable"": [
        {
          ""expr"": ""returnValue"",
          ""type"": ""unsigned int"",
          ""value"": 6
        }
      ]
    }
  ],
  ""outputs"": [
    {
      ""expr"": ""str"",
      ""type"": ""char *"",
      ""value"": ""n1o2p3""
    }
  ]
}
```
User:Well done. But the following branches are not covered. I will provide you with the uncovered conditions. Please generate test cases for the uncovered branches. The test cases you design need to be able to reach this branch and cover this branch. Do not output test cases that are repeated with the previous ones.
1. branch: if (str[idx] < 26): true condition uncovered.
","{""func"": ""rot13"", ""file"": """", ""cases"": [{""desc"": ""Test case to cover the branch where str[idx] < 26 is true"", ""inputs"": [{""expr"": ""str"", ""value"": ""A""}], ""stubins"": [{""expr"": ""returnValue"", ""value"": 1, ""funcName"": ""strlen""}], ""outputs"": [{""expr"": ""str"", ""value"": ""\""N\""""}], ""doBoundary"": 0, ""ioins"": []}], ""userVar"": [], ""defaultPTR"": [], ""ios"": []}"
